From 7e693725b874fa4c4b19ce1e1ba41f299a54e15b Mon Sep 17 00:00:00 2001
From: David Wu <david.wu@rock-chips.com>
Date: Tue, 03 Jan 2023 18:12:44 +0800
Subject: [PATCH] net/stmmac: add PMD with basic operations

This patch introduces the stmmac PMD with basic
initialisation functions includes probe, teardown,
hardware initialisation.

Signed-off-by: David Wu <david.wu@rock-chips.com>
Change-Id: I6ecc485740b8bbb198d2d03827f101658f9f748d
---

diff --git a/drivers/net/meson.build b/drivers/net/meson.build
index 2355d1c..d4bf94f 100644
--- a/drivers/net/meson.build
+++ b/drivers/net/meson.build
@@ -53,6 +53,7 @@
         'ring',
         'sfc',
         'softnic',
+        'stmmac',
         'tap',
         'thunderx',
         'txgbe',
diff --git a/drivers/net/stmmac/common.h b/drivers/net/stmmac/common.h
new file mode 100644
index 0000000..dbf81b8
--- /dev/null
+++ b/drivers/net/stmmac/common.h
@@ -0,0 +1,655 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#include <rte_io.h>
+#include <net/if.h>
+#include "stmmac_pmd_logs.h"
+#include "descs.h"
+#include "hwif.h"
+#include "mmc.h"
+#include "stmmac.h"
+#include "stmmac_uio.h"
+
+#define lower_32_bits(x) ((uint32_t)(x))
+#define upper_32_bits(x) ((uint32_t)(((x) >> 16) >> 16))
+
+#define SPEED_10		10
+#define SPEED_100		100
+#define SPEED_1000		1000
+#define SPEED_2500		2500
+#define SPEED_5000		5000
+#define SPEED_10000		10000
+#define SPEED_14000		14000
+#define SPEED_20000		20000
+#define SPEED_25000		25000
+#define SPEED_40000		40000
+#define SPEED_50000		50000
+#define SPEED_56000		56000
+#define SPEED_100000		100000
+
+/* Synopsys Core versions */
+#define	DWMAC_CORE_3_40		0x34
+#define	DWMAC_CORE_3_50		0x35
+#define	DWMAC_CORE_4_00		0x40
+#define DWMAC_CORE_4_10		0x41
+#define DWMAC_CORE_5_00		0x50
+#define DWMAC_CORE_5_10		0x51
+#define DWXGMAC_CORE_2_10	0x21
+#define DWXLGMAC_CORE_2_00	0x20
+
+/* Device ID */
+#define DWXGMAC_ID		0x76
+#define DWXLGMAC_ID		0x27
+
+#define STMMAC_CHAN0		0	/* Always supported and default for all chips */
+
+/* TX and RX Descriptor Length, these need to be power of two.
+ * TX descriptor length less than 64 may cause transmit queue timed out error.
+ * RX descriptor length less than 64 may cause inconsistent Rx chain error.
+ */
+#define DMA_MIN_TX_SIZE		64
+#define DMA_MAX_TX_SIZE		1024
+#define DMA_DEFAULT_TX_SIZE	1024
+#define DMA_MIN_RX_SIZE		64
+#define DMA_MAX_RX_SIZE		1024
+#define DMA_DEFAULT_RX_SIZE	1024
+#define STMMAC_GET_ENTRY(x, size)	((x + 1) & (size - 1))
+
+#undef FRAME_FILTER_DEBUG
+/* #define FRAME_FILTER_DEBUG */
+
+/* Extra statistic and debug information exposed by ethtool */
+struct stmmac_extra_stats {
+	/* Transmit errors */
+	unsigned long tx_underflow;
+	unsigned long tx_carrier;
+	unsigned long tx_losscarrier;
+	unsigned long vlan_tag;
+	unsigned long tx_deferred;
+	unsigned long tx_vlan;
+	unsigned long tx_jabber;
+	unsigned long tx_frame_flushed;
+	unsigned long tx_payload_error;
+	unsigned long tx_ip_header_error;
+	/* Receive errors */
+	unsigned long rx_desc;
+	unsigned long sa_filter_fail;
+	unsigned long overflow_error;
+	unsigned long ipc_csum_error;
+	unsigned long rx_collision;
+	unsigned long rx_crc_errors;
+	unsigned long dribbling_bit;
+	unsigned long rx_length;
+	unsigned long rx_mii;
+	unsigned long rx_multicast;
+	unsigned long rx_gmac_overflow;
+	unsigned long rx_watchdog;
+	unsigned long da_rx_filter_fail;
+	unsigned long sa_rx_filter_fail;
+	unsigned long rx_missed_cntr;
+	unsigned long rx_overflow_cntr;
+	unsigned long rx_vlan;
+	unsigned long rx_split_hdr_pkt_n;
+	/* Tx/Rx IRQ error info */
+	unsigned long tx_undeflow_irq;
+	unsigned long tx_process_stopped_irq;
+	unsigned long tx_jabber_irq;
+	unsigned long rx_overflow_irq;
+	unsigned long rx_buf_unav_irq;
+	unsigned long rx_process_stopped_irq;
+	unsigned long rx_watchdog_irq;
+	unsigned long tx_early_irq;
+	unsigned long fatal_bus_error_irq;
+	/* Tx/Rx IRQ Events */
+	unsigned long rx_early_irq;
+	unsigned long threshold;
+	unsigned long tx_pkt_n;
+	unsigned long rx_pkt_n;
+	unsigned long normal_irq_n;
+	unsigned long rx_normal_irq_n;
+	unsigned long napi_poll;
+	unsigned long tx_normal_irq_n;
+	unsigned long tx_clean;
+	unsigned long tx_set_ic_bit;
+	unsigned long irq_receive_pmt_irq_n;
+	/* MMC info */
+	unsigned long mmc_tx_irq_n;
+	unsigned long mmc_rx_irq_n;
+	unsigned long mmc_rx_csum_offload_irq_n;
+	/* EEE */
+	unsigned long irq_tx_path_in_lpi_mode_n;
+	unsigned long irq_tx_path_exit_lpi_mode_n;
+	unsigned long irq_rx_path_in_lpi_mode_n;
+	unsigned long irq_rx_path_exit_lpi_mode_n;
+	unsigned long phy_eee_wakeup_error_n;
+	/* Extended RDES status */
+	unsigned long ip_hdr_err;
+	unsigned long ip_payload_err;
+	unsigned long ip_csum_bypassed;
+	unsigned long ipv4_pkt_rcvd;
+	unsigned long ipv6_pkt_rcvd;
+	unsigned long no_ptp_rx_msg_type_ext;
+	unsigned long ptp_rx_msg_type_sync;
+	unsigned long ptp_rx_msg_type_follow_up;
+	unsigned long ptp_rx_msg_type_delay_req;
+	unsigned long ptp_rx_msg_type_delay_resp;
+	unsigned long ptp_rx_msg_type_pdelay_req;
+	unsigned long ptp_rx_msg_type_pdelay_resp;
+	unsigned long ptp_rx_msg_type_pdelay_follow_up;
+	unsigned long ptp_rx_msg_type_announce;
+	unsigned long ptp_rx_msg_type_management;
+	unsigned long ptp_rx_msg_pkt_reserved_type;
+	unsigned long ptp_frame_type;
+	unsigned long ptp_ver;
+	unsigned long timestamp_dropped;
+	unsigned long av_pkt_rcvd;
+	unsigned long av_tagged_pkt_rcvd;
+	unsigned long vlan_tag_priority_val;
+	unsigned long l3_filter_match;
+	unsigned long l4_filter_match;
+	unsigned long l3_l4_filter_no_match;
+	/* PCS */
+	unsigned long irq_pcs_ane_n;
+	unsigned long irq_pcs_link_n;
+	unsigned long irq_rgmii_n;
+	unsigned long pcs_link;
+	unsigned long pcs_duplex;
+	unsigned long pcs_speed;
+	/* debug register */
+	unsigned long mtl_tx_status_fifo_full;
+	unsigned long mtl_tx_fifo_not_empty;
+	unsigned long mmtl_fifo_ctrl;
+	unsigned long mtl_tx_fifo_read_ctrl_write;
+	unsigned long mtl_tx_fifo_read_ctrl_wait;
+	unsigned long mtl_tx_fifo_read_ctrl_read;
+	unsigned long mtl_tx_fifo_read_ctrl_idle;
+	unsigned long mac_tx_in_pause;
+	unsigned long mac_tx_frame_ctrl_xfer;
+	unsigned long mac_tx_frame_ctrl_idle;
+	unsigned long mac_tx_frame_ctrl_wait;
+	unsigned long mac_tx_frame_ctrl_pause;
+	unsigned long mac_gmii_tx_proto_engine;
+	unsigned long mtl_rx_fifo_fill_level_full;
+	unsigned long mtl_rx_fifo_fill_above_thresh;
+	unsigned long mtl_rx_fifo_fill_below_thresh;
+	unsigned long mtl_rx_fifo_fill_level_empty;
+	unsigned long mtl_rx_fifo_read_ctrl_flush;
+	unsigned long mtl_rx_fifo_read_ctrl_read_data;
+	unsigned long mtl_rx_fifo_read_ctrl_status;
+	unsigned long mtl_rx_fifo_read_ctrl_idle;
+	unsigned long mtl_rx_fifo_ctrl_active;
+	unsigned long mac_rx_frame_ctrl_fifo;
+	unsigned long mac_gmii_rx_proto_engine;
+	/* TSO */
+	unsigned long tx_tso_frames;
+	unsigned long tx_tso_nfrags;
+};
+
+/* Safety Feature statistics exposed by ethtool */
+struct stmmac_safety_stats {
+	unsigned long mac_errors[32];
+	unsigned long mtl_errors[32];
+	unsigned long dma_errors[32];
+};
+
+/* Number of fields in Safety Stats */
+#define STMMAC_SAFETY_FEAT_SIZE	\
+	(sizeof(struct stmmac_safety_stats) / sizeof(unsigned long))
+
+/* CSR Frequency Access Defines*/
+#define CSR_F_35M	35000000
+#define CSR_F_60M	60000000
+#define CSR_F_100M	100000000
+#define CSR_F_150M	150000000
+#define CSR_F_250M	250000000
+#define CSR_F_300M	300000000
+
+#define	MAC_CSR_H_FRQ_MASK	0x20
+
+#define HASH_TABLE_SIZE 64
+#define PAUSE_TIME 0xffff
+
+/* Flow Control defines */
+#define FLOW_OFF	0
+#define FLOW_RX		1
+#define FLOW_TX		2
+#define FLOW_AUTO	(FLOW_TX | FLOW_RX)
+
+/* PCS defines */
+#define STMMAC_PCS_RGMII	(1 << 0)
+#define STMMAC_PCS_SGMII	(1 << 1)
+#define STMMAC_PCS_TBI		(1 << 2)
+#define STMMAC_PCS_RTBI		(1 << 3)
+
+#define SF_DMA_MODE 1		/* DMA STORE-AND-FORWARD Operation Mode */
+
+/* DAM HW feature register fields */
+#define DMA_HW_FEAT_MIISEL	0x00000001	/* 10/100 Mbps Support */
+#define DMA_HW_FEAT_GMIISEL	0x00000002	/* 1000 Mbps Support */
+#define DMA_HW_FEAT_HDSEL	0x00000004	/* Half-Duplex Support */
+#define DMA_HW_FEAT_EXTHASHEN	0x00000008	/* Expanded DA Hash Filter */
+#define DMA_HW_FEAT_HASHSEL	0x00000010	/* HASH Filter */
+#define DMA_HW_FEAT_ADDMAC	0x00000020	/* Multiple MAC Addr Reg */
+#define DMA_HW_FEAT_PCSSEL	0x00000040	/* PCS registers */
+#define DMA_HW_FEAT_L3L4FLTREN	0x00000080	/* Layer 3 & Layer 4 Feature */
+#define DMA_HW_FEAT_SMASEL	0x00000100	/* SMA(MDIO) Interface */
+#define DMA_HW_FEAT_RWKSEL	0x00000200	/* PMT Remote Wakeup */
+#define DMA_HW_FEAT_MGKSEL	0x00000400	/* PMT Magic Packet */
+#define DMA_HW_FEAT_MMCSEL	0x00000800	/* RMON Module */
+#define DMA_HW_FEAT_TSVER1SEL	0x00001000	/* Only IEEE 1588-2002 */
+#define DMA_HW_FEAT_TSVER2SEL	0x00002000	/* IEEE 1588-2008 PTPv2 */
+#define DMA_HW_FEAT_EEESEL	0x00004000	/* Energy Efficient Ethernet */
+#define DMA_HW_FEAT_AVSEL	0x00008000	/* AV Feature */
+#define DMA_HW_FEAT_TXCOESEL	0x00010000	/* Checksum Offload in Tx */
+#define DMA_HW_FEAT_RXTYP1COE	0x00020000	/* IP COE (Type 1) in Rx */
+#define DMA_HW_FEAT_RXTYP2COE	0x00040000	/* IP COE (Type 2) in Rx */
+#define DMA_HW_FEAT_RXFIFOSIZE	0x00080000	/* Rx FIFO > 2048 Bytes */
+#define DMA_HW_FEAT_RXCHCNT	0x00300000	/* No. additional Rx Channels */
+#define DMA_HW_FEAT_TXCHCNT	0x00c00000	/* No. additional Tx Channels */
+#define DMA_HW_FEAT_ENHDESSEL	0x01000000	/* Alternate Descriptor */
+/* Timestamping with Internal System Time */
+#define DMA_HW_FEAT_INTTSEN	0x02000000
+#define DMA_HW_FEAT_FLEXIPPSEN	0x04000000	/* Flexible PPS Output */
+#define DMA_HW_FEAT_SAVLANINS	0x08000000	/* Source Addr or VLAN */
+#define DMA_HW_FEAT_ACTPHYIF	0x70000000	/* Active/selected PHY iface */
+#define DEFAULT_DMA_PBL		8
+
+/* PCS status and mask defines */
+#define	PCS_ANE_IRQ		BIT(2)	/* PCS Auto-Negotiation */
+#define	PCS_LINK_IRQ		BIT(1)	/* PCS Link */
+#define	PCS_RGSMIIIS_IRQ	BIT(0)	/* RGMII or SMII Interrupt */
+
+/* Max/Min RI Watchdog Timer count value */
+#define MAX_DMA_RIWT		0xff
+#define MIN_DMA_RIWT		0x10
+#define DEF_DMA_RIWT		0xa0
+/* Tx coalesce parameters */
+#define STMMAC_COAL_TX_TIMER	1000
+#define STMMAC_MAX_COAL_TX_TICK	100000
+#define STMMAC_TX_MAX_FRAMES	256
+#define STMMAC_TX_FRAMES	25
+#define STMMAC_RX_FRAMES	0
+
+/* Packets types */
+enum packets_types {
+	PACKET_AVCPQ = 0x1, /* AV Untagged Control packets */
+	PACKET_PTPQ = 0x2, /* PTP Packets */
+	PACKET_DCBCPQ = 0x3, /* DCB Control Packets */
+	PACKET_UPQ = 0x4, /* Untagged Packets */
+	PACKET_MCBCQ = 0x5, /* Multicast & Broadcast Packets */
+};
+
+/* Rx IPC status */
+enum rx_frame_status {
+	good_frame = 0x0,
+	discard_frame = 0x1,
+	csum_none = 0x2,
+	llc_snap = 0x4,
+	dma_own = 0x8,
+	rx_not_ls = 0x10,
+};
+
+/* Tx status */
+enum tx_frame_status {
+	tx_done = 0x0,
+	tx_not_ls = 0x1,
+	tx_err = 0x2,
+	tx_dma_own = 0x4,
+};
+
+enum dma_irq_status {
+	tx_hard_error = 0x1,
+	tx_hard_error_bump_tc = 0x2,
+	handle_rx = 0x4,
+	handle_tx = 0x8,
+};
+
+/* EEE and LPI defines */
+#define	CORE_IRQ_TX_PATH_IN_LPI_MODE	(1 << 0)
+#define	CORE_IRQ_TX_PATH_EXIT_LPI_MODE	(1 << 1)
+#define	CORE_IRQ_RX_PATH_IN_LPI_MODE	(1 << 2)
+#define	CORE_IRQ_RX_PATH_EXIT_LPI_MODE	(1 << 3)
+
+#define CORE_IRQ_MTL_RX_OVERFLOW	BIT(8)
+
+/* Physical Coding Sublayer */
+struct rgmii_adv {
+	unsigned int pause;
+	unsigned int duplex;
+	unsigned int lp_pause;
+	unsigned int lp_duplex;
+};
+
+#define STMMAC_PCS_PAUSE	1
+#define STMMAC_PCS_ASYM_PAUSE	2
+
+/* DMA HW capabilities */
+struct dma_features {
+	unsigned int mbps_10_100;
+	unsigned int mbps_1000;
+	unsigned int half_duplex;
+	unsigned int hash_filter;
+	unsigned int multi_addr;
+	unsigned int pcs;
+	unsigned int sma_mdio;
+	unsigned int pmt_remote_wake_up;
+	unsigned int pmt_magic_frame;
+	unsigned int rmon;
+	/* IEEE 1588-2002 */
+	unsigned int time_stamp;
+	/* IEEE 1588-2008 */
+	unsigned int atime_stamp;
+	/* 802.3az - Energy-Efficient Ethernet (EEE) */
+	unsigned int eee;
+	unsigned int av;
+	unsigned int hash_tb_sz;
+	unsigned int tsoen;
+	/* TX and RX csum */
+	unsigned int tx_coe;
+	unsigned int rx_coe;
+	unsigned int rx_coe_type1;
+	unsigned int rx_coe_type2;
+	unsigned int rxfifo_over_2048;
+	/* TX and RX number of channels */
+	unsigned int number_rx_channel;
+	unsigned int number_tx_channel;
+	/* TX and RX number of queues */
+	unsigned int number_rx_queues;
+	unsigned int number_tx_queues;
+	/* PPS output */
+	unsigned int pps_out_num;
+	/* Alternate (enhanced) DESC mode */
+	unsigned int enh_desc;
+	/* TX and RX FIFO sizes */
+	unsigned int tx_fifo_size;
+	unsigned int rx_fifo_size;
+	/* Automotive Safety Package */
+	unsigned int asp;
+	/* RX Parser */
+	unsigned int frpsel;
+	unsigned int frpbs;
+	unsigned int frpes;
+	unsigned int addr64;
+	unsigned int rssen;
+	unsigned int vlhash;
+	unsigned int sphen;
+	unsigned int vlins;
+	unsigned int dvlan;
+	unsigned int l3l4fnum;
+	unsigned int arpoffsel;
+	/* TSN Features */
+	unsigned int estwid;
+	unsigned int estdep;
+	unsigned int estsel;
+	unsigned int fpesel;
+	unsigned int tbssel;
+};
+
+/* RX Buffer size must be multiple of 4/8/16 bytes */
+#define BUF_SIZE_16KiB 16368
+#define BUF_SIZE_8KiB 8188
+#define BUF_SIZE_4KiB 4096
+#define BUF_SIZE_2KiB 2048
+
+/* Power Down and WOL */
+#define PMT_NOT_SUPPORTED 0
+#define PMT_SUPPORTED 1
+
+/* Common MAC defines */
+#define MAC_CTRL_REG		0x00000000	/* MAC Control */
+#define MAC_ENABLE_TX		0x00000008	/* Transmitter Enable */
+#define MAC_ENABLE_RX		0x00000004	/* Receiver Enable */
+
+/* Default LPI timers */
+#define STMMAC_DEFAULT_LIT_LS	0x3E8
+#define STMMAC_DEFAULT_TWT_LS	0x1E
+
+#define STMMAC_CHAIN_MODE	0x1
+#define STMMAC_RING_MODE	0x2
+
+#define STMMAC_BUFFER_ALIGN	64
+#define STMMAC_ALIGN_LENGTH	1536
+#define JUMBO_LEN		9000
+
+/* Receive Side Scaling */
+#define STMMAC_RSS_HASH_KEY_SIZE	40
+#define STMMAC_RSS_MAX_TABLE_SIZE	256
+
+/* VLAN */
+#define STMMAC_VLAN_NONE	0x0
+#define STMMAC_VLAN_REMOVE	0x1
+#define STMMAC_VLAN_INSERT	0x2
+#define STMMAC_VLAN_REPLACE	0x3
+
+#define STMMAC_HW_VLAN_CTAG_FILTER 1
+
+extern const struct stmmac_desc_ops enh_desc_ops;
+extern const struct stmmac_desc_ops ndesc_ops;
+
+struct mac_device_info;
+
+extern const struct stmmac_hwtimestamp stmmac_ptp;
+extern const struct stmmac_mode_ops dwmac4_ring_mode_ops;
+
+struct mac_link {
+	uint32_t speed_mask;
+	uint32_t speed10;
+	uint32_t speed100;
+	uint32_t speed1000;
+	uint32_t speed2500;
+	uint32_t duplex;
+	struct {
+		uint32_t speed2500;
+		uint32_t speed5000;
+		uint32_t speed10000;
+	} xgmii;
+	struct {
+		uint32_t speed25000;
+		uint32_t speed40000;
+		uint32_t speed50000;
+		uint32_t speed100000;
+	} xlgmii;
+};
+
+struct mii_regs {
+	unsigned int addr;	/* MII Address */
+	unsigned int data;	/* MII Data */
+	unsigned int addr_shift;	/* MII address shift */
+	unsigned int reg_shift;		/* MII reg shift */
+	unsigned int addr_mask;		/* MII address mask */
+	unsigned int reg_mask;		/* MII reg mask */
+	unsigned int clk_csr_shift;
+	unsigned int clk_csr_mask;
+};
+
+struct mac_device_info {
+	const struct stmmac_ops *mac;
+	const struct stmmac_desc_ops *desc;
+	const struct stmmac_dma_ops *dma;
+	const struct stmmac_mode_ops *mode;
+	const struct stmmac_hwtimestamp *ptp;
+	const struct stmmac_tc_ops *tc;
+	const struct stmmac_mmc_ops *mmc;
+	struct mac_link link;
+	void *pcsr;     /* vpointer to device CSRs */
+	unsigned int multicast_filter_bins;
+	unsigned int unicast_filter_entries;
+	unsigned int mcast_bits_log2;
+	unsigned int rx_csum;
+	unsigned int pcs;
+	unsigned int pmt;
+	unsigned int ps;
+	unsigned int xlgmac;
+	unsigned int num_vlan;
+	uint32_t vlan_filter[32];
+	unsigned int promisc;
+	bool vlan_fail_q_en;
+	uint8_t vlan_fail_q;
+};
+
+struct stmmac_rx_routing {
+	uint32_t reg_mask;
+	uint32_t reg_shift;
+};
+
+/*
+ * STMMAC can support 1 rx and tx queue..
+ */
+
+#define STMMAC_MAX_Q		1
+
+#define writel(v, p) ({*(volatile unsigned int *)(p) = (v); })
+#define readl(p) rte_read32(p)
+
+struct stmmac_tx_info {
+	dma_addr_t buf;
+	bool map_as_page;
+	unsigned len;
+	bool last_segment;
+	bool is_jumbo;
+};
+
+#define STMMAC_TBS_AVAIL	BIT(0)
+#define STMMAC_TBS_EN		BIT(1)
+
+struct stmmac_rx_buffer {
+	struct page *page;
+	struct page *sec_page;
+	dma_addr_t addr;
+	dma_addr_t sec_addr;
+};
+
+struct bufdesc_prop {
+	int			queue_id;
+	/* Addresses of Tx and Rx buffers */
+	struct bufdesc		*base;
+	struct bufdesc		*last;
+	struct bufdesc		*cur;
+	void 		*active_reg_desc;
+	uint64_t			descr_baseaddr_p;
+	unsigned short		ring_size;
+	unsigned char		d_size;
+	unsigned char		d_size_log2;
+};
+
+/* Frequently used values are kept adjacent for cache effect */
+struct stmmac_tx_queue {
+	uint32_t tx_count_frames;
+	int tbs;
+	uint32_t queue_index;
+	struct dma_desc *dma_tx;
+	struct dma_extended_desc *dma_etx;
+	struct dma_edesc *dma_entx;
+	struct rte_mbuf *tx_mbuf[DMA_MAX_TX_SIZE];
+	struct stmmac_tx_info *tx_mbuf_dma;
+	unsigned int cur_tx;
+	unsigned int dirty_tx;
+	unsigned short	 dma_tx_size;
+	dma_addr_t dma_tx_phy;
+	uint32_t tx_tail_addr;
+	uint32_t mss;
+	struct rte_mempool	*pool;
+	struct stmmac_private *private;
+};
+
+struct stmmac_rx_queue {
+	uint32_t rx_count_frames;
+	uint32_t queue_index;
+	struct dma_desc *dma_rx;
+	struct dma_extended_desc *dma_erx;
+	unsigned int cur_rx;
+	unsigned int dirty_rx;
+	uint32_t rx_zeroc_thresh;
+	dma_addr_t dma_rx_phy;
+	uint32_t rx_tail_addr;
+	unsigned int state_saved;
+	unsigned short	 dma_rx_size;
+	struct {
+		struct sk_buff *skb;
+		unsigned int len;
+		unsigned int error;
+	} state;
+	struct rte_mbuf		*rx_mbuf[DMA_MAX_RX_SIZE];
+	struct rte_mempool		*pool;
+	struct stmmac_private	*private;
+};
+
+struct stmmac_private {
+	struct rte_eth_dev	*dev;
+	struct rte_eth_stats stats;
+	struct mac_device_info *hw;
+	struct plat_stmmacenet_data *plat;
+	struct uio_job stmmac_uio_job;
+	unsigned int mode;
+	unsigned int chain_mode;
+	int extend_desc;
+	void  *mmcaddr;
+	void  *ptpaddr;
+	unsigned int dma_buf_sz;
+	int use_riwt;
+	uint32_t rx_riwt;
+	int hwts_rx_en;
+	unsigned int synopsys_id;
+	int			full_duplex;
+	int			flag_pause;
+	int			flag_csum;
+	uint32_t		quirks;
+	uint16_t		rx_queues_to_use;
+	uint16_t		tx_queues_to_use;
+	unsigned int		total_tx_ring_size;
+	unsigned int		total_rx_ring_size;
+	unsigned int		reg_size;
+	unsigned int		dma_rx_size;
+	unsigned int		dma_tx_size;
+	unsigned int		bd_r_size[STMMAC_MAX_Q];
+	unsigned int		bd_t_size[STMMAC_MAX_Q];
+	bool			bufdesc_ex;
+	bool			rgmii_txc_delay;
+	bool			rgmii_rxc_delay;
+	void			*ioaddr_v;
+	uint32_t		ioaddr_p;
+	void			*bd_addr_r_v;
+	uint32_t		bd_addr_r_p;
+	void			*bd_addr_t_v;
+	uint32_t		bd_addr_t_p;
+	dma_addr_t		desc_addr_p_r[STMMAC_MAX_Q];
+	dma_addr_t		desc_addr_p_t[STMMAC_MAX_Q];
+	void			*dma_baseaddr_v_r[STMMAC_MAX_Q];
+	void			*dma_baseaddr_v_t[STMMAC_MAX_Q];
+	struct stmmac_rx_queue *rx_queues[STMMAC_MAX_Q];
+	struct stmmac_tx_queue *tx_queues[STMMAC_MAX_Q];
+	unsigned long		flags;
+	unsigned long		features;
+	unsigned long		uc_count;
+};
+
+
+int dwmac100_setup(struct stmmac_private *priv);
+int dwmac1000_setup(struct stmmac_private *priv);
+extern int dwmac4_setup(struct stmmac_private *priv);
+int dwxgmac2_setup(struct stmmac_private *priv);
+int dwxlgmac2_setup(struct stmmac_private *priv);
+
+void stmmac_set_mac_addr(void *ioaddr, uint8_t addr[6],
+			 unsigned int high, unsigned int low);
+void stmmac_get_mac_addr(void *ioaddr, unsigned char *addr,
+			 unsigned int high, unsigned int low);
+void stmmac_set_mac(void *ioaddr, bool enable);
+
+void stmmac_dwmac4_set_mac_addr(void *ioaddr, uint8_t addr[6],
+				unsigned int high, unsigned int low);
+void stmmac_dwmac4_get_mac_addr(void *ioaddr, unsigned char *addr,
+				unsigned int high, unsigned int low);
+void stmmac_dwmac4_set_mac(void *ioaddr, bool enable);
+
+void dwmac_dma_flush_tx_fifo(void *ioaddr);
+
+extern const struct stmmac_mode_ops ring_mode_ops;
+extern const struct stmmac_mode_ops chain_mode_ops;
+extern const struct stmmac_desc_ops dwmac4_desc_ops;
+
+#endif /* __COMMON_H__ */
diff --git a/drivers/net/stmmac/descs.h b/drivers/net/stmmac/descs.h
new file mode 100644
index 0000000..7d6d842
--- /dev/null
+++ b/drivers/net/stmmac/descs.h
@@ -0,0 +1,183 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __DESCS_H__
+#define __DESCS_H__
+
+#define BIT(nr)			(1UL << (nr))
+#define BITS_PER_LONG	(__SIZEOF_LONG__ * 8)
+#define GENMASK(h, l)	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+
+/* Normal receive descriptor defines */
+
+/* RDES0 */
+#define	RDES0_PAYLOAD_CSUM_ERR	BIT(0)
+#define	RDES0_CRC_ERROR		BIT(1)
+#define	RDES0_DRIBBLING		BIT(2)
+#define	RDES0_MII_ERROR		BIT(3)
+#define	RDES0_RECEIVE_WATCHDOG	BIT(4)
+#define	RDES0_FRAME_TYPE	BIT(5)
+#define	RDES0_COLLISION		BIT(6)
+#define	RDES0_IPC_CSUM_ERROR	BIT(7)
+#define	RDES0_LAST_DESCRIPTOR	BIT(8)
+#define	RDES0_FIRST_DESCRIPTOR	BIT(9)
+#define	RDES0_VLAN_TAG		BIT(10)
+#define	RDES0_OVERFLOW_ERROR	BIT(11)
+#define	RDES0_LENGTH_ERROR	BIT(12)
+#define	RDES0_SA_FILTER_FAIL	BIT(13)
+#define	RDES0_DESCRIPTOR_ERROR	BIT(14)
+#define	RDES0_ERROR_SUMMARY	BIT(15)
+#define	RDES0_FRAME_LEN_MASK	GENMASK(29, 16)
+#define RDES0_FRAME_LEN_SHIFT	16
+#define	RDES0_DA_FILTER_FAIL	BIT(30)
+#define	RDES0_OWN		BIT(31)
+			/* RDES1 */
+#define	RDES1_BUFFER1_SIZE_MASK		GENMASK(10, 0)
+#define	RDES1_BUFFER2_SIZE_MASK		GENMASK(21, 11)
+#define	RDES1_BUFFER2_SIZE_SHIFT	11
+#define	RDES1_SECOND_ADDRESS_CHAINED	BIT(24)
+#define	RDES1_END_RING			BIT(25)
+#define	RDES1_DISABLE_IC		BIT(31)
+
+/* Enhanced receive descriptor defines */
+
+/* RDES0 (similar to normal RDES) */
+#define	 ERDES0_RX_MAC_ADDR	BIT(0)
+
+/* RDES1: completely differ from normal desc definitions */
+#define	ERDES1_BUFFER1_SIZE_MASK	GENMASK(12, 0)
+#define	ERDES1_SECOND_ADDRESS_CHAINED	BIT(14)
+#define	ERDES1_END_RING			BIT(15)
+#define	ERDES1_BUFFER2_SIZE_MASK	GENMASK(28, 16)
+#define ERDES1_BUFFER2_SIZE_SHIFT	16
+#define	ERDES1_DISABLE_IC		BIT(31)
+
+/* Normal transmit descriptor defines */
+/* TDES0 */
+#define	TDES0_DEFERRED			BIT(0)
+#define	TDES0_UNDERFLOW_ERROR		BIT(1)
+#define	TDES0_EXCESSIVE_DEFERRAL	BIT(2)
+#define	TDES0_COLLISION_COUNT_MASK	GENMASK(6, 3)
+#define	TDES0_VLAN_FRAME		BIT(7)
+#define	TDES0_EXCESSIVE_COLLISIONS	BIT(8)
+#define	TDES0_LATE_COLLISION		BIT(9)
+#define	TDES0_NO_CARRIER		BIT(10)
+#define	TDES0_LOSS_CARRIER		BIT(11)
+#define	TDES0_PAYLOAD_ERROR		BIT(12)
+#define	TDES0_FRAME_FLUSHED		BIT(13)
+#define	TDES0_JABBER_TIMEOUT		BIT(14)
+#define	TDES0_ERROR_SUMMARY		BIT(15)
+#define	TDES0_IP_HEADER_ERROR		BIT(16)
+#define	TDES0_TIME_STAMP_STATUS		BIT(17)
+#define	TDES0_OWN			((u32)BIT(31))	/* silence sparse */
+/* TDES1 */
+#define	TDES1_BUFFER1_SIZE_MASK		GENMASK(10, 0)
+#define	TDES1_BUFFER2_SIZE_MASK		GENMASK(21, 11)
+#define	TDES1_BUFFER2_SIZE_SHIFT	11
+#define	TDES1_TIME_STAMP_ENABLE		BIT(22)
+#define	TDES1_DISABLE_PADDING		BIT(23)
+#define	TDES1_SECOND_ADDRESS_CHAINED	BIT(24)
+#define	TDES1_END_RING			BIT(25)
+#define	TDES1_CRC_DISABLE		BIT(26)
+#define	TDES1_CHECKSUM_INSERTION_MASK	GENMASK(28, 27)
+#define	TDES1_CHECKSUM_INSERTION_SHIFT	27
+#define	TDES1_FIRST_SEGMENT		BIT(29)
+#define	TDES1_LAST_SEGMENT		BIT(30)
+#define	TDES1_INTERRUPT			BIT(31)
+
+/* Enhanced transmit descriptor defines */
+/* TDES0 */
+#define	ETDES0_DEFERRED			BIT(0)
+#define	ETDES0_UNDERFLOW_ERROR		BIT(1)
+#define	ETDES0_EXCESSIVE_DEFERRAL	BIT(2)
+#define	ETDES0_COLLISION_COUNT_MASK	GENMASK(6, 3)
+#define	ETDES0_VLAN_FRAME		BIT(7)
+#define	ETDES0_EXCESSIVE_COLLISIONS	BIT(8)
+#define	ETDES0_LATE_COLLISION		BIT(9)
+#define	ETDES0_NO_CARRIER		BIT(10)
+#define	ETDES0_LOSS_CARRIER		BIT(11)
+#define	ETDES0_PAYLOAD_ERROR		BIT(12)
+#define	ETDES0_FRAME_FLUSHED		BIT(13)
+#define	ETDES0_JABBER_TIMEOUT		BIT(14)
+#define	ETDES0_ERROR_SUMMARY		BIT(15)
+#define	ETDES0_IP_HEADER_ERROR		BIT(16)
+#define	ETDES0_TIME_STAMP_STATUS	BIT(17)
+#define	ETDES0_SECOND_ADDRESS_CHAINED	BIT(20)
+#define	ETDES0_END_RING			BIT(21)
+#define	ETDES0_CHECKSUM_INSERTION_MASK	GENMASK(23, 22)
+#define	ETDES0_CHECKSUM_INSERTION_SHIFT	22
+#define	ETDES0_TIME_STAMP_ENABLE	BIT(25)
+#define	ETDES0_DISABLE_PADDING		BIT(26)
+#define	ETDES0_CRC_DISABLE		BIT(27)
+#define	ETDES0_FIRST_SEGMENT		BIT(28)
+#define	ETDES0_LAST_SEGMENT		BIT(29)
+#define	ETDES0_INTERRUPT		BIT(30)
+#define	ETDES0_OWN			((u32)BIT(31))	/* silence sparse */
+/* TDES1 */
+#define	ETDES1_BUFFER1_SIZE_MASK	GENMASK(12, 0)
+#define	ETDES1_BUFFER2_SIZE_MASK	GENMASK(28, 16)
+#define	ETDES1_BUFFER2_SIZE_SHIFT	16
+
+/* Extended Receive descriptor definitions */
+#define	ERDES4_IP_PAYLOAD_TYPE_MASK	GENMASK(6, 2)
+#define	ERDES4_IP_HDR_ERR		BIT(3)
+#define	ERDES4_IP_PAYLOAD_ERR		BIT(4)
+#define	ERDES4_IP_CSUM_BYPASSED		BIT(5)
+#define	ERDES4_IPV4_PKT_RCVD		BIT(6)
+#define	ERDES4_IPV6_PKT_RCVD		BIT(7)
+#define	ERDES4_MSG_TYPE_MASK		GENMASK(11, 8)
+#define	ERDES4_PTP_FRAME_TYPE		BIT(12)
+#define	ERDES4_PTP_VER			BIT(13)
+#define	ERDES4_TIMESTAMP_DROPPED	BIT(14)
+#define	ERDES4_AV_PKT_RCVD		BIT(16)
+#define	ERDES4_AV_TAGGED_PKT_RCVD	BIT(17)
+#define	ERDES4_VLAN_TAG_PRI_VAL_MASK	GENMASK(20, 18)
+#define	ERDES4_L3_FILTER_MATCH		BIT(24)
+#define	ERDES4_L4_FILTER_MATCH		BIT(25)
+#define	ERDES4_L3_L4_FILT_NO_MATCH_MASK	GENMASK(27, 26)
+
+/* Extended RDES4 message type definitions */
+#define RDES_EXT_NO_PTP			0x0
+#define RDES_EXT_SYNC			0x1
+#define RDES_EXT_FOLLOW_UP		0x2
+#define RDES_EXT_DELAY_REQ		0x3
+#define RDES_EXT_DELAY_RESP		0x4
+#define RDES_EXT_PDELAY_REQ		0x5
+#define RDES_EXT_PDELAY_RESP		0x6
+#define RDES_EXT_PDELAY_FOLLOW_UP	0x7
+#define RDES_PTP_ANNOUNCE		0x8
+#define RDES_PTP_MANAGEMENT		0x9
+#define RDES_PTP_SIGNALING		0xa
+#define RDES_PTP_PKT_RESERVED_TYPE	0xf
+
+/* Basic descriptor structure for normal and alternate descriptors */
+struct dma_desc {
+	uint32_t des0;
+	uint32_t des1;
+	uint32_t des2;
+	uint32_t des3;
+};
+
+/* Extended descriptor structure (e.g. >= databook 3.50a) */
+struct dma_extended_desc {
+	struct dma_desc basic;	/* Basic descriptors */
+	uint32_t des4;	/* Extended Status */
+	uint32_t des5;	/* Reserved */
+	uint32_t des6;	/* Tx/Rx Timestamp Low */
+	uint32_t des7;	/* Tx/Rx Timestamp High */
+};
+
+/* Enhanced descriptor for TBS */
+struct dma_edesc {
+	uint32_t des4;
+	uint32_t des5;
+	uint32_t des6;
+	uint32_t des7;
+	struct dma_desc basic;
+};
+
+/* Transmit checksum insertion control */
+#define	TX_CIC_FULL	3	/* Include IP header and pseudoheader */
+
+#endif /* __DESCS_H__ */
diff --git a/drivers/net/stmmac/dwmac4.h b/drivers/net/stmmac/dwmac4.h
new file mode 100644
index 0000000..592b043
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4.h
@@ -0,0 +1,501 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * DWMAC4 Header file.
+ *
+ * Copyright (C) 2015  STMicroelectronics Ltd
+ *
+ * Author: Alexandre Torgue <alexandre.torgue@st.com>
+ */
+
+#ifndef __DWMAC4_H__
+#define __DWMAC4_H__
+
+#include "common.h"
+
+/*  MAC registers */
+#define GMAC_CONFIG			0x00000000
+#define GMAC_EXT_CONFIG			0x00000004
+#define GMAC_PACKET_FILTER		0x00000008
+#define GMAC_HASH_TAB(x)		(0x10 + (x) * 4)
+#define GMAC_VLAN_TAG			0x00000050
+#define GMAC_VLAN_TAG_DATA		0x00000054
+#define GMAC_VLAN_HASH_TABLE		0x00000058
+#define GMAC_RX_FLOW_CTRL		0x00000090
+#define GMAC_VLAN_INCL			0x00000060
+#define GMAC_QX_TX_FLOW_CTRL(x)		(0x70 + x * 4)
+#define GMAC_TXQ_PRTY_MAP0		0x98
+#define GMAC_TXQ_PRTY_MAP1		0x9C
+#define GMAC_RXQ_CTRL0			0x000000a0
+#define GMAC_RXQ_CTRL1			0x000000a4
+#define GMAC_RXQ_CTRL2			0x000000a8
+#define GMAC_RXQ_CTRL3			0x000000ac
+#define GMAC_INT_STATUS			0x000000b0
+#define GMAC_INT_EN			0x000000b4
+#define GMAC_1US_TIC_COUNTER		0x000000dc
+#define GMAC_PCS_BASE			0x000000e0
+#define GMAC_PHYIF_CONTROL_STATUS	0x000000f8
+#define GMAC_PMT			0x000000c0
+#define GMAC_DEBUG			0x00000114
+#define GMAC_HW_FEATURE0		0x0000011c
+#define GMAC_HW_FEATURE1		0x00000120
+#define GMAC_HW_FEATURE2		0x00000124
+#define GMAC_HW_FEATURE3		0x00000128
+#define GMAC_MDIO_ADDR			0x00000200
+#define GMAC_MDIO_DATA			0x00000204
+#define GMAC_ARP_ADDR			0x00000210
+#define GMAC_ADDR_HIGH(reg)		(0x300 + reg * 8)
+#define GMAC_ADDR_LOW(reg)		(0x304 + reg * 8)
+#define GMAC_L3L4_CTRL(reg)		(0x900 + (reg) * 0x30)
+#define GMAC_L4_ADDR(reg)		(0x904 + (reg) * 0x30)
+#define GMAC_L3_ADDR0(reg)		(0x910 + (reg) * 0x30)
+#define GMAC_L3_ADDR1(reg)		(0x914 + (reg) * 0x30)
+
+/* RX Queues Routing */
+#define GMAC_RXQCTRL_AVCPQ_MASK		GENMASK(2, 0)
+#define GMAC_RXQCTRL_AVCPQ_SHIFT	0
+#define GMAC_RXQCTRL_PTPQ_MASK		GENMASK(6, 4)
+#define GMAC_RXQCTRL_PTPQ_SHIFT		4
+#define GMAC_RXQCTRL_DCBCPQ_MASK	GENMASK(10, 8)
+#define GMAC_RXQCTRL_DCBCPQ_SHIFT	8
+#define GMAC_RXQCTRL_UPQ_MASK		GENMASK(14, 12)
+#define GMAC_RXQCTRL_UPQ_SHIFT		12
+#define GMAC_RXQCTRL_MCBCQ_MASK		GENMASK(18, 16)
+#define GMAC_RXQCTRL_MCBCQ_SHIFT	16
+#define GMAC_RXQCTRL_MCBCQEN		BIT(20)
+#define GMAC_RXQCTRL_MCBCQEN_SHIFT	20
+#define GMAC_RXQCTRL_TACPQE		BIT(21)
+#define GMAC_RXQCTRL_TACPQE_SHIFT	21
+#define GMAC_RXQCTRL_FPRQ		GENMASK(26, 24)
+#define GMAC_RXQCTRL_FPRQ_SHIFT		24
+
+/* MAC Packet Filtering */
+#define GMAC_PACKET_FILTER_PR		BIT(0)
+#define GMAC_PACKET_FILTER_HMC		BIT(2)
+#define GMAC_PACKET_FILTER_PM		BIT(4)
+#define GMAC_PACKET_FILTER_PCF		BIT(7)
+#define GMAC_PACKET_FILTER_HPF		BIT(10)
+#define GMAC_PACKET_FILTER_VTFE		BIT(16)
+#define GMAC_PACKET_FILTER_IPFE		BIT(20)
+#define GMAC_PACKET_FILTER_RA		BIT(31)
+
+#define GMAC_MAX_PERFECT_ADDRESSES	128
+
+/* MAC VLAN */
+#define GMAC_VLAN_EDVLP			BIT(26)
+#define GMAC_VLAN_VTHM			BIT(25)
+#define GMAC_VLAN_DOVLTC		BIT(20)
+#define GMAC_VLAN_ESVL			BIT(18)
+#define GMAC_VLAN_ETV			BIT(16)
+#define GMAC_VLAN_VID			GENMASK(15, 0)
+#define GMAC_VLAN_VLTI			BIT(20)
+#define GMAC_VLAN_CSVL			BIT(19)
+#define GMAC_VLAN_VLC			GENMASK(17, 16)
+#define GMAC_VLAN_VLC_SHIFT		16
+#define GMAC_VLAN_VLHT			GENMASK(15, 0)
+
+/* MAC VLAN Tag */
+#define GMAC_VLAN_TAG_VID		GENMASK(15, 0)
+#define GMAC_VLAN_TAG_ETV		BIT(16)
+
+/* MAC VLAN Tag Control */
+#define GMAC_VLAN_TAG_CTRL_OB		BIT(0)
+#define GMAC_VLAN_TAG_CTRL_CT		BIT(1)
+#define GMAC_VLAN_TAG_CTRL_OFS_MASK	GENMASK(6, 2)
+#define GMAC_VLAN_TAG_CTRL_OFS_SHIFT	2
+#define GMAC_VLAN_TAG_CTRL_EVLS_MASK	GENMASK(22, 21)
+#define GMAC_VLAN_TAG_CTRL_EVLS_SHIFT	21
+#define GMAC_VLAN_TAG_CTRL_EVLRXS	BIT(24)
+
+#define GMAC_VLAN_TAG_STRIP_NONE	(0x0 << GMAC_VLAN_TAG_CTRL_EVLS_SHIFT)
+#define GMAC_VLAN_TAG_STRIP_PASS	(0x1 << GMAC_VLAN_TAG_CTRL_EVLS_SHIFT)
+#define GMAC_VLAN_TAG_STRIP_FAIL	(0x2 << GMAC_VLAN_TAG_CTRL_EVLS_SHIFT)
+#define GMAC_VLAN_TAG_STRIP_ALL		(0x3 << GMAC_VLAN_TAG_CTRL_EVLS_SHIFT)
+
+/* MAC VLAN Tag Data/Filter */
+#define GMAC_VLAN_TAG_DATA_VID		GENMASK(15, 0)
+#define GMAC_VLAN_TAG_DATA_VEN		BIT(16)
+#define GMAC_VLAN_TAG_DATA_ETV		BIT(17)
+
+/* MAC RX Queue Enable */
+#define GMAC_RX_QUEUE_CLEAR(queue)	~(GENMASK(1, 0) << ((queue) * 2))
+#define GMAC_RX_AV_QUEUE_ENABLE(queue)	BIT((queue) * 2)
+#define GMAC_RX_DCB_QUEUE_ENABLE(queue)	BIT(((queue) * 2) + 1)
+
+/* MAC Flow Control RX */
+#define GMAC_RX_FLOW_CTRL_RFE		BIT(0)
+
+/* RX Queues Priorities */
+#define GMAC_RXQCTRL_PSRQX_MASK(x)	GENMASK(7 + ((x) * 8), 0 + ((x) * 8))
+#define GMAC_RXQCTRL_PSRQX_SHIFT(x)	((x) * 8)
+
+/* TX Queues Priorities */
+#define GMAC_TXQCTRL_PSTQX_MASK(x)	GENMASK(7 + ((x) * 8), 0 + ((x) * 8))
+#define GMAC_TXQCTRL_PSTQX_SHIFT(x)	((x) * 8)
+
+/* MAC Flow Control TX */
+#define GMAC_TX_FLOW_CTRL_TFE		BIT(1)
+#define GMAC_TX_FLOW_CTRL_PT_SHIFT	16
+
+/*  MAC Interrupt bitmap*/
+#define GMAC_INT_RGSMIIS		BIT(0)
+#define GMAC_INT_PCS_LINK		BIT(1)
+#define GMAC_INT_PCS_ANE		BIT(2)
+#define GMAC_INT_PCS_PHYIS		BIT(3)
+#define GMAC_INT_PMT_EN			BIT(4)
+#define GMAC_INT_LPI_EN			BIT(5)
+
+#define	GMAC_PCS_IRQ_DEFAULT	(GMAC_INT_RGSMIIS | GMAC_INT_PCS_LINK |	\
+				 GMAC_INT_PCS_ANE)
+
+#define	GMAC_INT_DEFAULT_ENABLE	(GMAC_INT_PMT_EN | GMAC_INT_LPI_EN)
+
+enum dwmac4_irq_status {
+	time_stamp_irq = 0x00001000,
+	mmc_rx_csum_offload_irq = 0x00000800,
+	mmc_tx_irq = 0x00000400,
+	mmc_rx_irq = 0x00000200,
+	mmc_irq = 0x00000100,
+	lpi_irq = 0x00000020,
+	pmt_irq = 0x00000010,
+};
+
+/* MAC PMT bitmap */
+enum power_event {
+	pointer_reset =	0x80000000,
+	global_unicast = 0x00000200,
+	wake_up_rx_frame = 0x00000040,
+	magic_frame = 0x00000020,
+	wake_up_frame_en = 0x00000004,
+	magic_pkt_en = 0x00000002,
+	power_down = 0x00000001,
+};
+
+/* Energy Efficient Ethernet (EEE) for GMAC4
+ *
+ * LPI status, timer and control register offset
+ */
+#define GMAC4_LPI_CTRL_STATUS	0xd0
+#define GMAC4_LPI_TIMER_CTRL	0xd4
+
+/* LPI control and status defines */
+#define GMAC4_LPI_CTRL_STATUS_LPITCSE	BIT(21)	/* LPI Tx Clock Stop Enable */
+#define GMAC4_LPI_CTRL_STATUS_LPITXA	BIT(19)	/* Enable LPI TX Automate */
+#define GMAC4_LPI_CTRL_STATUS_PLS	BIT(17) /* PHY Link Status */
+#define GMAC4_LPI_CTRL_STATUS_LPIEN	BIT(16)	/* LPI Enable */
+#define GMAC4_LPI_CTRL_STATUS_RLPIEX	BIT(3) /* Receive LPI Exit */
+#define GMAC4_LPI_CTRL_STATUS_RLPIEN	BIT(2) /* Receive LPI Entry */
+#define GMAC4_LPI_CTRL_STATUS_TLPIEX	BIT(1) /* Transmit LPI Exit */
+#define GMAC4_LPI_CTRL_STATUS_TLPIEN	BIT(0) /* Transmit LPI Entry */
+
+/* MAC Debug bitmap */
+#define GMAC_DEBUG_TFCSTS_MASK		GENMASK(18, 17)
+#define GMAC_DEBUG_TFCSTS_SHIFT		17
+#define GMAC_DEBUG_TFCSTS_IDLE		0
+#define GMAC_DEBUG_TFCSTS_WAIT		1
+#define GMAC_DEBUG_TFCSTS_GEN_PAUSE	2
+#define GMAC_DEBUG_TFCSTS_XFER		3
+#define GMAC_DEBUG_TPESTS		BIT(16)
+#define GMAC_DEBUG_RFCFCSTS_MASK	GENMASK(2, 1)
+#define GMAC_DEBUG_RFCFCSTS_SHIFT	1
+#define GMAC_DEBUG_RPESTS		BIT(0)
+
+/* MAC config */
+#define GMAC_CONFIG_ARPEN		BIT(31)
+#define GMAC_CONFIG_SARC		GENMASK(30, 28)
+#define GMAC_CONFIG_SARC_SHIFT		28
+#define GMAC_CONFIG_IPC			BIT(27)
+#define GMAC_CONFIG_IPG			GENMASK(26, 24)
+#define GMAC_CONFIG_IPG_SHIFT		24
+#define GMAC_CONFIG_2K			BIT(22)
+#define GMAC_CONFIG_ACS			BIT(20)
+#define GMAC_CONFIG_BE			BIT(18)
+#define GMAC_CONFIG_JD			BIT(17)
+#define GMAC_CONFIG_JE			BIT(16)
+#define GMAC_CONFIG_PS			BIT(15)
+#define GMAC_CONFIG_FES			BIT(14)
+#define GMAC_CONFIG_FES_SHIFT		14
+#define GMAC_CONFIG_DM			BIT(13)
+#define GMAC_CONFIG_LM			BIT(12)
+#define GMAC_CONFIG_DCRS		BIT(9)
+#define GMAC_CONFIG_TE			BIT(1)
+#define GMAC_CONFIG_RE			BIT(0)
+
+/* MAC extended config */
+#define GMAC_CONFIG_EIPG		GENMASK(29, 25)
+#define GMAC_CONFIG_EIPG_SHIFT		25
+#define GMAC_CONFIG_EIPG_EN		BIT(24)
+#define GMAC_CONFIG_HDSMS		GENMASK(22, 20)
+#define GMAC_CONFIG_HDSMS_SHIFT		20
+#define GMAC_CONFIG_HDSMS_256		(0x2 << GMAC_CONFIG_HDSMS_SHIFT)
+
+/* MAC HW features0 bitmap */
+#define GMAC_HW_FEAT_SAVLANINS		BIT(27)
+#define GMAC_HW_FEAT_ADDMAC		BIT(18)
+#define GMAC_HW_FEAT_RXCOESEL		BIT(16)
+#define GMAC_HW_FEAT_TXCOSEL		BIT(14)
+#define GMAC_HW_FEAT_EEESEL		BIT(13)
+#define GMAC_HW_FEAT_TSSEL		BIT(12)
+#define GMAC_HW_FEAT_ARPOFFSEL		BIT(9)
+#define GMAC_HW_FEAT_MMCSEL		BIT(8)
+#define GMAC_HW_FEAT_MGKSEL		BIT(7)
+#define GMAC_HW_FEAT_RWKSEL		BIT(6)
+#define GMAC_HW_FEAT_SMASEL		BIT(5)
+#define GMAC_HW_FEAT_VLHASH		BIT(4)
+#define GMAC_HW_FEAT_PCSSEL		BIT(3)
+#define GMAC_HW_FEAT_HDSEL		BIT(2)
+#define GMAC_HW_FEAT_GMIISEL		BIT(1)
+#define GMAC_HW_FEAT_MIISEL		BIT(0)
+
+/* MAC HW features1 bitmap */
+#define GMAC_HW_FEAT_L3L4FNUM		GENMASK(30, 27)
+#define GMAC_HW_HASH_TB_SZ		GENMASK(25, 24)
+#define GMAC_HW_FEAT_AVSEL		BIT(20)
+#define GMAC_HW_TSOEN			BIT(18)
+#define GMAC_HW_FEAT_SPHEN		BIT(17)
+#define GMAC_HW_ADDR64			GENMASK(15, 14)
+#define GMAC_HW_TXFIFOSIZE		GENMASK(10, 6)
+#define GMAC_HW_RXFIFOSIZE		GENMASK(4, 0)
+
+/* MAC HW features2 bitmap */
+#define GMAC_HW_FEAT_PPSOUTNUM		GENMASK(26, 24)
+#define GMAC_HW_FEAT_TXCHCNT		GENMASK(21, 18)
+#define GMAC_HW_FEAT_RXCHCNT		GENMASK(15, 12)
+#define GMAC_HW_FEAT_TXQCNT		GENMASK(9, 6)
+#define GMAC_HW_FEAT_RXQCNT		GENMASK(3, 0)
+
+/* MAC HW features3 bitmap */
+#define GMAC_HW_FEAT_ASP		GENMASK(29, 28)
+#define GMAC_HW_FEAT_TBSSEL		BIT(27)
+#define GMAC_HW_FEAT_FPESEL		BIT(26)
+#define GMAC_HW_FEAT_ESTWID		GENMASK(21, 20)
+#define GMAC_HW_FEAT_ESTDEP		GENMASK(19, 17)
+#define GMAC_HW_FEAT_ESTSEL		BIT(16)
+#define GMAC_HW_FEAT_FRPES		GENMASK(14, 13)
+#define GMAC_HW_FEAT_FRPBS		GENMASK(12, 11)
+#define GMAC_HW_FEAT_FRPSEL		BIT(10)
+#define GMAC_HW_FEAT_DVLAN		BIT(5)
+#define GMAC_HW_FEAT_NRVF		GENMASK(2, 0)
+
+/* MAC HW ADDR regs */
+#define GMAC_HI_DCS			GENMASK(18, 16)
+#define GMAC_HI_DCS_SHIFT		16
+#define GMAC_HI_REG_AE			BIT(31)
+
+/* L3/L4 Filters regs */
+#define GMAC_L4DPIM0			BIT(21)
+#define GMAC_L4DPM0			BIT(20)
+#define GMAC_L4SPIM0			BIT(19)
+#define GMAC_L4SPM0			BIT(18)
+#define GMAC_L4PEN0			BIT(16)
+#define GMAC_L3DAIM0			BIT(5)
+#define GMAC_L3DAM0			BIT(4)
+#define GMAC_L3SAIM0			BIT(3)
+#define GMAC_L3SAM0			BIT(2)
+#define GMAC_L3PEN0			BIT(0)
+#define GMAC_L4DP0			GENMASK(31, 16)
+#define GMAC_L4DP0_SHIFT		16
+#define GMAC_L4SP0			GENMASK(15, 0)
+
+/*  MTL registers */
+#define MTL_OPERATION_MODE		0x00000c00
+#define MTL_FRPE			BIT(15)
+#define MTL_OPERATION_SCHALG_MASK	GENMASK(6, 5)
+#define MTL_OPERATION_SCHALG_WRR	(0x0 << 5)
+#define MTL_OPERATION_SCHALG_WFQ	(0x1 << 5)
+#define MTL_OPERATION_SCHALG_DWRR	(0x2 << 5)
+#define MTL_OPERATION_SCHALG_SP		(0x3 << 5)
+#define MTL_OPERATION_RAA		BIT(2)
+#define MTL_OPERATION_RAA_SP		(0x0 << 2)
+#define MTL_OPERATION_RAA_WSP		(0x1 << 2)
+
+#define MTL_INT_STATUS			0x00000c20
+#define MTL_INT_QX(x)			BIT(x)
+
+#define MTL_RXQ_DMA_MAP0		0x00000c30 /* queue 0 to 3 */
+#define MTL_RXQ_DMA_MAP1		0x00000c34 /* queue 4 to 7 */
+#define MTL_RXQ_DMA_Q04MDMACH_MASK	GENMASK(3, 0)
+#define MTL_RXQ_DMA_Q04MDMACH(x)	((x) << 0)
+#define MTL_RXQ_DMA_QXMDMACH_MASK(x)	GENMASK(11 + (8 * ((x) - 1)), 8 * (x))
+#define MTL_RXQ_DMA_QXMDMACH(chan, q)	((chan) << (8 * (q)))
+
+#define MTL_CHAN_BASE_ADDR		0x00000d00
+#define MTL_CHAN_BASE_OFFSET		0x40
+#define MTL_CHANX_BASE_ADDR(x)		(MTL_CHAN_BASE_ADDR + \
+					(x * MTL_CHAN_BASE_OFFSET))
+
+#define MTL_CHAN_TX_OP_MODE(x)		MTL_CHANX_BASE_ADDR(x)
+#define MTL_CHAN_TX_DEBUG(x)		(MTL_CHANX_BASE_ADDR(x) + 0x8)
+#define MTL_CHAN_INT_CTRL(x)		(MTL_CHANX_BASE_ADDR(x) + 0x2c)
+#define MTL_CHAN_RX_OP_MODE(x)		(MTL_CHANX_BASE_ADDR(x) + 0x30)
+#define MTL_CHAN_RX_DEBUG(x)		(MTL_CHANX_BASE_ADDR(x) + 0x38)
+
+#define MTL_OP_MODE_RSF			BIT(5)
+#define MTL_OP_MODE_TXQEN_MASK		GENMASK(3, 2)
+#define MTL_OP_MODE_TXQEN_AV		BIT(2)
+#define MTL_OP_MODE_TXQEN		BIT(3)
+#define MTL_OP_MODE_TSF			BIT(1)
+
+#define MTL_OP_MODE_TQS_MASK		GENMASK(24, 16)
+#define MTL_OP_MODE_TQS_SHIFT		16
+
+#define MTL_OP_MODE_TTC_MASK		0x70
+#define MTL_OP_MODE_TTC_SHIFT		4
+
+#define MTL_OP_MODE_TTC_32		0
+#define MTL_OP_MODE_TTC_64		(1 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_96		(2 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_128		(3 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_192		(4 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_256		(5 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_384		(6 << MTL_OP_MODE_TTC_SHIFT)
+#define MTL_OP_MODE_TTC_512		(7 << MTL_OP_MODE_TTC_SHIFT)
+
+#define MTL_OP_MODE_RQS_MASK		GENMASK(29, 20)
+#define MTL_OP_MODE_RQS_SHIFT		20
+
+#define MTL_OP_MODE_RFD_MASK		GENMASK(19, 14)
+#define MTL_OP_MODE_RFD_SHIFT		14
+
+#define MTL_OP_MODE_RFA_MASK		GENMASK(13, 8)
+#define MTL_OP_MODE_RFA_SHIFT		8
+
+#define MTL_OP_MODE_EHFC		BIT(7)
+
+#define MTL_OP_MODE_RTC_MASK		0x18
+#define MTL_OP_MODE_RTC_SHIFT		3
+
+#define MTL_OP_MODE_RTC_32		(1 << MTL_OP_MODE_RTC_SHIFT)
+#define MTL_OP_MODE_RTC_64		0
+#define MTL_OP_MODE_RTC_96		(2 << MTL_OP_MODE_RTC_SHIFT)
+#define MTL_OP_MODE_RTC_128		(3 << MTL_OP_MODE_RTC_SHIFT)
+
+/* MTL ETS Control register */
+#define MTL_ETS_CTRL_BASE_ADDR		0x00000d10
+#define MTL_ETS_CTRL_BASE_OFFSET	0x40
+#define MTL_ETSX_CTRL_BASE_ADDR(x)	(MTL_ETS_CTRL_BASE_ADDR + \
+					((x) * MTL_ETS_CTRL_BASE_OFFSET))
+
+#define MTL_ETS_CTRL_CC			BIT(3)
+#define MTL_ETS_CTRL_AVALG		BIT(2)
+
+/* MTL Queue Quantum Weight */
+#define MTL_TXQ_WEIGHT_BASE_ADDR	0x00000d18
+#define MTL_TXQ_WEIGHT_BASE_OFFSET	0x40
+#define MTL_TXQX_WEIGHT_BASE_ADDR(x)	(MTL_TXQ_WEIGHT_BASE_ADDR + \
+					((x) * MTL_TXQ_WEIGHT_BASE_OFFSET))
+#define MTL_TXQ_WEIGHT_ISCQW_MASK	GENMASK(20, 0)
+
+/* MTL sendSlopeCredit register */
+#define MTL_SEND_SLP_CRED_BASE_ADDR	0x00000d1c
+#define MTL_SEND_SLP_CRED_OFFSET	0x40
+#define MTL_SEND_SLP_CREDX_BASE_ADDR(x)	(MTL_SEND_SLP_CRED_BASE_ADDR + \
+					((x) * MTL_SEND_SLP_CRED_OFFSET))
+
+#define MTL_SEND_SLP_CRED_SSC_MASK	GENMASK(13, 0)
+
+/* MTL hiCredit register */
+#define MTL_HIGH_CRED_BASE_ADDR		0x00000d20
+#define MTL_HIGH_CRED_OFFSET		0x40
+#define MTL_HIGH_CREDX_BASE_ADDR(x)	(MTL_HIGH_CRED_BASE_ADDR + \
+					((x) * MTL_HIGH_CRED_OFFSET))
+
+#define MTL_HIGH_CRED_HC_MASK		GENMASK(28, 0)
+
+/* MTL loCredit register */
+#define MTL_LOW_CRED_BASE_ADDR		0x00000d24
+#define MTL_LOW_CRED_OFFSET		0x40
+#define MTL_LOW_CREDX_BASE_ADDR(x)	(MTL_LOW_CRED_BASE_ADDR + \
+					((x) * MTL_LOW_CRED_OFFSET))
+
+#define MTL_HIGH_CRED_LC_MASK		GENMASK(28, 0)
+
+/*  MTL debug */
+#define MTL_DEBUG_TXSTSFSTS		BIT(5)
+#define MTL_DEBUG_TXFSTS		BIT(4)
+#define MTL_DEBUG_TWCSTS		BIT(3)
+
+/* MTL debug: Tx FIFO Read Controller Status */
+#define MTL_DEBUG_TRCSTS_MASK		GENMASK(2, 1)
+#define MTL_DEBUG_TRCSTS_SHIFT		1
+#define MTL_DEBUG_TRCSTS_IDLE		0
+#define MTL_DEBUG_TRCSTS_READ		1
+#define MTL_DEBUG_TRCSTS_TXW		2
+#define MTL_DEBUG_TRCSTS_WRITE		3
+#define MTL_DEBUG_TXPAUSED		BIT(0)
+
+/* MAC debug: GMII or MII Transmit Protocol Engine Status */
+#define MTL_DEBUG_RXFSTS_MASK		GENMASK(5, 4)
+#define MTL_DEBUG_RXFSTS_SHIFT		4
+#define MTL_DEBUG_RXFSTS_EMPTY		0
+#define MTL_DEBUG_RXFSTS_BT		1
+#define MTL_DEBUG_RXFSTS_AT		2
+#define MTL_DEBUG_RXFSTS_FULL		3
+#define MTL_DEBUG_RRCSTS_MASK		GENMASK(2, 1)
+#define MTL_DEBUG_RRCSTS_SHIFT		1
+#define MTL_DEBUG_RRCSTS_IDLE		0
+#define MTL_DEBUG_RRCSTS_RDATA		1
+#define MTL_DEBUG_RRCSTS_RSTAT		2
+#define MTL_DEBUG_RRCSTS_FLUSH		3
+#define MTL_DEBUG_RWCSTS		BIT(0)
+
+/*  MTL interrupt */
+#define MTL_RX_OVERFLOW_INT_EN		BIT(24)
+#define MTL_RX_OVERFLOW_INT		BIT(16)
+
+/* Default operating mode of the MAC */
+#define GMAC_CORE_INIT (GMAC_CONFIG_JD | GMAC_CONFIG_PS | \
+			GMAC_CONFIG_BE | GMAC_CONFIG_DCRS | \
+			GMAC_CONFIG_JE)
+
+/* To dump the core regs excluding  the Address Registers */
+#define	GMAC_REG_NUM	132
+
+/*  MTL debug */
+#define MTL_DEBUG_TXSTSFSTS		BIT(5)
+#define MTL_DEBUG_TXFSTS		BIT(4)
+#define MTL_DEBUG_TWCSTS		BIT(3)
+
+/* MTL debug: Tx FIFO Read Controller Status */
+#define MTL_DEBUG_TRCSTS_MASK		GENMASK(2, 1)
+#define MTL_DEBUG_TRCSTS_SHIFT		1
+#define MTL_DEBUG_TRCSTS_IDLE		0
+#define MTL_DEBUG_TRCSTS_READ		1
+#define MTL_DEBUG_TRCSTS_TXW		2
+#define MTL_DEBUG_TRCSTS_WRITE		3
+#define MTL_DEBUG_TXPAUSED		BIT(0)
+
+/* MAC debug: GMII or MII Transmit Protocol Engine Status */
+#define MTL_DEBUG_RXFSTS_MASK		GENMASK(5, 4)
+#define MTL_DEBUG_RXFSTS_SHIFT		4
+#define MTL_DEBUG_RXFSTS_EMPTY		0
+#define MTL_DEBUG_RXFSTS_BT		1
+#define MTL_DEBUG_RXFSTS_AT		2
+#define MTL_DEBUG_RXFSTS_FULL		3
+#define MTL_DEBUG_RRCSTS_MASK		GENMASK(2, 1)
+#define MTL_DEBUG_RRCSTS_SHIFT		1
+#define MTL_DEBUG_RRCSTS_IDLE		0
+#define MTL_DEBUG_RRCSTS_RDATA		1
+#define MTL_DEBUG_RRCSTS_RSTAT		2
+#define MTL_DEBUG_RRCSTS_FLUSH		3
+#define MTL_DEBUG_RWCSTS		BIT(0)
+
+/* SGMII/RGMII status register */
+#define GMAC_PHYIF_CTRLSTATUS_TC		BIT(0)
+#define GMAC_PHYIF_CTRLSTATUS_LUD		BIT(1)
+#define GMAC_PHYIF_CTRLSTATUS_SMIDRXS		BIT(4)
+#define GMAC_PHYIF_CTRLSTATUS_LNKMOD		BIT(16)
+#define GMAC_PHYIF_CTRLSTATUS_SPEED		GENMASK(18, 17)
+#define GMAC_PHYIF_CTRLSTATUS_SPEED_SHIFT	17
+#define GMAC_PHYIF_CTRLSTATUS_LNKSTS		BIT(19)
+#define GMAC_PHYIF_CTRLSTATUS_JABTO		BIT(20)
+#define GMAC_PHYIF_CTRLSTATUS_FALSECARDET	BIT(21)
+/* LNKMOD */
+#define GMAC_PHYIF_CTRLSTATUS_LNKMOD_MASK	0x1
+/* LNKSPEED */
+#define GMAC_PHYIF_CTRLSTATUS_SPEED_125		0x2
+#define GMAC_PHYIF_CTRLSTATUS_SPEED_25		0x1
+#define GMAC_PHYIF_CTRLSTATUS_SPEED_2_5		0x0
+
+extern const struct stmmac_dma_ops dwmac4_dma_ops;
+extern const struct stmmac_dma_ops dwmac410_dma_ops;
+#endif /* __DWMAC4_H__ */
diff --git a/drivers/net/stmmac/dwmac4_core.c b/drivers/net/stmmac/dwmac4_core.c
new file mode 100644
index 0000000..9c8b19a
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_core.c
@@ -0,0 +1,1272 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include "stmmac_pmd_logs.h"
+#include "stmmac.h"
+#include "dwmac4.h"
+#include "dwmac5.h"
+
+#define WAKE_UCAST		(1 << 1)
+#define WAKE_MAGIC		(1 << 5)
+
+/* PCS registers (AN/TBI/SGMII/RGMII) offsets */
+#define GMAC_AN_CTRL(x)		(x)		/* AN control */
+#define GMAC_AN_STATUS(x)	(x + 0x4)	/* AN status */
+#define GMAC_ANE_ADV(x)		(x + 0x8)	/* ANE Advertisement */
+#define GMAC_ANE_LPA(x)		(x + 0xc)	/* ANE link partener ability */
+#define GMAC_ANE_EXP(x)		(x + 0x10)	/* ANE expansion */
+#define GMAC_TBI(x)		(x + 0x14)	/* TBI extend status */
+
+/* AN Configuration defines */
+#define GMAC_AN_CTRL_RAN	BIT(9)	/* Restart Auto-Negotiation */
+#define GMAC_AN_CTRL_ANE	BIT(12)	/* Auto-Negotiation Enable */
+#define GMAC_AN_CTRL_ELE	BIT(14)	/* External Loopback Enable */
+#define GMAC_AN_CTRL_ECD	BIT(16)	/* Enable Comma Detect */
+#define GMAC_AN_CTRL_LR		BIT(17)	/* Lock to Reference */
+#define GMAC_AN_CTRL_SGMRAL	BIT(18)	/* SGMII RAL Control */
+
+/* AN Status defines */
+#define GMAC_AN_STATUS_LS	BIT(2)	/* Link Status 0:down 1:up */
+#define GMAC_AN_STATUS_ANA	BIT(3)	/* Auto-Negotiation Ability */
+#define GMAC_AN_STATUS_ANC	BIT(5)	/* Auto-Negotiation Complete */
+#define GMAC_AN_STATUS_ES	BIT(8)	/* Extended Status */
+
+#define ETH_ALEN		6
+
+static uint32_t bitrev32(uint32_t x)
+{
+	x = (x >> 16) | (x << 16);
+	x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));
+	x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));
+	x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));
+	x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));
+	return x;
+}
+
+static uint32_t crc32_le(uint32_t crc, uint8_t *p, uint32_t len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++;
+		for (i = 0; i < 8; i++)
+			crc = (crc >> 1) ^ ((crc & 1) ? 0xedb88320 : 0);
+	}
+	return crc;
+}
+
+static void dwmac4_core_init(struct mac_device_info *hw,
+			     struct stmmac_private *priv)
+{
+
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	ioaddr = priv->ioaddr_v;
+	value |= GMAC_CORE_INIT;
+
+	if (hw->ps) {
+		value |= GMAC_CONFIG_TE;
+
+		value &= hw->link.speed_mask;
+		switch (hw->ps) {
+		case SPEED_1000:
+			value |= hw->link.speed1000;
+			break;
+		case SPEED_100:
+			value |= hw->link.speed100;
+			break;
+		case SPEED_10:
+			value |= hw->link.speed10;
+			break;
+		}
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+
+	/* Enable GMAC interrupts */
+	value = GMAC_INT_DEFAULT_ENABLE;
+
+	if (hw->pcs)
+		value |= GMAC_PCS_IRQ_DEFAULT;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_INT_EN);
+}
+
+static void dwmac4_rx_queue_enable(struct mac_device_info *hw,
+				   uint8_t mode, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_RXQ_CTRL0);
+
+	value &= GMAC_RX_QUEUE_CLEAR(queue);
+	if (mode == MTL_QUEUE_AVB)
+		value |= GMAC_RX_AV_QUEUE_ENABLE(queue);
+	else if (mode == MTL_QUEUE_DCB)
+		value |= GMAC_RX_DCB_QUEUE_ENABLE(queue);
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_RXQ_CTRL0);
+}
+
+static void dwmac4_rx_queue_priority(struct mac_device_info *hw,
+				     uint32_t prio, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t base_register;
+	uint32_t value;
+
+	base_register = (queue < 4) ? GMAC_RXQ_CTRL2 : GMAC_RXQ_CTRL3;
+	if (queue >= 4)
+		queue -= 4;
+
+	value = rte_read32((uint8_t *)ioaddr + base_register);
+
+	value &= ~GMAC_RXQCTRL_PSRQX_MASK(queue);
+	value |= (prio << GMAC_RXQCTRL_PSRQX_SHIFT(queue)) &
+						GMAC_RXQCTRL_PSRQX_MASK(queue);
+	rte_write32(value, (uint8_t *)ioaddr + base_register);
+}
+
+static void dwmac4_tx_queue_priority(struct mac_device_info *hw,
+				     uint32_t prio, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t base_register;
+	uint32_t value;
+
+	base_register = (queue < 4) ? GMAC_TXQ_PRTY_MAP0 : GMAC_TXQ_PRTY_MAP1;
+	if (queue >= 4)
+		queue -= 4;
+
+	value = rte_read32((uint8_t *)ioaddr + base_register);
+
+	value &= ~GMAC_TXQCTRL_PSTQX_MASK(queue);
+	value |= (prio << GMAC_TXQCTRL_PSTQX_SHIFT(queue)) &
+						GMAC_TXQCTRL_PSTQX_MASK(queue);
+
+	rte_write32(value, (uint8_t *)ioaddr + base_register);
+}
+
+static void dwmac4_rx_queue_routing(struct mac_device_info *hw,
+				    uint8_t packet, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	static const struct stmmac_rx_routing route_possibilities[] = {
+		{ GMAC_RXQCTRL_AVCPQ_MASK, GMAC_RXQCTRL_AVCPQ_SHIFT },
+		{ GMAC_RXQCTRL_PTPQ_MASK, GMAC_RXQCTRL_PTPQ_SHIFT },
+		{ GMAC_RXQCTRL_DCBCPQ_MASK, GMAC_RXQCTRL_DCBCPQ_SHIFT },
+		{ GMAC_RXQCTRL_UPQ_MASK, GMAC_RXQCTRL_UPQ_SHIFT },
+		{ GMAC_RXQCTRL_MCBCQ_MASK, GMAC_RXQCTRL_MCBCQ_SHIFT },
+	};
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_RXQ_CTRL1);
+
+	/* routing configuration */
+	value &= ~route_possibilities[packet - 1].reg_mask;
+	value |= (queue << route_possibilities[packet-1].reg_shift) &
+		 route_possibilities[packet - 1].reg_mask;
+
+	/* some packets require extra ops */
+	if (packet == PACKET_AVCPQ) {
+		value &= ~GMAC_RXQCTRL_TACPQE;
+		value |= 0x1 << GMAC_RXQCTRL_TACPQE_SHIFT;
+	} else if (packet == PACKET_MCBCQ) {
+		value &= ~GMAC_RXQCTRL_MCBCQEN;
+		value |= 0x1 << GMAC_RXQCTRL_MCBCQEN_SHIFT;
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_RXQ_CTRL1);
+}
+
+static void dwmac4_prog_mtl_rx_algorithms(struct mac_device_info *hw,
+					  uint32_t rx_alg)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + MTL_OPERATION_MODE);
+
+	value &= ~MTL_OPERATION_RAA;
+	switch (rx_alg) {
+	case MTL_RX_ALGORITHM_SP:
+		value |= MTL_OPERATION_RAA_SP;
+		break;
+	case MTL_RX_ALGORITHM_WSP:
+		value |= MTL_OPERATION_RAA_WSP;
+		break;
+	default:
+		break;
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + MTL_OPERATION_MODE);
+}
+
+static void dwmac4_prog_mtl_tx_algorithms(struct mac_device_info *hw,
+					  uint32_t tx_alg)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + MTL_OPERATION_MODE);
+
+	value &= ~MTL_OPERATION_SCHALG_MASK;
+	switch (tx_alg) {
+	case MTL_TX_ALGORITHM_WRR:
+		value |= MTL_OPERATION_SCHALG_WRR;
+		break;
+	case MTL_TX_ALGORITHM_WFQ:
+		value |= MTL_OPERATION_SCHALG_WFQ;
+		break;
+	case MTL_TX_ALGORITHM_DWRR:
+		value |= MTL_OPERATION_SCHALG_DWRR;
+		break;
+	case MTL_TX_ALGORITHM_SP:
+		value |= MTL_OPERATION_SCHALG_SP;
+		break;
+	default:
+		break;
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + MTL_OPERATION_MODE);
+}
+
+static void dwmac4_set_mtl_tx_queue_weight(struct mac_device_info *hw,
+					   uint32_t weight, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + MTL_TXQX_WEIGHT_BASE_ADDR(queue));
+
+	value &= ~MTL_TXQ_WEIGHT_ISCQW_MASK;
+	value |= weight & MTL_TXQ_WEIGHT_ISCQW_MASK;
+	rte_write32(value, (uint8_t *)ioaddr + MTL_TXQX_WEIGHT_BASE_ADDR(queue));
+}
+
+static void dwmac4_map_mtl_dma(struct mac_device_info *hw, uint32_t queue, uint32_t chan)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	if (queue < 4)
+		value = rte_read32((uint8_t *)ioaddr + MTL_RXQ_DMA_MAP0);
+	else
+		value = rte_read32((uint8_t *)ioaddr + MTL_RXQ_DMA_MAP1);
+
+	if (queue == 0 || queue == 4) {
+		value &= ~MTL_RXQ_DMA_Q04MDMACH_MASK;
+		value |= MTL_RXQ_DMA_Q04MDMACH(chan);
+	} else {
+		value &= ~MTL_RXQ_DMA_QXMDMACH_MASK(queue);
+		value |= MTL_RXQ_DMA_QXMDMACH(chan, queue);
+	}
+
+	if (queue < 4)
+		rte_write32(value, (uint8_t *)ioaddr + MTL_RXQ_DMA_MAP0);
+	else
+		rte_write32(value, (uint8_t *)ioaddr + MTL_RXQ_DMA_MAP1);
+}
+
+static void dwmac4_config_cbs(struct mac_device_info *hw,
+			      uint32_t send_slope, uint32_t idle_slope,
+			      uint32_t high_credit, uint32_t low_credit, uint32_t queue)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	STMMAC_PMD_INFO("Queue %d configured as AVB. Parameters:\n", queue);
+	STMMAC_PMD_INFO("\tsend_slope: 0x%08x\n", send_slope);
+	STMMAC_PMD_INFO("\tidle_slope: 0x%08x\n", idle_slope);
+	STMMAC_PMD_INFO("\thigh_credit: 0x%08x\n", high_credit);
+	STMMAC_PMD_INFO("\tlow_credit: 0x%08x\n", low_credit);
+
+	/* enable AV algorithm */
+	value = rte_read32((uint8_t *)ioaddr + MTL_ETSX_CTRL_BASE_ADDR(queue));
+	value |= MTL_ETS_CTRL_AVALG;
+	value |= MTL_ETS_CTRL_CC;
+	rte_write32(value, (uint8_t *)ioaddr + MTL_ETSX_CTRL_BASE_ADDR(queue));
+
+	/* configure send slope */
+	value = rte_read32((uint8_t *)ioaddr + MTL_SEND_SLP_CREDX_BASE_ADDR(queue));
+	value &= ~MTL_SEND_SLP_CRED_SSC_MASK;
+	value |= send_slope & MTL_SEND_SLP_CRED_SSC_MASK;
+	rte_write32(value, (uint8_t *)ioaddr + MTL_SEND_SLP_CREDX_BASE_ADDR(queue));
+
+	/* configure idle slope (same register as tx weight) */
+	dwmac4_set_mtl_tx_queue_weight(hw, idle_slope, queue);
+
+	/* configure high credit */
+	value = rte_read32((uint8_t *)ioaddr + MTL_HIGH_CREDX_BASE_ADDR(queue));
+	value &= ~MTL_HIGH_CRED_HC_MASK;
+	value |= high_credit & MTL_HIGH_CRED_HC_MASK;
+	rte_write32(value, (uint8_t *)ioaddr + MTL_HIGH_CREDX_BASE_ADDR(queue));
+
+	/* configure high credit */
+	value = rte_read32((uint8_t *)ioaddr + MTL_LOW_CREDX_BASE_ADDR(queue));
+	value &= ~MTL_HIGH_CRED_LC_MASK;
+	value |= low_credit & MTL_HIGH_CRED_LC_MASK;
+	rte_write32(value, (uint8_t *)ioaddr + MTL_LOW_CREDX_BASE_ADDR(queue));
+}
+
+static void dwmac4_dump_regs(struct mac_device_info *hw, uint32_t *reg_space)
+{
+	void *ioaddr = hw->pcsr;
+	int i;
+
+	for (i = 0; i < GMAC_REG_NUM; i++)
+		reg_space[i] = rte_read32((uint8_t *)ioaddr + i * 4);
+}
+
+static int dwmac4_rx_ipc_enable(struct mac_device_info *hw)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	if (hw->rx_csum)
+		value |= GMAC_CONFIG_IPC;
+	else
+		value &= ~GMAC_CONFIG_IPC;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	return !!(value & GMAC_CONFIG_IPC);
+}
+
+static void dwmac4_pmt(struct mac_device_info *hw, unsigned long mode)
+{
+	void *ioaddr = hw->pcsr;
+	unsigned int pmt = 0;
+	uint32_t config;
+
+	if (mode & WAKE_MAGIC) {
+		STMMAC_PMD_INFO("GMAC: WOL Magic frame\n");
+		pmt |= power_down | magic_pkt_en;
+	}
+	if (mode & WAKE_UCAST) {
+		STMMAC_PMD_INFO("GMAC: WOL on global unicast\n");
+		pmt |= power_down | global_unicast | wake_up_frame_en;
+	}
+
+	if (pmt) {
+		/* The receiver must be enabled for WOL before powering down */
+		config = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+		config |= GMAC_CONFIG_RE;
+		rte_write32(config, (uint8_t *)ioaddr + GMAC_CONFIG);
+	}
+	rte_write32(pmt, (uint8_t *)ioaddr + GMAC_PMT);
+}
+
+static void dwmac4_set_umac_addr(struct mac_device_info *hw,
+				 unsigned char *addr, unsigned int reg_n)
+{
+	void *ioaddr = hw->pcsr;
+
+	stmmac_dwmac4_set_mac_addr(ioaddr, (uint8_t *)addr, GMAC_ADDR_HIGH(reg_n),
+				   GMAC_ADDR_LOW(reg_n));
+}
+
+static void dwmac4_get_umac_addr(struct mac_device_info *hw,
+				 unsigned char *addr, unsigned int reg_n)
+{
+	void *ioaddr = hw->pcsr;
+
+	stmmac_dwmac4_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),
+				   GMAC_ADDR_LOW(reg_n));
+}
+
+static void dwmac4_set_eee_mode(struct mac_device_info *hw,
+				bool en_tx_lpi_clockgating)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	/* Enable the link status receive on RGMII, SGMII ore SMII
+	 * receive path and instruct the transmit to enter in LPI
+	 * state.
+	 */
+	value = rte_read32((uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+	value |= GMAC4_LPI_CTRL_STATUS_LPIEN | GMAC4_LPI_CTRL_STATUS_LPITXA;
+
+	if (en_tx_lpi_clockgating)
+		value |= GMAC4_LPI_CTRL_STATUS_LPITCSE;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+}
+
+static void dwmac4_reset_eee_mode(struct mac_device_info *hw)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+	value &= ~(GMAC4_LPI_CTRL_STATUS_LPIEN | GMAC4_LPI_CTRL_STATUS_LPITXA);
+	rte_write32(value, (uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+}
+
+static void dwmac4_set_eee_pls(struct mac_device_info *hw, int link)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+
+	if (link)
+		value |= GMAC4_LPI_CTRL_STATUS_PLS;
+	else
+		value &= ~GMAC4_LPI_CTRL_STATUS_PLS;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+}
+
+static void dwmac4_set_eee_timer(struct mac_device_info *hw, int ls, int tw)
+{
+	void *ioaddr = hw->pcsr;
+	int value = ((tw & 0xffff)) | ((ls & 0x3ff) << 16);
+
+	/* Program the timers in the LPI timer control register:
+	 * LS: minimum time (ms) for which the link
+	 *  status from PHY should be ok before transmitting
+	 *  the LPI pattern.
+	 * TW: minimum time (us) for which the core waits
+	 *  after it has stopped transmitting the LPI pattern.
+	 */
+	rte_write32(value, (uint8_t *)ioaddr + GMAC4_LPI_TIMER_CTRL);
+}
+
+static void dwmac4_write_single_vlan(struct stmmac_private *priv, uint16_t vid)
+{
+	void *ioaddr = (void  *)priv->ioaddr_v;
+	uint32_t val;
+
+	val = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	val &= ~GMAC_VLAN_TAG_VID;
+	val |= GMAC_VLAN_TAG_ETV | vid;
+
+	rte_write32(val, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+}
+
+static int dwmac4_write_vlan_filter(struct stmmac_private *priv,
+				    struct mac_device_info *hw,
+				    uint8_t index, uint32_t data)
+{
+	void *ioaddr = (void  *)priv->ioaddr_v;
+	int i, timeout = 10;
+	uint32_t val;
+
+	if (index >= hw->num_vlan)
+		return -EINVAL;
+
+	rte_write32(data, (uint8_t *)ioaddr + GMAC_VLAN_TAG_DATA);
+
+	val = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	val &= ~(GMAC_VLAN_TAG_CTRL_OFS_MASK |
+		GMAC_VLAN_TAG_CTRL_CT |
+		GMAC_VLAN_TAG_CTRL_OB);
+	val |= (index << GMAC_VLAN_TAG_CTRL_OFS_SHIFT) | GMAC_VLAN_TAG_CTRL_OB;
+
+	rte_write32(val, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+
+	for (i = 0; i < timeout; i++) {
+		val = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+		if (!(val & GMAC_VLAN_TAG_CTRL_OB))
+			return 0;
+		rte_delay_us(1);
+	}
+
+	STMMAC_PMD_ERR("Timeout accessing MAC_VLAN_Tag_Filter\n");
+
+	return -EBUSY;
+}
+
+static int dwmac4_add_hw_vlan_rx_fltr(struct stmmac_private *priv,
+				      struct mac_device_info *hw,
+				      uint16_t proto, uint16_t vid)
+{
+	int index = -1;
+	uint32_t val = 0;
+	unsigned int i, ret;
+
+	proto = 0;
+
+	if (vid > 4095)
+		return -EINVAL;
+
+	if (hw->promisc) {
+		STMMAC_PMD_ERR("Adding VLAN in promisc mode not supported\n");
+		return -EPERM;
+	}
+
+	/* Single Rx VLAN Filter */
+	if (hw->num_vlan == 1) {
+		/* For single VLAN filter, VID 0 means VLAN promiscuous */
+		if (vid == 0) {
+			STMMAC_PMD_WARN("Adding VLAN ID 0 is not supported\n");
+			return -EPERM;
+		}
+
+		if (hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) {
+			STMMAC_PMD_ERR("Only single VLAN ID supported\n");
+			return -EPERM;
+		}
+
+		hw->vlan_filter[0] = vid;
+		dwmac4_write_single_vlan(priv, vid);
+
+		return 0;
+	}
+
+	/* Extended Rx VLAN Filter Enable */
+	val |= GMAC_VLAN_TAG_DATA_ETV | GMAC_VLAN_TAG_DATA_VEN | vid;
+
+	for (i = 0; i < hw->num_vlan; i++) {
+		if (hw->vlan_filter[i] == val)
+			return 0;
+		else if (!(hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN))
+			index = i;
+	}
+
+	if (index == -1) {
+		STMMAC_PMD_ERR("MAC_VLAN_Tag_Filter full (size: %0u)\n",
+			   hw->num_vlan);
+		return -EPERM;
+	}
+
+	ret = dwmac4_write_vlan_filter(priv, hw, index, val);
+	if (!ret)
+		hw->vlan_filter[index] = val;
+
+	return ret;
+
+	return 0;
+}
+
+static int dwmac4_del_hw_vlan_rx_fltr(struct stmmac_private *priv,
+				      struct mac_device_info *hw,
+				      uint16_t proto, uint16_t vid)
+{
+	unsigned int i, ret = 0;
+
+	if (hw->promisc) {
+		STMMAC_PMD_ERR("Deleting VLAN in promisc mode not supported\n");
+		return -EPERM;
+	}
+
+	/* Single Rx VLAN Filter */
+	if (hw->num_vlan == 1) {
+		if ((hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) == vid) {
+			hw->vlan_filter[0] = 0;
+			dwmac4_write_single_vlan(priv, 0);
+		}
+		return 0;
+	}
+
+	/* Extended Rx VLAN Filter Enable */
+	for (i = 0; i < hw->num_vlan; i++) {
+		if ((hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VID) == vid) {
+			ret = dwmac4_write_vlan_filter(priv, hw, i, 0);
+
+			if (!ret)
+				hw->vlan_filter[i] = 0;
+			else
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static void dwmac4_vlan_promisc_enable(struct stmmac_private *priv,
+				       struct mac_device_info *hw)
+{
+	void  *ioaddr  = hw->pcsr;
+	uint32_t value;
+	uint32_t hash;
+	uint32_t val;
+	unsigned int i;
+
+	/* Single Rx VLAN Filter */
+	if (hw->num_vlan == 1) {
+		dwmac4_write_single_vlan(priv, 0);
+		return;
+	}
+
+	/* Extended Rx VLAN Filter Enable */
+	for (i = 0; i < hw->num_vlan; i++) {
+		if (hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN) {
+			val = hw->vlan_filter[i] & ~GMAC_VLAN_TAG_DATA_VEN;
+			dwmac4_write_vlan_filter(priv, hw, i, val);
+		}
+	}
+
+	hash = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_HASH_TABLE);
+	if (hash & GMAC_VLAN_VLHT) {
+		value = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+		if (value & GMAC_VLAN_VTHM) {
+			value &= ~GMAC_VLAN_VTHM;
+			rte_write32(value, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+		}
+	}
+}
+
+static void dwmac4_restore_hw_vlan_rx_fltr(struct stmmac_private *priv,
+					   struct mac_device_info *hw)
+{
+	void  *ioaddr  = hw->pcsr;
+	uint32_t value;
+	uint32_t hash;
+	uint32_t val;
+	unsigned int i;
+
+	/* Single Rx VLAN Filter */
+	if (hw->num_vlan == 1) {
+		dwmac4_write_single_vlan(priv, hw->vlan_filter[0]);
+		return;
+	}
+
+	/* Extended Rx VLAN Filter Enable */
+	for (i = 0; i < hw->num_vlan; i++) {
+		if (hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN) {
+			val = hw->vlan_filter[i];
+			dwmac4_write_vlan_filter(priv, hw, i, val);
+		}
+	}
+
+	hash = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_HASH_TABLE);
+	if (hash & GMAC_VLAN_VLHT) {
+		value = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+		value |= GMAC_VLAN_VTHM;
+		rte_write32(value, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	}
+}
+
+static void dwmac4_set_filter(struct mac_device_info *hw,
+			      struct stmmac_private *priv)
+{
+	void  *ioaddr  = (void  *)priv->ioaddr_v;
+	int numhashregs = (hw->multicast_filter_bins >> 5);
+	int mcbitslog2 = hw->mcast_bits_log2;
+	uint8_t ha_addr[6] = {0};
+	unsigned int value;
+	uint32_t mc_filter[8];
+	int i;
+
+	ioaddr  = hw->pcsr;
+
+	memset(mc_filter, 0, sizeof(mc_filter));
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+	value &= ~GMAC_PACKET_FILTER_HMC;
+	value &= ~GMAC_PACKET_FILTER_HPF;
+	value &= ~GMAC_PACKET_FILTER_PCF;
+	value &= ~GMAC_PACKET_FILTER_PM;
+	value &= ~GMAC_PACKET_FILTER_PR;
+	value &= ~GMAC_PACKET_FILTER_RA;
+
+	if (priv->flags & IFF_PROMISC) {
+		/* VLAN Tag Filter Fail Packets Queuing */
+		if (hw->vlan_fail_q_en) {
+			value = rte_read32((uint8_t *)ioaddr + GMAC_RXQ_CTRL4);
+			value &= ~GMAC_RXQCTRL_VFFQ_MASK;
+			value |= GMAC_RXQCTRL_VFFQE |
+				 (hw->vlan_fail_q << GMAC_RXQCTRL_VFFQ_SHIFT);
+			rte_write32(value, (uint8_t *)ioaddr + GMAC_RXQ_CTRL4);
+			value = GMAC_PACKET_FILTER_PR | GMAC_PACKET_FILTER_RA;
+		} else {
+			value = GMAC_PACKET_FILTER_PR | GMAC_PACKET_FILTER_PCF;
+		}
+	} else if (priv->flags & IFF_ALLMULTI) {
+		/* Pass all multi */
+		value |= GMAC_PACKET_FILTER_PM;
+		/* Set all the bits of the HASH tab */
+		memset(mc_filter, 0xff, sizeof(mc_filter));
+	} else if (priv->flags & IFF_MULTICAST) {
+		/* Hash filter for multicast */
+		value |= GMAC_PACKET_FILTER_HMC;
+
+		/* Fixed me, get the ha addr */
+		{
+			/* The upper n bits of the calculated CRC are used to
+			 * index the contents of the hash table. The number of
+			 * bits used depends on the hardware configuration
+			 * selected at core configuration time.
+			 */
+			uint32_t bit_nr = bitrev32(~crc32_le(~0, ha_addr,
+					ETH_ALEN)) >> (32 - mcbitslog2);
+			/* The most significant bit determines the register to
+			 * use (H/L) while the other 5 bits determine the bit
+			 * within the register.
+			 */
+			mc_filter[bit_nr >> 5] |= (1 << (bit_nr & 0x1f));
+		}
+	}
+
+	for (i = 0; i < numhashregs; i++)
+		rte_write32(mc_filter[i], (uint8_t *)ioaddr + GMAC_HASH_TAB(i));
+
+	value |= GMAC_PACKET_FILTER_HPF;
+
+	/* Fixed me, Handle multiple unicast addresses */
+	if (priv->uc_count > 128) {
+		/* Switch to promiscuous mode if more than 128 addrs
+		 * are required
+		 */
+		value |= GMAC_PACKET_FILTER_PR;
+	} else {
+		int reg = 1;
+
+		/* Fixed me, get the ha addr */
+		{
+			dwmac4_set_umac_addr(hw, ha_addr, reg);
+			reg++;
+		}
+
+		while (reg < GMAC_MAX_PERFECT_ADDRESSES) {
+			rte_write32(0, (uint8_t *)ioaddr + GMAC_ADDR_HIGH(reg));
+			rte_write32(0, (uint8_t *)ioaddr + GMAC_ADDR_LOW(reg));
+			reg++;
+		}
+	}
+
+	/* Fixed me, VLAN filtering */
+	if (priv->features & STMMAC_HW_VLAN_CTAG_FILTER)
+		value |= GMAC_PACKET_FILTER_VTFE;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+
+	if (priv->flags & IFF_PROMISC && !hw->vlan_fail_q_en) {
+		if (!hw->promisc) {
+			hw->promisc = 1;
+			dwmac4_vlan_promisc_enable(priv, hw);
+		}
+	} else {
+		if (hw->promisc) {
+			hw->promisc = 0;
+			dwmac4_restore_hw_vlan_rx_fltr(priv, hw);
+		}
+	}
+}
+
+static void dwmac4_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,
+			     unsigned int fc, unsigned int pause_time,
+			     uint32_t tx_cnt)
+{
+	void  *ioaddr = hw->pcsr;
+	unsigned int flow = 0;
+	uint32_t queue = 0;
+
+	STMMAC_PMD_INFO("GMAC Flow-Control:\n");
+	if (fc & FLOW_RX) {
+		STMMAC_PMD_INFO("\tReceive Flow-Control ON\n");
+		flow |= GMAC_RX_FLOW_CTRL_RFE;
+	}
+	rte_write32(flow, (uint8_t *)ioaddr + GMAC_RX_FLOW_CTRL);
+
+	if (fc & FLOW_TX) {
+		STMMAC_PMD_INFO("\tTransmit Flow-Control ON\n");
+
+		if (duplex)
+			STMMAC_PMD_INFO("\tduplex mode: PAUSE %d\n", pause_time);
+
+		for (queue = 0; queue < tx_cnt; queue++) {
+			flow = GMAC_TX_FLOW_CTRL_TFE;
+
+			if (duplex)
+				flow |=
+				(pause_time << GMAC_TX_FLOW_CTRL_PT_SHIFT);
+
+			rte_write32(flow, (uint8_t *)ioaddr + GMAC_QX_TX_FLOW_CTRL(queue));
+		}
+	} else {
+		for (queue = 0; queue < tx_cnt; queue++)
+			rte_write32(0, (uint8_t *)ioaddr + GMAC_QX_TX_FLOW_CTRL(queue));
+	}
+}
+
+static int dwmac4_irq_mtl_status(struct mac_device_info *hw, uint32_t chan)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t mtl_int_qx_status;
+	int ret = 0;
+
+	mtl_int_qx_status = rte_read32((uint8_t *)ioaddr + MTL_INT_STATUS);
+
+	/* Check MTL Interrupt */
+	if (mtl_int_qx_status & MTL_INT_QX(chan)) {
+		/* read Queue x Interrupt status */
+		uint32_t status = rte_read32((uint8_t *)ioaddr + MTL_CHAN_INT_CTRL(chan));
+
+		if (status & MTL_RX_OVERFLOW_INT) {
+			/*  clear Interrupt */
+			rte_write32(status | MTL_RX_OVERFLOW_INT,
+			       (uint8_t *)ioaddr + MTL_CHAN_INT_CTRL(chan));
+			ret = CORE_IRQ_MTL_RX_OVERFLOW;
+		}
+	}
+
+	return ret;
+}
+
+static int dwmac4_irq_status(struct mac_device_info *hw,
+			     struct stmmac_extra_stats *x)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t intr_status = rte_read32((uint8_t *)ioaddr + GMAC_INT_STATUS);
+	uint32_t intr_enable = rte_read32((uint8_t *)ioaddr + GMAC_INT_EN);
+	int ret = 0;
+
+	/* Discard disabled bits */
+	intr_status &= intr_enable;
+
+	/* Not used events (e.g. MMC interrupts) are not handled. */
+	if ((intr_status & mmc_tx_irq))
+		x->mmc_tx_irq_n++;
+	if (unlikely(intr_status & mmc_rx_irq))
+		x->mmc_rx_irq_n++;
+	if (unlikely(intr_status & mmc_rx_csum_offload_irq))
+		x->mmc_rx_csum_offload_irq_n++;
+	/* Clear the PMT bits 5 and 6 by reading the PMT status reg */
+	if (unlikely(intr_status & pmt_irq)) {
+		rte_read32((uint8_t *)ioaddr + GMAC_PMT);
+		x->irq_receive_pmt_irq_n++;
+	}
+
+	/* MAC tx/rx EEE LPI entry/exit interrupts */
+	if (intr_status & lpi_irq) {
+		/* Clear LPI interrupt by reading MAC_LPI_Control_Status */
+		uint32_t status = rte_read32((uint8_t *)ioaddr + GMAC4_LPI_CTRL_STATUS);
+
+		if (status & GMAC4_LPI_CTRL_STATUS_TLPIEN) {
+			ret |= CORE_IRQ_TX_PATH_IN_LPI_MODE;
+			x->irq_tx_path_in_lpi_mode_n++;
+		}
+		if (status & GMAC4_LPI_CTRL_STATUS_TLPIEX) {
+			ret |= CORE_IRQ_TX_PATH_EXIT_LPI_MODE;
+			x->irq_tx_path_exit_lpi_mode_n++;
+		}
+		if (status & GMAC4_LPI_CTRL_STATUS_RLPIEN)
+			x->irq_rx_path_in_lpi_mode_n++;
+		if (status & GMAC4_LPI_CTRL_STATUS_RLPIEX)
+			x->irq_rx_path_exit_lpi_mode_n++;
+	}
+
+	return ret;
+}
+
+static void dwmac4_debug(void *ioaddr , struct stmmac_extra_stats *x,
+			 uint32_t rx_queues, uint32_t tx_queues)
+{
+	uint32_t value;
+	uint32_t queue;
+
+	for (queue = 0; queue < tx_queues; queue++) {
+		value = rte_read32((uint8_t *)ioaddr + MTL_CHAN_TX_DEBUG(queue));
+
+		if (value & MTL_DEBUG_TXSTSFSTS)
+			x->mtl_tx_status_fifo_full++;
+		if (value & MTL_DEBUG_TXFSTS)
+			x->mtl_tx_fifo_not_empty++;
+		if (value & MTL_DEBUG_TWCSTS)
+			x->mmtl_fifo_ctrl++;
+		if (value & MTL_DEBUG_TRCSTS_MASK) {
+			uint32_t trcsts = (value & MTL_DEBUG_TRCSTS_MASK)
+				     >> MTL_DEBUG_TRCSTS_SHIFT;
+			if (trcsts == MTL_DEBUG_TRCSTS_WRITE)
+				x->mtl_tx_fifo_read_ctrl_write++;
+			else if (trcsts == MTL_DEBUG_TRCSTS_TXW)
+				x->mtl_tx_fifo_read_ctrl_wait++;
+			else if (trcsts == MTL_DEBUG_TRCSTS_READ)
+				x->mtl_tx_fifo_read_ctrl_read++;
+			else
+				x->mtl_tx_fifo_read_ctrl_idle++;
+		}
+		if (value & MTL_DEBUG_TXPAUSED)
+			x->mac_tx_in_pause++;
+	}
+
+	for (queue = 0; queue < rx_queues; queue++) {
+		value = rte_read32((uint8_t *)ioaddr + MTL_CHAN_RX_DEBUG(queue));
+
+		if (value & MTL_DEBUG_RXFSTS_MASK) {
+			uint32_t rxfsts = (value & MTL_DEBUG_RXFSTS_MASK)
+				     >> MTL_DEBUG_RRCSTS_SHIFT;
+
+			if (rxfsts == MTL_DEBUG_RXFSTS_FULL)
+				x->mtl_rx_fifo_fill_level_full++;
+			else if (rxfsts == MTL_DEBUG_RXFSTS_AT)
+				x->mtl_rx_fifo_fill_above_thresh++;
+			else if (rxfsts == MTL_DEBUG_RXFSTS_BT)
+				x->mtl_rx_fifo_fill_below_thresh++;
+			else
+				x->mtl_rx_fifo_fill_level_empty++;
+		}
+		if (value & MTL_DEBUG_RRCSTS_MASK) {
+			uint32_t rrcsts = (value & MTL_DEBUG_RRCSTS_MASK) >>
+				     MTL_DEBUG_RRCSTS_SHIFT;
+
+			if (rrcsts == MTL_DEBUG_RRCSTS_FLUSH)
+				x->mtl_rx_fifo_read_ctrl_flush++;
+			else if (rrcsts == MTL_DEBUG_RRCSTS_RSTAT)
+				x->mtl_rx_fifo_read_ctrl_read_data++;
+			else if (rrcsts == MTL_DEBUG_RRCSTS_RDATA)
+				x->mtl_rx_fifo_read_ctrl_status++;
+			else
+				x->mtl_rx_fifo_read_ctrl_idle++;
+		}
+		if (value & MTL_DEBUG_RWCSTS)
+			x->mtl_rx_fifo_ctrl_active++;
+	}
+
+	/* GMAC debug */
+	value = rte_read32((uint8_t *)ioaddr + GMAC_DEBUG);
+
+	if (value & GMAC_DEBUG_TFCSTS_MASK) {
+		uint32_t tfcsts = (value & GMAC_DEBUG_TFCSTS_MASK)
+			      >> GMAC_DEBUG_TFCSTS_SHIFT;
+
+		if (tfcsts == GMAC_DEBUG_TFCSTS_XFER)
+			x->mac_tx_frame_ctrl_xfer++;
+		else if (tfcsts == GMAC_DEBUG_TFCSTS_GEN_PAUSE)
+			x->mac_tx_frame_ctrl_pause++;
+		else if (tfcsts == GMAC_DEBUG_TFCSTS_WAIT)
+			x->mac_tx_frame_ctrl_wait++;
+		else
+			x->mac_tx_frame_ctrl_idle++;
+	}
+	if (value & GMAC_DEBUG_TPESTS)
+		x->mac_gmii_tx_proto_engine++;
+	if (value & GMAC_DEBUG_RFCFCSTS_MASK)
+		x->mac_rx_frame_ctrl_fifo = (value & GMAC_DEBUG_RFCFCSTS_MASK)
+					    >> GMAC_DEBUG_RFCFCSTS_SHIFT;
+	if (value & GMAC_DEBUG_RPESTS)
+		x->mac_gmii_rx_proto_engine++;
+}
+
+static void dwmac4_set_mac_loopback(void *ioaddr , bool enable)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	if (enable)
+		value |= GMAC_CONFIG_LM;
+	else
+		value &= ~GMAC_CONFIG_LM;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+static void dwmac4_update_vlan_hash(struct mac_device_info *hw, uint32_t hash,
+				    uint16_t perfect_match, bool is_double)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	rte_write32(hash, (uint8_t *)ioaddr + GMAC_VLAN_HASH_TABLE);
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_TAG);
+
+	if (hash) {
+		value |= GMAC_VLAN_VTHM | GMAC_VLAN_ETV;
+		if (is_double) {
+			value |= GMAC_VLAN_EDVLP;
+			value |= GMAC_VLAN_ESVL;
+			value |= GMAC_VLAN_DOVLTC;
+		}
+
+		rte_write32(value, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	} else if (perfect_match) {
+		uint32_t value = GMAC_VLAN_ETV;
+
+		if (is_double) {
+			value |= GMAC_VLAN_EDVLP;
+			value |= GMAC_VLAN_ESVL;
+			value |= GMAC_VLAN_DOVLTC;
+		}
+
+		rte_write32(value | perfect_match, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	} else {
+		value &= ~(GMAC_VLAN_VTHM | GMAC_VLAN_ETV);
+		value &= ~(GMAC_VLAN_EDVLP | GMAC_VLAN_ESVL);
+		value &= ~GMAC_VLAN_DOVLTC;
+		value &= ~GMAC_VLAN_VID;
+
+		rte_write32(value, (uint8_t *)ioaddr + GMAC_VLAN_TAG);
+	}
+}
+
+static void dwmac4_sarc_configure(void *ioaddr , int val)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	value &= ~GMAC_CONFIG_SARC;
+	value |= val << GMAC_CONFIG_SARC_SHIFT;
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+static void dwmac4_enable_vlan(struct mac_device_info *hw, uint32_t type)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_VLAN_INCL);
+	value |= GMAC_VLAN_VLTI;
+	value |= GMAC_VLAN_CSVL; /* Only use SVLAN */
+	value &= ~GMAC_VLAN_VLC;
+	value |= (type << GMAC_VLAN_VLC_SHIFT) & GMAC_VLAN_VLC;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_VLAN_INCL);
+}
+
+static void dwmac4_set_arp_offload(struct mac_device_info *hw, bool en,
+				   uint32_t addr)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	rte_write32(addr, (uint8_t *)ioaddr + GMAC_ARP_ADDR);
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+	if (en)
+		value |= GMAC_CONFIG_ARPEN;
+	else
+		value &= ~GMAC_CONFIG_ARPEN;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+static int dwmac4_config_l3_filter(struct mac_device_info *hw, uint32_t filter_no,
+				   bool en, bool ipv6, bool sa, bool inv,
+				   uint32_t match)
+{
+	void  *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+	value |= GMAC_PACKET_FILTER_IPFE;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+
+	/* For IPv6 not both SA/DA filters can be active */
+	if (ipv6) {
+		value |= GMAC_L3PEN0;
+		value &= ~(GMAC_L3SAM0 | GMAC_L3SAIM0);
+		value &= ~(GMAC_L3DAM0 | GMAC_L3DAIM0);
+		if (sa) {
+			value |= GMAC_L3SAM0;
+			if (inv)
+				value |= GMAC_L3SAIM0;
+		} else {
+			value |= GMAC_L3DAM0;
+			if (inv)
+				value |= GMAC_L3DAIM0;
+		}
+	} else {
+		value &= ~GMAC_L3PEN0;
+		if (sa) {
+			value |= GMAC_L3SAM0;
+			if (inv)
+				value |= GMAC_L3SAIM0;
+		} else {
+			value |= GMAC_L3DAM0;
+			if (inv)
+				value |= GMAC_L3DAIM0;
+		}
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+
+	if (sa) {
+		rte_write32(match, (uint8_t *)ioaddr + GMAC_L3_ADDR0(filter_no));
+	} else {
+		rte_write32(match, (uint8_t *)ioaddr + GMAC_L3_ADDR1(filter_no));
+	}
+
+	if (!en)
+		rte_write32(0, (uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+
+	return 0;
+}
+
+static int dwmac4_config_l4_filter(struct mac_device_info *hw, uint32_t filter_no,
+				   bool en, bool udp, bool sa, bool inv,
+				   uint32_t match)
+{
+	void *ioaddr = hw->pcsr;
+	uint32_t value;
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+	value |= GMAC_PACKET_FILTER_IPFE;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_PACKET_FILTER);
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+	if (udp) {
+		value |= GMAC_L4PEN0;
+	} else {
+		value &= ~GMAC_L4PEN0;
+	}
+
+	value &= ~(GMAC_L4SPM0 | GMAC_L4SPIM0);
+	value &= ~(GMAC_L4DPM0 | GMAC_L4DPIM0);
+	if (sa) {
+		value |= GMAC_L4SPM0;
+		if (inv)
+			value |= GMAC_L4SPIM0;
+	} else {
+		value |= GMAC_L4DPM0;
+		if (inv)
+			value |= GMAC_L4DPIM0;
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+
+	if (sa) {
+		value = match & GMAC_L4SP0;
+	} else {
+		value = (match << GMAC_L4DP0_SHIFT) & GMAC_L4DP0;
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_L4_ADDR(filter_no));
+
+	if (!en)
+		rte_write32(0, (uint8_t *)ioaddr + GMAC_L3L4_CTRL(filter_no));
+
+	return 0;
+}
+
+const struct stmmac_ops dwmac410_ops = {
+	.core_init = dwmac4_core_init,
+	.set_mac = stmmac_dwmac4_set_mac,
+	.rx_ipc = dwmac4_rx_ipc_enable,
+	.rx_queue_enable = dwmac4_rx_queue_enable,
+	.rx_queue_prio = dwmac4_rx_queue_priority,
+	.tx_queue_prio = dwmac4_tx_queue_priority,
+	.rx_queue_routing = dwmac4_rx_queue_routing,
+	.prog_mtl_rx_algorithms = dwmac4_prog_mtl_rx_algorithms,
+	.prog_mtl_tx_algorithms = dwmac4_prog_mtl_tx_algorithms,
+	.set_mtl_tx_queue_weight = dwmac4_set_mtl_tx_queue_weight,
+	.map_mtl_to_dma = dwmac4_map_mtl_dma,
+	.config_cbs = dwmac4_config_cbs,
+	.dump_regs = dwmac4_dump_regs,
+	.host_irq_status = dwmac4_irq_status,
+	.host_mtl_irq_status = dwmac4_irq_mtl_status,
+	.flow_ctrl = dwmac4_flow_ctrl,
+	.pmt = dwmac4_pmt,
+	.set_umac_addr = dwmac4_set_umac_addr,
+	.get_umac_addr = dwmac4_get_umac_addr,
+	.set_eee_mode = dwmac4_set_eee_mode,
+	.reset_eee_mode = dwmac4_reset_eee_mode,
+	.set_eee_timer = dwmac4_set_eee_timer,
+	.set_eee_pls = dwmac4_set_eee_pls,
+	.debug = dwmac4_debug,
+	.set_filter = dwmac4_set_filter,
+	.set_mac_loopback = dwmac4_set_mac_loopback,
+	.update_vlan_hash = dwmac4_update_vlan_hash,
+	.sarc_configure = dwmac4_sarc_configure,
+	.enable_vlan = dwmac4_enable_vlan,
+	.set_arp_offload = dwmac4_set_arp_offload,
+	.config_l3_filter = dwmac4_config_l3_filter,
+	.config_l4_filter = dwmac4_config_l4_filter,
+	.add_hw_vlan_rx_fltr = dwmac4_add_hw_vlan_rx_fltr,
+	.del_hw_vlan_rx_fltr = dwmac4_del_hw_vlan_rx_fltr,
+	.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,
+};
+
+const struct stmmac_ops dwmac510_ops = {
+	.core_init = dwmac4_core_init,
+	.set_mac = stmmac_dwmac4_set_mac,
+	.rx_ipc = dwmac4_rx_ipc_enable,
+	.rx_queue_enable = dwmac4_rx_queue_enable,
+	.rx_queue_prio = dwmac4_rx_queue_priority,
+	.tx_queue_prio = dwmac4_tx_queue_priority,
+	.rx_queue_routing = dwmac4_rx_queue_routing,
+	.prog_mtl_rx_algorithms = dwmac4_prog_mtl_rx_algorithms,
+	.prog_mtl_tx_algorithms = dwmac4_prog_mtl_tx_algorithms,
+	.set_mtl_tx_queue_weight = dwmac4_set_mtl_tx_queue_weight,
+	.map_mtl_to_dma = dwmac4_map_mtl_dma,
+	.config_cbs = dwmac4_config_cbs,
+	.dump_regs = dwmac4_dump_regs,
+	.host_irq_status = dwmac4_irq_status,
+	.host_mtl_irq_status = dwmac4_irq_mtl_status,
+	.flow_ctrl = dwmac4_flow_ctrl,
+	.pmt = dwmac4_pmt,
+	.set_umac_addr = dwmac4_set_umac_addr,
+	.get_umac_addr = dwmac4_get_umac_addr,
+	.set_eee_mode = dwmac4_set_eee_mode,
+	.reset_eee_mode = dwmac4_reset_eee_mode,
+	.set_eee_timer = dwmac4_set_eee_timer,
+	.set_eee_pls = dwmac4_set_eee_pls,
+	.debug = dwmac4_debug,
+	.set_filter = dwmac4_set_filter,
+	.set_mac_loopback = dwmac4_set_mac_loopback,
+	.update_vlan_hash = dwmac4_update_vlan_hash,
+	.sarc_configure = dwmac4_sarc_configure,
+	.enable_vlan = dwmac4_enable_vlan,
+	.set_arp_offload = dwmac4_set_arp_offload,
+	.config_l3_filter = dwmac4_config_l3_filter,
+	.config_l4_filter = dwmac4_config_l4_filter,
+	.add_hw_vlan_rx_fltr = dwmac4_add_hw_vlan_rx_fltr,
+	.del_hw_vlan_rx_fltr = dwmac4_del_hw_vlan_rx_fltr,
+	.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,
+};
+
+static uint32_t dwmac4_get_num_vlan(void *ioaddr )
+{
+	uint32_t val, num_vlan;
+
+	val = rte_read32((uint8_t *)ioaddr + GMAC_HW_FEATURE3);
+	switch (val & GMAC_HW_FEAT_NRVF) {
+	case 0:
+		num_vlan = 1;
+		break;
+	case 1:
+		num_vlan = 4;
+		break;
+	case 2:
+		num_vlan = 8;
+		break;
+	case 3:
+		num_vlan = 16;
+		break;
+	case 4:
+		num_vlan = 24;
+		break;
+	case 5:
+		num_vlan = 32;
+		break;
+	default:
+		num_vlan = 1;
+	}
+
+	return num_vlan;
+}
+
+int dwmac4_setup(struct stmmac_private *priv)
+{
+	struct mac_device_info *mac = priv->hw;
+
+	STMMAC_PMD_INFO("\tDWMAC4/5\n");
+
+	STMMAC_PMD_ERR("\tDWMAC4/5\n");
+
+	//priv->dev->priv_flags |= IFF_UNICAST_FLT;
+	mac->pcsr = priv->ioaddr_v;
+	//mac->multicast_filter_bins = priv->plat->multicast_filter_bins;
+	//mac->unicast_filter_entries = priv->plat->unicast_filter_entries;
+	//mac->mcast_bits_log2 = 0;
+
+	//if (mac->multicast_filter_bins)
+	//	mac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);
+
+	//mac->link.duplex = GMAC_CONFIG_DM;
+	//mac->link.speed10 = GMAC_CONFIG_PS;
+	//mac->link.speed100 = GMAC_CONFIG_FES | GMAC_CONFIG_PS;
+	//mac->link.speed1000 = 0;
+	//mac->link.speed_mask = GMAC_CONFIG_FES | GMAC_CONFIG_PS;
+	//mac->mii.addr = GMAC_MDIO_ADDR;
+	//mac->mii.data = GMAC_MDIO_DATA;
+	//mac->mii.addr_shift = 21;
+	//mac->mii.addr_mask = GENMASK(25, 21);
+	//mac->mii.reg_shift = 16;
+	//mac->mii.reg_mask = GENMASK(20, 16);
+	//mac->mii.clk_csr_shift = 8;
+	//mac->mii.clk_csr_mask = GENMASK(11, 8);
+	mac->num_vlan = dwmac4_get_num_vlan(priv->ioaddr_v);
+
+	return 0;
+}
diff --git a/drivers/net/stmmac/dwmac4_descs.c b/drivers/net/stmmac/dwmac4_descs.c
new file mode 100644
index 0000000..e2b802c
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_descs.c
@@ -0,0 +1,481 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include "common.h"
+#include "dwmac4_descs.h"
+
+#define wsb()		{asm volatile("dsb sy");}
+
+static int dwmac4_wrback_get_tx_status(struct rte_eth_stats *x,
+				       struct dma_desc *p)
+{
+	unsigned int tdes3;
+	int ret = tx_done;
+
+	tdes3 = rte_le_to_cpu_32(p->des3);
+
+	/* Get tx owner first */
+	if (unlikely(tdes3 & TDES3_OWN))
+		return tx_dma_own;
+
+	/* Verify tx error by looking at the last segment. */
+	if (likely(!(tdes3 & TDES3_LAST_DESCRIPTOR)))
+		return tx_not_ls;
+
+	if (unlikely(tdes3 & TDES3_ERROR_SUMMARY))
+		ret = tx_err;
+
+	if (unlikely(tdes3 & TDES3_DEFERRED))
+		ret = tx_err;
+
+	if (ret == tx_err)
+		x->ierrors++;
+
+	return ret;
+}
+
+static int dwmac4_wrback_get_rx_status(struct rte_eth_stats *x,
+				       struct dma_desc *p)
+{
+	unsigned int rdes2 = rte_le_to_cpu_32(p->des2);
+	unsigned int rdes3 = rte_le_to_cpu_32(p->des3);
+	int ret = good_frame;
+
+	if (unlikely(rdes3 & RDES3_OWN))
+		return dma_own;
+
+	if (unlikely(rdes3 & RDES3_CONTEXT_DESCRIPTOR))
+		return discard_frame;
+	if (likely(!(rdes3 & RDES3_LAST_DESCRIPTOR)))
+		return rx_not_ls;
+
+	if (unlikely(rdes3 & RDES3_ERROR_SUMMARY))
+		ret = discard_frame;
+
+	if (unlikely(rdes2 & RDES2_SA_FILTER_FAIL))
+		ret = discard_frame;
+	if (unlikely(rdes2 & RDES2_DA_FILTER_FAIL))
+		ret = discard_frame;
+
+	if (ret == discard_frame)
+		x->oerrors++;
+
+	return ret;
+}
+
+static int dwmac4_rd_get_tx_len(struct dma_desc *p)
+{
+	return (rte_le_to_cpu_32(p->des2) & TDES2_BUFFER1_SIZE_MASK);
+}
+
+static int dwmac4_get_tx_owner(struct dma_desc *p)
+{
+	return (rte_le_to_cpu_32(p->des3) & TDES3_OWN) >> TDES3_OWN_SHIFT;
+}
+
+static void dwmac4_set_tx_owner(struct dma_desc *p)
+{
+	p->des3 |= rte_cpu_to_le_32(TDES3_OWN);
+}
+
+static void dwmac4_set_rx_owner(struct dma_desc *p, int disable_rx_ic)
+{
+	p->des3 |= rte_cpu_to_le_32(RDES3_OWN | RDES3_BUFFER1_VALID_ADDR);
+
+	if (!disable_rx_ic)
+		p->des3 |= rte_cpu_to_le_32(RDES3_INT_ON_COMPLETION_EN);
+}
+
+static int dwmac4_get_tx_ls(struct dma_desc *p)
+{
+	return (rte_le_to_cpu_32(p->des3) & TDES3_LAST_DESCRIPTOR)
+		>> TDES3_LAST_DESCRIPTOR_SHIFT;
+}
+
+static int dwmac4_wrback_get_rx_frame_len(struct dma_desc *p, int rx_coe)
+{
+	return (rte_le_to_cpu_32(p->des3) & RDES3_PACKET_SIZE_MASK);
+}
+
+static void dwmac4_rd_enable_tx_timestamp(struct dma_desc *p)
+{
+	p->des2 |= rte_cpu_to_le_32(TDES2_TIMESTAMP_ENABLE);
+}
+
+static int dwmac4_wrback_get_tx_timestamp_status(struct dma_desc *p)
+{
+	/* Context type from W/B descriptor must be zero */
+	if (rte_le_to_cpu_32(p->des3) & TDES3_CONTEXT_TYPE)
+		return 0;
+
+	/* Tx Timestamp Status is 1 so des0 and des1'll have valid values */
+	if (rte_le_to_cpu_32(p->des3) & TDES3_TIMESTAMP_STATUS)
+		return 1;
+
+	return 0;
+}
+
+static inline void dwmac4_get_timestamp(void *desc, uint32_t ats, uint64_t *ts)
+{
+	struct dma_desc *p = (struct dma_desc *)desc;
+	uint64_t ns;
+
+	ns = rte_le_to_cpu_32(p->des0);
+	/* convert high/sec time stamp value to nanosecond */
+	ns += rte_le_to_cpu_32(p->des1) * 1000000000ULL;
+
+	*ts = ns;
+}
+
+static int dwmac4_rx_check_timestamp(void *desc)
+{
+	struct dma_desc *p = (struct dma_desc *)desc;
+	unsigned int rdes0 = rte_le_to_cpu_32(p->des0);
+	unsigned int rdes1 = rte_le_to_cpu_32(p->des1);
+	unsigned int rdes3 = rte_le_to_cpu_32(p->des3);
+	uint32_t own, ctxt;
+	int ret = 1;
+
+	own = rdes3 & RDES3_OWN;
+	ctxt = ((rdes3 & RDES3_CONTEXT_DESCRIPTOR)
+		>> RDES3_CONTEXT_DESCRIPTOR_SHIFT);
+
+	if (likely(!own && ctxt)) {
+		if ((rdes0 == 0xffffffff) && (rdes1 == 0xffffffff))
+			/* Corrupted value */
+			ret = -EINVAL;
+		else
+			/* A valid Timestamp is ready to be read */
+			ret = 0;
+	}
+
+	/* Timestamp not ready */
+	return ret;
+}
+
+static int dwmac4_wrback_get_rx_timestamp_status(void *desc, void *next_desc,
+						 uint32_t ats)
+{
+	struct dma_desc *p = (struct dma_desc *)desc;
+	int ret = -EINVAL;
+
+	/* Get the status from normal w/b descriptor */
+	if (likely(rte_le_to_cpu_32(p->des3) & RDES3_RDES1_VALID)) {
+		if (likely(rte_le_to_cpu_32(p->des1) & RDES1_TIMESTAMP_AVAILABLE)) {
+			int i = 0;
+
+			/* Check if timestamp is OK from context descriptor */
+			do {
+				ret = dwmac4_rx_check_timestamp(next_desc);
+				if (ret < 0)
+					goto exit;
+				i++;
+
+			} while ((ret == 1) && (i < 10));
+
+			if (i == 10)
+				ret = -EBUSY;
+		}
+	}
+exit:
+	if (likely(ret == 0))
+		return 1;
+
+	return 0;
+}
+
+static void dwmac4_rd_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
+				   int mode, int end, int bfsize)
+{
+	dwmac4_set_rx_owner(p, disable_rx_ic);
+}
+
+static void dwmac4_rd_init_tx_desc(struct dma_desc *p, int mode, int end)
+{
+	p->des0 = 0;
+	p->des1 = 0;
+	p->des2 = 0;
+	p->des3 = 0;
+	mode = 0;
+}
+
+static void dwmac4_rd_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
+				      bool csum_flag, int mode, bool tx_own,
+				      bool ls, unsigned int tot_pkt_len)
+{
+	unsigned int tdes3 = rte_le_to_cpu_32(p->des3);
+
+	p->des2 |= rte_le_to_cpu_32(len & TDES2_BUFFER1_SIZE_MASK);
+
+	tdes3 |= tot_pkt_len & TDES3_PACKET_SIZE_MASK;
+	if (is_fs)
+		tdes3 |= TDES3_FIRST_DESCRIPTOR;
+	else
+		tdes3 &= ~TDES3_FIRST_DESCRIPTOR;
+
+	if (likely(csum_flag))
+		tdes3 |= (TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);
+	else
+		tdes3 &= ~(TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);
+
+	if (ls)
+		tdes3 |= TDES3_LAST_DESCRIPTOR;
+	else
+		tdes3 &= ~TDES3_LAST_DESCRIPTOR;
+
+	/* Finally set the OWN bit. Later the DMA will start! */
+	if (tx_own)
+		tdes3 |= TDES3_OWN;
+
+	if (is_fs && tx_own)
+		/* When the own bit, for the first frame, has to be set, all
+		 * descriptors for the same frame has to be set before, to
+		 * avoid race condition.
+		 */
+		rte_wmb();
+
+	p->des3 = rte_le_to_cpu_32(tdes3);
+}
+
+static void dwmac4_rd_prepare_tso_tx_desc(struct dma_desc *p, int is_fs,
+					  int len1, int len2, bool tx_own,
+					  bool ls, unsigned int tcphdrlen,
+					  unsigned int tcppayloadlen)
+{
+	unsigned int tdes3 = rte_le_to_cpu_32(p->des3);
+
+	if (len1)
+		p->des2 |= rte_cpu_to_le_32((len1 & TDES2_BUFFER1_SIZE_MASK));
+
+	if (len2)
+		p->des2 |= rte_cpu_to_le_32((len2 << TDES2_BUFFER2_SIZE_MASK_SHIFT)
+			    & TDES2_BUFFER2_SIZE_MASK);
+
+	if (is_fs) {
+		tdes3 |= TDES3_FIRST_DESCRIPTOR |
+			 TDES3_TCP_SEGMENTATION_ENABLE |
+			 ((tcphdrlen << TDES3_HDR_LEN_SHIFT) &
+			  TDES3_SLOT_NUMBER_MASK) |
+			 ((tcppayloadlen & TDES3_TCP_PKT_PAYLOAD_MASK));
+	} else {
+		tdes3 &= ~TDES3_FIRST_DESCRIPTOR;
+	}
+
+	if (ls)
+		tdes3 |= TDES3_LAST_DESCRIPTOR;
+	else
+		tdes3 &= ~TDES3_LAST_DESCRIPTOR;
+
+	/* Finally set the OWN bit. Later the DMA will start! */
+	if (tx_own)
+		tdes3 |= TDES3_OWN;
+
+	if (is_fs && tx_own)
+		/* When the own bit, for the first frame, has to be set, all
+		 * descriptors for the same frame has to be set before, to
+		 * avoid race condition.
+		 */
+		wsb();//rte_wmb();
+
+	p->des3 = rte_cpu_to_le_32(tdes3);
+}
+
+static void dwmac4_release_tx_desc(struct dma_desc *p, int mode)
+{
+	p->des0 = 0;
+	p->des1 = 0;
+	p->des2 = 0;
+	p->des3 = 0;
+}
+
+static void dwmac4_rd_set_tx_ic(struct dma_desc *p)
+{
+	p->des2 |= rte_cpu_to_le_32(TDES2_INTERRUPT_ON_COMPLETION);
+}
+
+static void dwmac4_display_ring(void *head, unsigned int size, bool rx,
+				dma_addr_t dma_rx_phy, unsigned int desc_size)
+{
+	dma_addr_t dma_addr;
+	unsigned int i;
+
+	STMMAC_PMD_INFO("%s descriptor ring:\n", rx ? "RX" : "TX");
+
+	if (desc_size == sizeof(struct dma_desc)) {
+		struct dma_desc *p = (struct dma_desc *)head;
+
+		for (i = 0; i < size; i++) {
+			dma_addr = dma_rx_phy + i * sizeof(*p);
+			STMMAC_PMD_INFO("%03d [%pad]: 0x%x 0x%x 0x%x 0x%x\n",
+				i, &dma_addr,
+				rte_le_to_cpu_32(p->des0), rte_le_to_cpu_32(p->des1),
+				rte_le_to_cpu_32(p->des2), rte_le_to_cpu_32(p->des3));
+			p++;
+		}
+	} else if (desc_size == sizeof(struct dma_extended_desc)) {
+		struct dma_extended_desc *extp = (struct dma_extended_desc *)head;
+
+		for (i = 0; i < size; i++) {
+			dma_addr = dma_rx_phy + i * sizeof(*extp);
+			STMMAC_PMD_INFO("%03d [%pad]: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+				i, &dma_addr,
+				rte_le_to_cpu_32(extp->basic.des0), rte_le_to_cpu_32(extp->basic.des1),
+				rte_le_to_cpu_32(extp->basic.des2), rte_le_to_cpu_32(extp->basic.des3),
+				rte_le_to_cpu_32(extp->des4), rte_le_to_cpu_32(extp->des5),
+				rte_le_to_cpu_32(extp->des6), rte_le_to_cpu_32(extp->des7));
+			extp++;
+		}
+	} else if (desc_size == sizeof(struct dma_edesc)) {
+		struct dma_edesc *ep = (struct dma_edesc *)head;
+
+		for (i = 0; i < size; i++) {
+			dma_addr = dma_rx_phy + i * sizeof(*ep);
+			STMMAC_PMD_INFO("%03d [%pad]: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+				i, &dma_addr,
+				rte_le_to_cpu_32(ep->des4), rte_le_to_cpu_32(ep->des5),
+				rte_le_to_cpu_32(ep->des6), rte_le_to_cpu_32(ep->des7),
+				rte_le_to_cpu_32(ep->basic.des0), rte_le_to_cpu_32(ep->basic.des1),
+				rte_le_to_cpu_32(ep->basic.des2), rte_le_to_cpu_32(ep->basic.des3));
+			ep++;
+		}
+	} else {
+		STMMAC_PMD_ERR("unsupported descriptor!");
+	}
+}
+
+static void dwmac4_set_mss_ctxt(struct dma_desc *p, unsigned int mss)
+{
+	p->des0 = 0;
+	p->des1 = 0;
+	p->des2 = rte_cpu_to_le_32(mss);
+	p->des3 = rte_cpu_to_le_32(TDES3_CONTEXT_TYPE | TDES3_CTXT_TCMSSV);
+}
+
+static void dwmac4_get_addr(struct dma_desc *p, unsigned int *addr)
+{
+	*addr = rte_le_to_cpu_32(p->des0);
+}
+
+static void dwmac4_set_addr(struct dma_desc *p, dma_addr_t addr)
+{
+	p->des0 = rte_cpu_to_le_32(lower_32_bits(addr));
+	p->des1 = rte_cpu_to_le_32(upper_32_bits(addr));
+}
+
+static void dwmac4_clear(struct dma_desc *p)
+{
+	p->des0 = 0;
+	p->des1 = 0;
+	p->des2 = 0;
+	p->des3 = 0;
+}
+
+static void dwmac4_set_sarc(struct dma_desc *p, uint32_t sarc_type)
+{
+	sarc_type <<= TDES3_SA_INSERT_CTRL_SHIFT;
+
+	p->des3 |= rte_cpu_to_le_32(sarc_type & TDES3_SA_INSERT_CTRL_MASK);
+}
+
+static int set_16kib_bfsize(int mtu)
+{
+	int ret = 0;
+
+	if (unlikely(mtu >= BUF_SIZE_8KiB))
+		ret = BUF_SIZE_16KiB;
+	return ret;
+}
+
+static void dwmac4_set_vlan_tag(struct dma_desc *p, uint16_t tag, uint16_t inner_tag,
+				uint32_t inner_type)
+{
+	p->des0 = 0;
+	p->des1 = 0;
+	p->des2 = 0;
+	p->des3 = 0;
+
+	/* Inner VLAN */
+	if (inner_type) {
+		uint32_t des = inner_tag << TDES2_IVT_SHIFT;
+
+		des &= TDES2_IVT_MASK;
+		p->des2 = rte_cpu_to_le_32(des);
+
+		des = inner_type << TDES3_IVTIR_SHIFT;
+		des &= TDES3_IVTIR_MASK;
+		p->des3 = rte_cpu_to_le_32(des | TDES3_IVLTV);
+	}
+
+	/* Outer VLAN */
+	p->des3 |= rte_cpu_to_le_32(tag & TDES3_VLAN_TAG);
+	p->des3 |= rte_cpu_to_le_32(TDES3_VLTV);
+
+	p->des3 |= rte_cpu_to_le_32(TDES3_CONTEXT_TYPE);
+}
+
+static void dwmac4_set_vlan(struct dma_desc *p, uint32_t type)
+{
+	type <<= TDES2_VLAN_TAG_SHIFT;
+	p->des2 |= rte_cpu_to_le_32(type & TDES2_VLAN_TAG_MASK);
+}
+
+static void dwmac4_get_rx_header_len(struct dma_desc *p, unsigned int *len)
+{
+	*len = rte_le_to_cpu_32(p->des2) & RDES2_HL;
+}
+
+static void dwmac4_set_sec_addr(struct dma_desc *p, dma_addr_t addr, bool buf2_valid)
+{
+	p->des2 = rte_cpu_to_le_32(lower_32_bits(addr));
+	p->des3 = rte_cpu_to_le_32(upper_32_bits(addr));
+
+	if (buf2_valid)
+		p->des3 |= rte_cpu_to_le_32(RDES3_BUFFER2_VALID_ADDR);
+	else
+		p->des3 &= rte_cpu_to_le_32(~RDES3_BUFFER2_VALID_ADDR);
+}
+
+static void dwmac4_set_tbs(struct dma_edesc *p, uint32_t sec, uint32_t nsec)
+{
+	p->des4 = rte_cpu_to_le_32((sec & TDES4_LT) | TDES4_LTV);
+	p->des5 = rte_cpu_to_le_32(nsec & TDES5_LT);
+	p->des6 = 0;
+	p->des7 = 0;
+}
+
+const struct stmmac_desc_ops dwmac4_desc_ops = {
+	.tx_status = dwmac4_wrback_get_tx_status,
+	.rx_status = dwmac4_wrback_get_rx_status,
+	.get_tx_len = dwmac4_rd_get_tx_len,
+	.get_tx_owner = dwmac4_get_tx_owner,
+	.set_tx_owner = dwmac4_set_tx_owner,
+	.set_rx_owner = dwmac4_set_rx_owner,
+	.get_tx_ls = dwmac4_get_tx_ls,
+	.get_rx_frame_len = dwmac4_wrback_get_rx_frame_len,
+	.enable_tx_timestamp = dwmac4_rd_enable_tx_timestamp,
+	.get_tx_timestamp_status = dwmac4_wrback_get_tx_timestamp_status,
+	.get_rx_timestamp_status = dwmac4_wrback_get_rx_timestamp_status,
+	.get_timestamp = dwmac4_get_timestamp,
+	.set_tx_ic = dwmac4_rd_set_tx_ic,
+	.prepare_tx_desc = dwmac4_rd_prepare_tx_desc,
+	.prepare_tso_tx_desc = dwmac4_rd_prepare_tso_tx_desc,
+	.release_tx_desc = dwmac4_release_tx_desc,
+	.init_rx_desc = dwmac4_rd_init_rx_desc,
+	.init_tx_desc = dwmac4_rd_init_tx_desc,
+	.display_ring = dwmac4_display_ring,
+	.set_mss = dwmac4_set_mss_ctxt,
+	.get_addr = dwmac4_get_addr,
+	.set_addr = dwmac4_set_addr,
+	.clear = dwmac4_clear,
+	.set_sarc = dwmac4_set_sarc,
+	.set_vlan_tag = dwmac4_set_vlan_tag,
+	.set_vlan = dwmac4_set_vlan,
+	.get_rx_header_len = dwmac4_get_rx_header_len,
+	.set_sec_addr = dwmac4_set_sec_addr,
+	.set_tbs = dwmac4_set_tbs,
+};
+
+const struct stmmac_mode_ops dwmac4_ring_mode_ops = {
+	.set_16kib_bfsize = set_16kib_bfsize,
+};
diff --git a/drivers/net/stmmac/dwmac4_descs.h b/drivers/net/stmmac/dwmac4_descs.h
new file mode 100644
index 0000000..ffcd28f
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_descs.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __DWMAC4_DESCS_H__
+#define __DWMAC4_DESCS_H__
+
+#include "descs.h"
+
+/* Normal transmit descriptor defines (without split feature) */
+
+/* TDES2 (read format) */
+#define TDES2_BUFFER1_SIZE_MASK		GENMASK(13, 0)
+#define TDES2_VLAN_TAG_MASK		GENMASK(15, 14)
+#define TDES2_VLAN_TAG_SHIFT		14
+#define TDES2_BUFFER2_SIZE_MASK		GENMASK(29, 16)
+#define TDES2_BUFFER2_SIZE_MASK_SHIFT	16
+#define TDES3_IVTIR_MASK		GENMASK(19, 18)
+#define TDES3_IVTIR_SHIFT		18
+#define TDES3_IVLTV			BIT(17)
+#define TDES2_TIMESTAMP_ENABLE		BIT(30)
+#define TDES2_IVT_MASK			GENMASK(31, 16)
+#define TDES2_IVT_SHIFT			16
+#define TDES2_INTERRUPT_ON_COMPLETION	BIT(31)
+
+/* TDES3 (read format) */
+#define TDES3_PACKET_SIZE_MASK		GENMASK(14, 0)
+#define TDES3_VLAN_TAG			GENMASK(15, 0)
+#define TDES3_VLTV			BIT(16)
+#define TDES3_CHECKSUM_INSERTION_MASK	GENMASK(17, 16)
+#define TDES3_CHECKSUM_INSERTION_SHIFT	16
+#define TDES3_TCP_PKT_PAYLOAD_MASK	GENMASK(17, 0)
+#define TDES3_TCP_SEGMENTATION_ENABLE	BIT(18)
+#define TDES3_HDR_LEN_SHIFT		19
+#define TDES3_SLOT_NUMBER_MASK		GENMASK(22, 19)
+#define TDES3_SA_INSERT_CTRL_MASK	GENMASK(25, 23)
+#define TDES3_SA_INSERT_CTRL_SHIFT	23
+#define TDES3_CRC_PAD_CTRL_MASK		GENMASK(27, 26)
+
+/* TDES3 (write back format) */
+#define TDES3_IP_HDR_ERROR		BIT(0)
+#define TDES3_DEFERRED			BIT(1)
+#define TDES3_UNDERFLOW_ERROR		BIT(2)
+#define TDES3_EXCESSIVE_DEFERRAL	BIT(3)
+#define TDES3_COLLISION_COUNT_MASK	GENMASK(7, 4)
+#define TDES3_COLLISION_COUNT_SHIFT	4
+#define TDES3_EXCESSIVE_COLLISION	BIT(8)
+#define TDES3_LATE_COLLISION		BIT(9)
+#define TDES3_NO_CARRIER		BIT(10)
+#define TDES3_LOSS_CARRIER		BIT(11)
+#define TDES3_PAYLOAD_ERROR		BIT(12)
+#define TDES3_PACKET_FLUSHED		BIT(13)
+#define TDES3_JABBER_TIMEOUT		BIT(14)
+#define TDES3_ERROR_SUMMARY		BIT(15)
+#define TDES3_TIMESTAMP_STATUS		BIT(17)
+#define TDES3_TIMESTAMP_STATUS_SHIFT	17
+
+/* TDES3 context */
+#define TDES3_CTXT_TCMSSV		BIT(26)
+
+/* TDES3 Common */
+#define	TDES3_RS1V			BIT(26)
+#define	TDES3_RS1V_SHIFT		26
+#define TDES3_LAST_DESCRIPTOR		BIT(28)
+#define TDES3_LAST_DESCRIPTOR_SHIFT	28
+#define TDES3_FIRST_DESCRIPTOR		BIT(29)
+#define TDES3_CONTEXT_TYPE		BIT(30)
+#define	TDES3_CONTEXT_TYPE_SHIFT	30
+
+/* TDES4 */
+#define TDES4_LTV			BIT(31)
+#define TDES4_LT			GENMASK(7, 0)
+
+/* TDES5 */
+#define TDES5_LT			GENMASK(31, 8)
+
+/* TDS3 use for both format (read and write back) */
+#define TDES3_OWN			BIT(31)
+#define TDES3_OWN_SHIFT			31
+
+/* Normal receive descriptor defines (without split feature) */
+
+/* RDES0 (write back format) */
+#define RDES0_VLAN_TAG_MASK		GENMASK(15, 0)
+
+/* RDES1 (write back format) */
+#define RDES1_IP_PAYLOAD_TYPE_MASK	GENMASK(2, 0)
+#define RDES1_IP_HDR_ERROR		BIT(3)
+#define RDES1_IPV4_HEADER		BIT(4)
+#define RDES1_IPV6_HEADER		BIT(5)
+#define RDES1_IP_CSUM_BYPASSED		BIT(6)
+#define RDES1_IP_CSUM_ERROR		BIT(7)
+#define RDES1_PTP_MSG_TYPE_MASK		GENMASK(11, 8)
+#define RDES1_PTP_PACKET_TYPE		BIT(12)
+#define RDES1_PTP_VER			BIT(13)
+#define RDES1_TIMESTAMP_AVAILABLE	BIT(14)
+#define RDES1_TIMESTAMP_AVAILABLE_SHIFT	14
+#define RDES1_TIMESTAMP_DROPPED		BIT(15)
+#define RDES1_IP_TYPE1_CSUM_MASK	GENMASK(31, 16)
+
+/* RDES2 (write back format) */
+#define RDES2_L3_L4_HEADER_SIZE_MASK	GENMASK(9, 0)
+#define RDES2_VLAN_FILTER_STATUS	BIT(15)
+#define RDES2_SA_FILTER_FAIL		BIT(16)
+#define RDES2_DA_FILTER_FAIL		BIT(17)
+#define RDES2_HASH_FILTER_STATUS	BIT(18)
+#define RDES2_MAC_ADDR_MATCH_MASK	GENMASK(26, 19)
+#define RDES2_HASH_VALUE_MATCH_MASK	GENMASK(26, 19)
+#define RDES2_L3_FILTER_MATCH		BIT(27)
+#define RDES2_L4_FILTER_MATCH		BIT(28)
+#define RDES2_L3_L4_FILT_NB_MATCH_MASK	GENMASK(27, 26)
+#define RDES2_L3_L4_FILT_NB_MATCH_SHIFT	26
+#define RDES2_HL			GENMASK(9, 0)
+
+/* RDES3 (write back format) */
+#define RDES3_PACKET_SIZE_MASK		GENMASK(14, 0)
+#define RDES3_ERROR_SUMMARY		BIT(15)
+#define RDES3_PACKET_LEN_TYPE_MASK	GENMASK(18, 16)
+#define RDES3_DRIBBLE_ERROR		BIT(19)
+#define RDES3_RECEIVE_ERROR		BIT(20)
+#define RDES3_OVERFLOW_ERROR		BIT(21)
+#define RDES3_RECEIVE_WATCHDOG		BIT(22)
+#define RDES3_GIANT_PACKET		BIT(23)
+#define RDES3_CRC_ERROR			BIT(24)
+#define RDES3_RDES0_VALID		BIT(25)
+#define RDES3_RDES1_VALID		BIT(26)
+#define RDES3_RDES2_VALID		BIT(27)
+#define RDES3_LAST_DESCRIPTOR		BIT(28)
+#define RDES3_FIRST_DESCRIPTOR		BIT(29)
+#define RDES3_CONTEXT_DESCRIPTOR	BIT(30)
+#define RDES3_CONTEXT_DESCRIPTOR_SHIFT	30
+
+/* RDES3 (read format) */
+#define RDES3_BUFFER1_VALID_ADDR	BIT(24)
+#define RDES3_BUFFER2_VALID_ADDR	BIT(25)
+#define RDES3_INT_ON_COMPLETION_EN	BIT(30)
+
+/* TDS3 use for both format (read and write back) */
+#define RDES3_OWN			BIT(31)
+
+#endif /* __DWMAC4_DESCS_H__ */
diff --git a/drivers/net/stmmac/dwmac4_dma.c b/drivers/net/stmmac/dwmac4_dma.c
new file mode 100644
index 0000000..d59d8a1
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_dma.c
@@ -0,0 +1,554 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include "dwmac4.h"
+#include "dwmac4_dma.h"
+
+static void dwmac4_dma_axi(void  *ioaddr, struct stmmac_axi *axi)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_SYS_BUS_MODE);
+	int i;
+
+	STMMAC_PMD_INFO("dwmac4: Master AXI performs %s burst length\n",
+		(value & DMA_SYS_BUS_FB) ? "fixed" : "any");
+
+	if (axi->axi_lpi_en)
+		value |= DMA_AXI_EN_LPI;
+	if (axi->axi_xit_frm)
+		value |= DMA_AXI_LPI_XIT_FRM;
+
+	value &= ~DMA_AXI_WR_OSR_LMT;
+	value |= (axi->axi_wr_osr_lmt & DMA_AXI_OSR_MAX) <<
+		 DMA_AXI_WR_OSR_LMT_SHIFT;
+
+	value &= ~DMA_AXI_RD_OSR_LMT;
+	value |= (axi->axi_rd_osr_lmt & DMA_AXI_OSR_MAX) <<
+		 DMA_AXI_RD_OSR_LMT_SHIFT;
+
+	/* Depending on the UNDEF bit the Master AXI will perform any burst
+	 * length according to the BLEN programmed (by default all BLEN are
+	 * set).
+	 */
+	for (i = 0; i < AXI_BLEN; i++) {
+		switch (axi->axi_blen[i]) {
+		case 256:
+			value |= DMA_AXI_BLEN256;
+			break;
+		case 128:
+			value |= DMA_AXI_BLEN128;
+			break;
+		case 64:
+			value |= DMA_AXI_BLEN64;
+			break;
+		case 32:
+			value |= DMA_AXI_BLEN32;
+			break;
+		case 16:
+			value |= DMA_AXI_BLEN16;
+			break;
+		case 8:
+			value |= DMA_AXI_BLEN8;
+			break;
+		case 4:
+			value |= DMA_AXI_BLEN4;
+			break;
+		}
+	}
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_SYS_BUS_MODE);
+}
+
+static void dwmac4_dma_init_rx_chan(void  *ioaddr,
+				    struct stmmac_dma_cfg *dma_cfg,
+				    dma_addr_t dma_rx_phy, uint32_t chan)
+{
+	uint32_t value;
+	uint32_t rxpbl = dma_cfg->rxpbl ?: dma_cfg->pbl;
+
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+	value = value | (rxpbl << DMA_BUS_MODE_RPBL_SHIFT);
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+
+	//if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) && likely(dma_cfg->eame))
+		rte_write32(upper_32_bits(dma_rx_phy),
+		       (uint8_t *)ioaddr + DMA_CHAN_RX_BASE_ADDR_HI(chan));
+
+	rte_write32(lower_32_bits(dma_rx_phy), (uint8_t *)ioaddr + DMA_CHAN_RX_BASE_ADDR(chan));
+}
+
+static void dwmac4_dma_init_tx_chan(void  *ioaddr,
+				    struct stmmac_dma_cfg *dma_cfg,
+				    dma_addr_t dma_tx_phy, uint32_t chan)
+{
+	uint32_t value;
+	uint32_t txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;
+
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+	value = value | (txpbl << DMA_BUS_MODE_PBL_SHIFT);
+
+	/* Enable OSP to get best performance */
+	value |= DMA_CONTROL_OSP;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	//if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) && likely(dma_cfg->eame))
+		rte_write32(upper_32_bits(dma_tx_phy),
+		       (uint8_t *)ioaddr + DMA_CHAN_TX_BASE_ADDR_HI(chan));
+
+	rte_write32(lower_32_bits(dma_tx_phy), (uint8_t *)ioaddr + DMA_CHAN_TX_BASE_ADDR(chan));
+}
+
+static void dwmac4_dma_init_channel(void  *ioaddr,
+				    struct stmmac_dma_cfg *dma_cfg, uint32_t chan)
+{
+	uint32_t value;
+
+	/* common channel control register config */
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+	if (dma_cfg->pblx8)
+		value = value | DMA_BUS_MODE_PBL;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+
+	/* Mask interrupts by writing to CSR7 */
+	rte_write32(DMA_CHAN_INTR_DEFAULT_MASK,
+	       (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+static void dwmac410_dma_init_channel(void  *ioaddr,
+				      struct stmmac_dma_cfg *dma_cfg, uint32_t chan)
+{
+	uint32_t value;
+
+	/* common channel control register config */
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+	if (dma_cfg->pblx8)
+		value = value | DMA_BUS_MODE_PBL;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+
+	/* Mask interrupts by writing to CSR7 */
+	rte_write32(DMA_CHAN_INTR_DEFAULT_MASK_4_10,
+	       (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+static void dwmac4_dma_init(void  *ioaddr,
+			    struct stmmac_dma_cfg *dma_cfg)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_SYS_BUS_MODE);
+
+	/* Set the Fixed burst mode */
+	if (dma_cfg->fixed_burst)
+		value |= DMA_SYS_BUS_FB;
+
+	/* Mixed Burst has no effect when fb is set */
+	if (dma_cfg->mixed_burst)
+		value |= DMA_SYS_BUS_MB;
+
+	if (dma_cfg->aal)
+		value |= DMA_SYS_BUS_AAL;
+
+	if (dma_cfg->eame)
+		value |= DMA_SYS_BUS_EAME;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_SYS_BUS_MODE);
+}
+
+static void _dwmac4_dump_dma_regs(void  *ioaddr, uint32_t channel,
+				  uint32_t *reg_space)
+{
+	reg_space[DMA_CHAN_CONTROL(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_CONTROL(channel));
+	reg_space[DMA_CHAN_TX_CONTROL(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(channel));
+	reg_space[DMA_CHAN_RX_CONTROL(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(channel));
+	reg_space[DMA_CHAN_TX_BASE_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_BASE_ADDR(channel));
+	reg_space[DMA_CHAN_RX_BASE_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_BASE_ADDR(channel));
+	reg_space[DMA_CHAN_TX_END_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_END_ADDR(channel));
+	reg_space[DMA_CHAN_RX_END_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_END_ADDR(channel));
+	reg_space[DMA_CHAN_TX_RING_LEN(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_RING_LEN(channel));
+	reg_space[DMA_CHAN_RX_RING_LEN(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_RING_LEN(channel));
+	reg_space[DMA_CHAN_INTR_ENA(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(channel));
+	reg_space[DMA_CHAN_RX_WATCHDOG(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_WATCHDOG(channel));
+	reg_space[DMA_CHAN_SLOT_CTRL_STATUS(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_SLOT_CTRL_STATUS(channel));
+	reg_space[DMA_CHAN_CUR_TX_DESC(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_CUR_TX_DESC(channel));
+	reg_space[DMA_CHAN_CUR_RX_DESC(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_CUR_RX_DESC(channel));
+	reg_space[DMA_CHAN_CUR_TX_BUF_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_CUR_TX_BUF_ADDR(channel));
+	reg_space[DMA_CHAN_CUR_RX_BUF_ADDR(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_CUR_RX_BUF_ADDR(channel));
+	reg_space[DMA_CHAN_STATUS(channel) / 4] =
+		rte_read32((uint8_t *)ioaddr + DMA_CHAN_STATUS(channel));
+}
+
+static void dwmac4_dump_dma_regs(void  *ioaddr, uint32_t *reg_space)
+{
+	int i;
+
+	for (i = 0; i < DMA_CHANNEL_NB_MAX; i++)
+		_dwmac4_dump_dma_regs((uint8_t *)ioaddr, i, reg_space);
+}
+
+static void dwmac4_rx_watchdog(void  *ioaddr, uint32_t riwt, uint32_t number_chan)
+{
+	uint32_t chan;
+
+	for (chan = 0; chan < number_chan; chan++)
+		rte_write32(riwt, (uint8_t *)ioaddr + DMA_CHAN_RX_WATCHDOG(chan));
+}
+
+static void dwmac4_dma_rx_chan_op_mode(void  *ioaddr, int mode,
+				       uint32_t channel, int fifosz, uint8_t qmode)
+{
+	unsigned int rqs = fifosz / 256 - 1;
+	uint32_t mtl_rx_op;
+
+	mtl_rx_op = rte_read32((uint8_t *)ioaddr + MTL_CHAN_RX_OP_MODE(channel));
+
+	if (mode == SF_DMA_MODE) {
+		STMMAC_PMD_INFO("GMAC: enable RX store and forward mode\n");
+		mtl_rx_op |= MTL_OP_MODE_RSF;
+	} else {
+		STMMAC_PMD_INFO("GMAC: disable RX SF mode (threshold %d)\n", mode);
+		mtl_rx_op &= ~MTL_OP_MODE_RSF;
+		mtl_rx_op &= MTL_OP_MODE_RTC_MASK;
+		if (mode <= 32)
+			mtl_rx_op |= MTL_OP_MODE_RTC_32;
+		else if (mode <= 64)
+			mtl_rx_op |= MTL_OP_MODE_RTC_64;
+		else if (mode <= 96)
+			mtl_rx_op |= MTL_OP_MODE_RTC_96;
+		else
+			mtl_rx_op |= MTL_OP_MODE_RTC_128;
+	}
+
+	mtl_rx_op &= ~MTL_OP_MODE_RQS_MASK;
+	mtl_rx_op |= rqs << MTL_OP_MODE_RQS_SHIFT;
+
+	/* Enable flow control only if each channel gets 4 KiB or more FIFO and
+	 * only if channel is not an AVB channel.
+	 */
+	if ((fifosz >= 4096) && (qmode != MTL_QUEUE_AVB)) {
+		unsigned int rfd, rfa;
+
+		mtl_rx_op |= MTL_OP_MODE_EHFC;
+
+		/* Set Threshold for Activating Flow Control to min 2 frames,
+		 * i.e. 1500 * 2 = 3000 bytes.
+		 *
+		 * Set Threshold for Deactivating Flow Control to min 1 frame,
+		 * i.e. 1500 bytes.
+		 */
+		switch (fifosz) {
+		case 4096:
+			/* This violates the above formula because of FIFO size
+			 * limit therefore overflow may occur in spite of this.
+			 */
+			rfd = 0x03; /* Full-2.5K */
+			rfa = 0x01; /* Full-1.5K */
+			break;
+
+		default:
+			rfd = 0x07; /* Full-4.5K */
+			rfa = 0x04; /* Full-3K */
+			break;
+		}
+
+		mtl_rx_op &= ~MTL_OP_MODE_RFD_MASK;
+		mtl_rx_op |= rfd << MTL_OP_MODE_RFD_SHIFT;
+
+		mtl_rx_op &= ~MTL_OP_MODE_RFA_MASK;
+		mtl_rx_op |= rfa << MTL_OP_MODE_RFA_SHIFT;
+	}
+
+	rte_write32(mtl_rx_op, (uint8_t *)ioaddr + MTL_CHAN_RX_OP_MODE(channel));
+}
+
+static void dwmac4_dma_tx_chan_op_mode(void  *ioaddr, int mode,
+				       uint32_t channel, int fifosz, uint8_t qmode)
+{
+	uint32_t mtl_tx_op = rte_read32((uint8_t *)ioaddr + MTL_CHAN_TX_OP_MODE(channel));
+	unsigned int tqs = fifosz / 256 - 1;
+
+	if (mode == SF_DMA_MODE) {
+		STMMAC_PMD_INFO("GMAC: enable TX store and forward mode\n");
+		/* Transmit COE type 2 cannot be done in cut-through mode. */
+		mtl_tx_op |= MTL_OP_MODE_TSF;
+	} else {
+		STMMAC_PMD_INFO("GMAC: disabling TX SF (threshold %d)\n", mode);
+		mtl_tx_op &= ~MTL_OP_MODE_TSF;
+		mtl_tx_op &= MTL_OP_MODE_TTC_MASK;
+		/* Set the transmit threshold */
+		if (mode <= 32)
+			mtl_tx_op |= MTL_OP_MODE_TTC_32;
+		else if (mode <= 64)
+			mtl_tx_op |= MTL_OP_MODE_TTC_64;
+		else if (mode <= 96)
+			mtl_tx_op |= MTL_OP_MODE_TTC_96;
+		else if (mode <= 128)
+			mtl_tx_op |= MTL_OP_MODE_TTC_128;
+		else if (mode <= 192)
+			mtl_tx_op |= MTL_OP_MODE_TTC_192;
+		else if (mode <= 256)
+			mtl_tx_op |= MTL_OP_MODE_TTC_256;
+		else if (mode <= 384)
+			mtl_tx_op |= MTL_OP_MODE_TTC_384;
+		else
+			mtl_tx_op |= MTL_OP_MODE_TTC_512;
+	}
+	/* For an IP with DWC_EQOS_NUM_TXQ == 1, the fields TXQEN and TQS are RO
+	 * with reset values: TXQEN on, TQS == DWC_EQOS_TXFIFO_SIZE.
+	 * For an IP with DWC_EQOS_NUM_TXQ > 1, the fields TXQEN and TQS are R/W
+	 * with reset values: TXQEN off, TQS 256 bytes.
+	 *
+	 * TXQEN must be written for multi-channel operation and TQS must
+	 * reflect the available fifo size per queue (total fifo size / number
+	 * of enabled queues).
+	 */
+	mtl_tx_op &= ~MTL_OP_MODE_TXQEN_MASK;
+	if (qmode != MTL_QUEUE_AVB)
+		mtl_tx_op |= MTL_OP_MODE_TXQEN;
+	else
+		mtl_tx_op |= MTL_OP_MODE_TXQEN_AV;
+	mtl_tx_op &= ~MTL_OP_MODE_TQS_MASK;
+	mtl_tx_op |= tqs << MTL_OP_MODE_TQS_SHIFT;
+
+	rte_write32(mtl_tx_op, (uint8_t *)ioaddr +  MTL_CHAN_TX_OP_MODE(channel));
+}
+
+static void dwmac4_get_hw_feature(void  *ioaddr,
+				  struct dma_features *dma_cap)
+{
+	uint32_t hw_cap = rte_read32((uint8_t *)ioaddr + GMAC_HW_FEATURE0);
+
+	/*  MAC HW feature0 */
+	dma_cap->mbps_10_100 = (hw_cap & GMAC_HW_FEAT_MIISEL);
+	dma_cap->mbps_1000 = (hw_cap & GMAC_HW_FEAT_GMIISEL) >> 1;
+	dma_cap->half_duplex = (hw_cap & GMAC_HW_FEAT_HDSEL) >> 2;
+	dma_cap->vlhash = (hw_cap & GMAC_HW_FEAT_VLHASH) >> 4;
+	dma_cap->multi_addr = (hw_cap & GMAC_HW_FEAT_ADDMAC) >> 18;
+	dma_cap->pcs = (hw_cap & GMAC_HW_FEAT_PCSSEL) >> 3;
+	dma_cap->sma_mdio = (hw_cap & GMAC_HW_FEAT_SMASEL) >> 5;
+	dma_cap->pmt_remote_wake_up = (hw_cap & GMAC_HW_FEAT_RWKSEL) >> 6;
+	dma_cap->pmt_magic_frame = (hw_cap & GMAC_HW_FEAT_MGKSEL) >> 7;
+	/* MMC */
+	dma_cap->rmon = (hw_cap & GMAC_HW_FEAT_MMCSEL) >> 8;
+	/* IEEE 1588-2008 */
+	dma_cap->atime_stamp = (hw_cap & GMAC_HW_FEAT_TSSEL) >> 12;
+	/* 802.3az - Energy-Efficient Ethernet (EEE) */
+	dma_cap->eee = (hw_cap & GMAC_HW_FEAT_EEESEL) >> 13;
+	/* TX and RX csum */
+	dma_cap->tx_coe = (hw_cap & GMAC_HW_FEAT_TXCOSEL) >> 14;
+	dma_cap->rx_coe =  (hw_cap & GMAC_HW_FEAT_RXCOESEL) >> 16;
+	dma_cap->vlins = (hw_cap & GMAC_HW_FEAT_SAVLANINS) >> 27;
+	dma_cap->arpoffsel = (hw_cap & GMAC_HW_FEAT_ARPOFFSEL) >> 9;
+
+	/* MAC HW feature1 */
+	hw_cap = rte_read32((uint8_t *)ioaddr + GMAC_HW_FEATURE1);
+	dma_cap->l3l4fnum = (hw_cap & GMAC_HW_FEAT_L3L4FNUM) >> 27;
+	dma_cap->hash_tb_sz = (hw_cap & GMAC_HW_HASH_TB_SZ) >> 24;
+	dma_cap->av = (hw_cap & GMAC_HW_FEAT_AVSEL) >> 20;
+	dma_cap->tsoen = (hw_cap & GMAC_HW_TSOEN) >> 18;
+	dma_cap->sphen = (hw_cap & GMAC_HW_FEAT_SPHEN) >> 17;
+
+	dma_cap->addr64 = (hw_cap & GMAC_HW_ADDR64) >> 14;
+	switch (dma_cap->addr64) {
+	case 0:
+		dma_cap->addr64 = 32;
+		break;
+	case 1:
+		dma_cap->addr64 = 40;
+		break;
+	case 2:
+		dma_cap->addr64 = 48;
+		break;
+	default:
+		dma_cap->addr64 = 32;
+		break;
+	}
+
+	/* RX and TX FIFO sizes are encoded as log2(n / 128). Undo that by
+	 * shifting and store the sizes in bytes.
+	 */
+	dma_cap->tx_fifo_size = 128 << ((hw_cap & GMAC_HW_TXFIFOSIZE) >> 6);
+	dma_cap->rx_fifo_size = 128 << ((hw_cap & GMAC_HW_RXFIFOSIZE) >> 0);
+	/* MAC HW feature2 */
+	hw_cap = rte_read32((uint8_t *)ioaddr + GMAC_HW_FEATURE2);
+	/* TX and RX number of channels */
+	dma_cap->number_rx_channel =
+		((hw_cap & GMAC_HW_FEAT_RXCHCNT) >> 12) + 1;
+	dma_cap->number_tx_channel =
+		((hw_cap & GMAC_HW_FEAT_TXCHCNT) >> 18) + 1;
+	/* TX and RX number of queues */
+	dma_cap->number_rx_queues =
+		((hw_cap & GMAC_HW_FEAT_RXQCNT) >> 0) + 1;
+	dma_cap->number_tx_queues =
+		((hw_cap & GMAC_HW_FEAT_TXQCNT) >> 6) + 1;
+	/* PPS output */
+	dma_cap->pps_out_num = (hw_cap & GMAC_HW_FEAT_PPSOUTNUM) >> 24;
+
+	/* IEEE 1588-2002 */
+	dma_cap->time_stamp = 0;
+
+	/* MAC HW feature3 */
+	hw_cap = rte_read32((uint8_t *)ioaddr + GMAC_HW_FEATURE3);
+
+	/* 5.10 Features */
+	dma_cap->asp = (hw_cap & GMAC_HW_FEAT_ASP) >> 28;
+	dma_cap->tbssel = (hw_cap & GMAC_HW_FEAT_TBSSEL) >> 27;
+	dma_cap->fpesel = (hw_cap & GMAC_HW_FEAT_FPESEL) >> 26;
+	dma_cap->estwid = (hw_cap & GMAC_HW_FEAT_ESTWID) >> 20;
+	dma_cap->estdep = (hw_cap & GMAC_HW_FEAT_ESTDEP) >> 17;
+	dma_cap->estsel = (hw_cap & GMAC_HW_FEAT_ESTSEL) >> 16;
+	dma_cap->frpes = (hw_cap & GMAC_HW_FEAT_FRPES) >> 13;
+	dma_cap->frpbs = (hw_cap & GMAC_HW_FEAT_FRPBS) >> 11;
+	dma_cap->frpsel = (hw_cap & GMAC_HW_FEAT_FRPSEL) >> 10;
+	dma_cap->dvlan = (hw_cap & GMAC_HW_FEAT_DVLAN) >> 5;
+}
+
+/* Enable/disable TSO feature and set MSS */
+static void dwmac4_enable_tso(void  *ioaddr, bool en, uint32_t chan)
+{
+	uint32_t value;
+
+	if (en) {
+		/* enable TSO */
+		value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+		rte_write32(value | DMA_CONTROL_TSE,
+		       (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+	} else {
+		/* enable TSO */
+		value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+		rte_write32(value & ~DMA_CONTROL_TSE,
+		       (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+	}
+}
+
+static void dwmac4_qmode(void  *ioaddr, uint32_t channel, uint8_t qmode)
+{
+	uint32_t mtl_tx_op = rte_read32((uint8_t *)ioaddr + MTL_CHAN_TX_OP_MODE(channel));
+
+	mtl_tx_op &= ~MTL_OP_MODE_TXQEN_MASK;
+	if (qmode != MTL_QUEUE_AVB)
+		mtl_tx_op |= MTL_OP_MODE_TXQEN;
+	else
+		mtl_tx_op |= MTL_OP_MODE_TXQEN_AV;
+
+	rte_write32(mtl_tx_op, (uint8_t *)ioaddr +  MTL_CHAN_TX_OP_MODE(channel));
+}
+
+static void dwmac4_set_bfsize(void  *ioaddr, int bfsize, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+
+	value &= ~DMA_RBSZ_MASK;
+	value |= (bfsize << DMA_RBSZ_SHIFT) & DMA_RBSZ_MASK;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+}
+
+static void dwmac4_enable_sph(void  *ioaddr, bool en, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_EXT_CONFIG);
+
+	value &= ~GMAC_CONFIG_HDSMS;
+	value |= GMAC_CONFIG_HDSMS_256; /* Segment max 256 bytes */
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_EXT_CONFIG);
+
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+	if (en)
+		value |= DMA_CONTROL_SPH;
+	else
+		value &= ~DMA_CONTROL_SPH;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_CONTROL(chan));
+}
+
+static int dwmac4_enable_tbs(void  *ioaddr, bool en, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	if (en)
+		value |= DMA_CONTROL_EDSE;
+	else
+		value &= ~DMA_CONTROL_EDSE;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan)) & DMA_CONTROL_EDSE;
+	if (en && !value)
+		return -EIO;
+
+	rte_write32(DMA_TBS_DEF_FTOS, (uint8_t *)ioaddr + DMA_TBS_CTRL);
+	return 0;
+}
+
+const struct stmmac_dma_ops dwmac4_dma_ops = {
+	.reset = dwmac4_dma_reset,
+	.init = dwmac4_dma_init,
+	.init_chan = dwmac4_dma_init_channel,
+	.init_rx_chan = dwmac4_dma_init_rx_chan,
+	.init_tx_chan = dwmac4_dma_init_tx_chan,
+	.axi = dwmac4_dma_axi,
+	.dump_regs = dwmac4_dump_dma_regs,
+	.dma_rx_mode = dwmac4_dma_rx_chan_op_mode,
+	.dma_tx_mode = dwmac4_dma_tx_chan_op_mode,
+	.enable_dma_irq = dwmac4_enable_dma_irq,
+	.disable_dma_irq = dwmac4_disable_dma_irq,
+	.start_tx = dwmac4_dma_start_tx,
+	.stop_tx = dwmac4_dma_stop_tx,
+	.start_rx = dwmac4_dma_start_rx,
+	.stop_rx = dwmac4_dma_stop_rx,
+	.dma_interrupt = dwmac4_dma_interrupt,
+	.get_hw_feature = dwmac4_get_hw_feature,
+	.rx_watchdog = dwmac4_rx_watchdog,
+	.set_rx_ring_len = dwmac4_set_rx_ring_len,
+	.set_tx_ring_len = dwmac4_set_tx_ring_len,
+	.set_rx_tail_ptr = dwmac4_set_rx_tail_ptr,
+	.set_tx_tail_ptr = dwmac4_set_tx_tail_ptr,
+	.enable_tso = dwmac4_enable_tso,
+	.qmode = dwmac4_qmode,
+	.set_bfsize = dwmac4_set_bfsize,
+	.enable_sph = dwmac4_enable_sph,
+};
+
+const struct stmmac_dma_ops dwmac410_dma_ops = {
+	.reset = dwmac4_dma_reset,
+	.init = dwmac4_dma_init,
+	.init_chan = dwmac410_dma_init_channel,
+	.init_rx_chan = dwmac4_dma_init_rx_chan,
+	.init_tx_chan = dwmac4_dma_init_tx_chan,
+	.axi = dwmac4_dma_axi,
+	.dump_regs = dwmac4_dump_dma_regs,
+	.dma_rx_mode = dwmac4_dma_rx_chan_op_mode,
+	.dma_tx_mode = dwmac4_dma_tx_chan_op_mode,
+	.enable_dma_irq = dwmac410_enable_dma_irq,
+	.disable_dma_irq = dwmac4_disable_dma_irq,
+	.start_tx = dwmac4_dma_start_tx,
+	.stop_tx = dwmac4_dma_stop_tx,
+	.start_rx = dwmac4_dma_start_rx,
+	.stop_rx = dwmac4_dma_stop_rx,
+	.dma_interrupt = dwmac4_dma_interrupt,
+	.get_hw_feature = dwmac4_get_hw_feature,
+	.rx_watchdog = dwmac4_rx_watchdog,
+	.set_rx_ring_len = dwmac4_set_rx_ring_len,
+	.set_tx_ring_len = dwmac4_set_tx_ring_len,
+	.set_rx_tail_ptr = dwmac4_set_rx_tail_ptr,
+	.set_tx_tail_ptr = dwmac4_set_tx_tail_ptr,
+	.enable_tso = dwmac4_enable_tso,
+	.qmode = dwmac4_qmode,
+	.set_bfsize = dwmac4_set_bfsize,
+	.enable_sph = dwmac4_enable_sph,
+	.enable_tbs = dwmac4_enable_tbs,
+};
diff --git a/drivers/net/stmmac/dwmac4_dma.h b/drivers/net/stmmac/dwmac4_dma.h
new file mode 100644
index 0000000..2af50b4
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_dma.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __DWMAC4_DMA_H__
+#define __DWMAC4_DMA_H__
+
+#include "descs.h"
+
+/* Define the max channel number used for tx (also rx).
+ * dwmac4 accepts up to 8 channels for TX (and also 8 channels for RX
+ */
+#define DMA_CHANNEL_NB_MAX		1
+
+#define DMA_BUS_MODE			0x00001000
+#define DMA_SYS_BUS_MODE		0x00001004
+#define DMA_STATUS			0x00001008
+#define DMA_DEBUG_STATUS_0		0x0000100c
+#define DMA_DEBUG_STATUS_1		0x00001010
+#define DMA_DEBUG_STATUS_2		0x00001014
+#define DMA_AXI_BUS_MODE		0x00001028
+#define DMA_TBS_CTRL			0x00001050
+
+/* DMA Bus Mode bitmap */
+#define DMA_BUS_MODE_SFT_RESET		BIT(0)
+
+/* DMA SYS Bus Mode bitmap */
+#define DMA_BUS_MODE_SPH		BIT(24)
+#define DMA_BUS_MODE_PBL		BIT(16)
+#define DMA_BUS_MODE_PBL_SHIFT		16
+#define DMA_BUS_MODE_RPBL_SHIFT		16
+#define DMA_BUS_MODE_MB			BIT(14)
+#define DMA_BUS_MODE_FB			BIT(0)
+
+/* DMA Interrupt top status */
+#define DMA_STATUS_MAC			BIT(17)
+#define DMA_STATUS_MTL			BIT(16)
+#define DMA_STATUS_CHAN7		BIT(7)
+#define DMA_STATUS_CHAN6		BIT(6)
+#define DMA_STATUS_CHAN5		BIT(5)
+#define DMA_STATUS_CHAN4		BIT(4)
+#define DMA_STATUS_CHAN3		BIT(3)
+#define DMA_STATUS_CHAN2		BIT(2)
+#define DMA_STATUS_CHAN1		BIT(1)
+#define DMA_STATUS_CHAN0		BIT(0)
+
+/* DMA debug status bitmap */
+#define DMA_DEBUG_STATUS_TS_MASK	0xf
+#define DMA_DEBUG_STATUS_RS_MASK	0xf
+
+/* DMA AXI bitmap */
+#define DMA_AXI_EN_LPI			BIT(31)
+#define DMA_AXI_LPI_XIT_FRM		BIT(30)
+#define DMA_AXI_WR_OSR_LMT		GENMASK(27, 24)
+#define DMA_AXI_WR_OSR_LMT_SHIFT	24
+#define DMA_AXI_RD_OSR_LMT		GENMASK(19, 16)
+#define DMA_AXI_RD_OSR_LMT_SHIFT	16
+
+#define DMA_AXI_OSR_MAX			0xf
+#define DMA_AXI_MAX_OSR_LIMIT ((DMA_AXI_OSR_MAX << DMA_AXI_WR_OSR_LMT_SHIFT) | \
+				(DMA_AXI_OSR_MAX << DMA_AXI_RD_OSR_LMT_SHIFT))
+
+#define DMA_SYS_BUS_MB			BIT(14)
+#define DMA_AXI_1KBBE			BIT(13)
+#define DMA_SYS_BUS_AAL			BIT(12)
+#define DMA_SYS_BUS_EAME		BIT(11)
+#define DMA_AXI_BLEN256			BIT(7)
+#define DMA_AXI_BLEN128			BIT(6)
+#define DMA_AXI_BLEN64			BIT(5)
+#define DMA_AXI_BLEN32			BIT(4)
+#define DMA_AXI_BLEN16			BIT(3)
+#define DMA_AXI_BLEN8			BIT(2)
+#define DMA_AXI_BLEN4			BIT(1)
+#define DMA_SYS_BUS_FB			BIT(0)
+
+#define DMA_BURST_LEN_DEFAULT		(DMA_AXI_BLEN256 | DMA_AXI_BLEN128 | \
+					DMA_AXI_BLEN64 | DMA_AXI_BLEN32 | \
+					DMA_AXI_BLEN16 | DMA_AXI_BLEN8 | \
+					DMA_AXI_BLEN4)
+
+#define DMA_AXI_BURST_LEN_MASK		0x000000FE
+
+/* DMA TBS Control */
+#define DMA_TBS_FTOS			GENMASK(31, 8)
+#define DMA_TBS_FTOV			BIT(0)
+#define DMA_TBS_DEF_FTOS		(DMA_TBS_FTOS | DMA_TBS_FTOV)
+
+/* Following DMA defines are chanels oriented */
+#define DMA_CHAN_BASE_ADDR		0x00001100
+#define DMA_CHAN_BASE_OFFSET		0x80
+#define DMA_CHANX_BASE_ADDR(x)		(DMA_CHAN_BASE_ADDR + \
+					(x * DMA_CHAN_BASE_OFFSET))
+#define DMA_CHAN_REG_NUMBER		17
+
+#define DMA_CHAN_CONTROL(x)		DMA_CHANX_BASE_ADDR(x)
+#define DMA_CHAN_TX_CONTROL(x)		(DMA_CHANX_BASE_ADDR(x) + 0x4)
+#define DMA_CHAN_RX_CONTROL(x)		(DMA_CHANX_BASE_ADDR(x) + 0x8)
+#define DMA_CHAN_TX_BASE_ADDR_HI(x)	(DMA_CHANX_BASE_ADDR(x) + 0x10)
+#define DMA_CHAN_TX_BASE_ADDR(x)	(DMA_CHANX_BASE_ADDR(x) + 0x14)
+#define DMA_CHAN_RX_BASE_ADDR_HI(x)	(DMA_CHANX_BASE_ADDR(x) + 0x18)
+#define DMA_CHAN_RX_BASE_ADDR(x)	(DMA_CHANX_BASE_ADDR(x) + 0x1c)
+#define DMA_CHAN_TX_END_ADDR(x)		(DMA_CHANX_BASE_ADDR(x) + 0x20)
+#define DMA_CHAN_RX_END_ADDR(x)		(DMA_CHANX_BASE_ADDR(x) + 0x28)
+#define DMA_CHAN_TX_RING_LEN(x)		(DMA_CHANX_BASE_ADDR(x) + 0x2c)
+#define DMA_CHAN_RX_RING_LEN(x)		(DMA_CHANX_BASE_ADDR(x) + 0x30)
+#define DMA_CHAN_INTR_ENA(x)		(DMA_CHANX_BASE_ADDR(x) + 0x34)
+#define DMA_CHAN_RX_WATCHDOG(x)		(DMA_CHANX_BASE_ADDR(x) + 0x38)
+#define DMA_CHAN_SLOT_CTRL_STATUS(x)	(DMA_CHANX_BASE_ADDR(x) + 0x3c)
+#define DMA_CHAN_CUR_TX_DESC(x)		(DMA_CHANX_BASE_ADDR(x) + 0x44)
+#define DMA_CHAN_CUR_RX_DESC(x)		(DMA_CHANX_BASE_ADDR(x) + 0x4c)
+#define DMA_CHAN_CUR_TX_BUF_ADDR(x)	(DMA_CHANX_BASE_ADDR(x) + 0x54)
+#define DMA_CHAN_CUR_RX_BUF_ADDR(x)	(DMA_CHANX_BASE_ADDR(x) + 0x5c)
+#define DMA_CHAN_STATUS(x)		(DMA_CHANX_BASE_ADDR(x) + 0x60)
+
+/* DMA Control X */
+#define DMA_CONTROL_SPH			BIT(24)
+#define DMA_CONTROL_MSS_MASK		GENMASK(13, 0)
+
+/* DMA Tx Channel X Control register defines */
+#define DMA_CONTROL_EDSE		BIT(28)
+#define DMA_CONTROL_TSE			BIT(12)
+#define DMA_CONTROL_OSP			BIT(4)
+#define DMA_CONTROL_ST			BIT(0)
+
+/* DMA Rx Channel X Control register defines */
+#define DMA_CONTROL_SR			BIT(0)
+#define DMA_RBSZ_MASK			GENMASK(14, 1)
+#define DMA_RBSZ_SHIFT			1
+
+/* Interrupt status per channel */
+#define DMA_CHAN_STATUS_REB		GENMASK(21, 19)
+#define DMA_CHAN_STATUS_REB_SHIFT	19
+#define DMA_CHAN_STATUS_TEB		GENMASK(18, 16)
+#define DMA_CHAN_STATUS_TEB_SHIFT	16
+#define DMA_CHAN_STATUS_NIS		BIT(15)
+#define DMA_CHAN_STATUS_AIS		BIT(14)
+#define DMA_CHAN_STATUS_CDE		BIT(13)
+#define DMA_CHAN_STATUS_FBE		BIT(12)
+#define DMA_CHAN_STATUS_ERI		BIT(11)
+#define DMA_CHAN_STATUS_ETI		BIT(10)
+#define DMA_CHAN_STATUS_RWT		BIT(9)
+#define DMA_CHAN_STATUS_RPS		BIT(8)
+#define DMA_CHAN_STATUS_RBU		BIT(7)
+#define DMA_CHAN_STATUS_RI		BIT(6)
+#define DMA_CHAN_STATUS_TBU		BIT(2)
+#define DMA_CHAN_STATUS_TPS		BIT(1)
+#define DMA_CHAN_STATUS_TI		BIT(0)
+
+/* Interrupt enable bits per channel */
+#define DMA_CHAN_INTR_ENA_NIE		BIT(16)
+#define DMA_CHAN_INTR_ENA_AIE		BIT(15)
+#define DMA_CHAN_INTR_ENA_NIE_4_10	BIT(15)
+#define DMA_CHAN_INTR_ENA_AIE_4_10	BIT(14)
+#define DMA_CHAN_INTR_ENA_CDE		BIT(13)
+#define DMA_CHAN_INTR_ENA_FBE		BIT(12)
+#define DMA_CHAN_INTR_ENA_ERE		BIT(11)
+#define DMA_CHAN_INTR_ENA_ETE		BIT(10)
+#define DMA_CHAN_INTR_ENA_RWE		BIT(9)
+#define DMA_CHAN_INTR_ENA_RSE		BIT(8)
+#define DMA_CHAN_INTR_ENA_RBUE		BIT(7)
+#define DMA_CHAN_INTR_ENA_RIE		BIT(6)
+#define DMA_CHAN_INTR_ENA_TBUE		BIT(2)
+#define DMA_CHAN_INTR_ENA_TSE		BIT(1)
+#define DMA_CHAN_INTR_ENA_TIE		BIT(0)
+
+#define DMA_CHAN_INTR_NORMAL		(DMA_CHAN_INTR_ENA_NIE | \
+					 DMA_CHAN_INTR_ENA_RIE | \
+					 DMA_CHAN_INTR_ENA_TIE)
+
+#define DMA_CHAN_INTR_ABNORMAL		(DMA_CHAN_INTR_ENA_AIE | \
+					 DMA_CHAN_INTR_ENA_FBE)
+/* DMA default interrupt mask for 4.00 */
+#define DMA_CHAN_INTR_DEFAULT_MASK	(DMA_CHAN_INTR_NORMAL | \
+					 DMA_CHAN_INTR_ABNORMAL)
+#define DMA_CHAN_INTR_DEFAULT_RX	(DMA_CHAN_INTR_ENA_RIE)
+#define DMA_CHAN_INTR_DEFAULT_TX	(DMA_CHAN_INTR_ENA_TIE)
+
+#define DMA_CHAN_INTR_NORMAL_4_10	(DMA_CHAN_INTR_ENA_NIE_4_10 | \
+					 DMA_CHAN_INTR_ENA_RIE | \
+					 DMA_CHAN_INTR_ENA_TIE)
+
+#define DMA_CHAN_INTR_ABNORMAL_4_10	(DMA_CHAN_INTR_ENA_AIE_4_10 | \
+					 DMA_CHAN_INTR_ENA_FBE)
+/* DMA default interrupt mask for 4.10a */
+#define DMA_CHAN_INTR_DEFAULT_MASK_4_10	(DMA_CHAN_INTR_NORMAL_4_10 | \
+					 DMA_CHAN_INTR_ABNORMAL_4_10)
+#define DMA_CHAN_INTR_DEFAULT_RX_4_10	(DMA_CHAN_INTR_ENA_RIE)
+#define DMA_CHAN_INTR_DEFAULT_TX_4_10	(DMA_CHAN_INTR_ENA_TIE)
+
+/* channel 0 specific fields */
+#define DMA_CHAN0_DBG_STAT_TPS		GENMASK(15, 12)
+#define DMA_CHAN0_DBG_STAT_TPS_SHIFT	12
+#define DMA_CHAN0_DBG_STAT_RPS		GENMASK(11, 8)
+#define DMA_CHAN0_DBG_STAT_RPS_SHIFT	8
+
+int dwmac4_dma_reset(void  *ioaddr);
+void dwmac4_enable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx);
+void dwmac410_enable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx);
+void dwmac4_disable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx);
+void dwmac410_disable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx);
+void dwmac4_dma_start_tx(void  *ioaddr, uint32_t chan);
+void dwmac4_dma_stop_tx(void  *ioaddr, uint32_t chan);
+void dwmac4_dma_start_rx(void  *ioaddr, uint32_t chan);
+void dwmac4_dma_stop_rx(void  *ioaddr, uint32_t chan);
+int dwmac4_dma_interrupt(void  *ioaddr,
+			 struct stmmac_extra_stats *x, uint32_t chan);
+void dwmac4_set_rx_ring_len(void  *ioaddr, uint32_t len, uint32_t chan);
+void dwmac4_set_tx_ring_len(void  *ioaddr, uint32_t len, uint32_t chan);
+void dwmac4_set_rx_tail_ptr(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+void dwmac4_set_tx_tail_ptr(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+
+#endif /* __DWMAC4_DMA_H__ */
diff --git a/drivers/net/stmmac/dwmac4_lib.c b/drivers/net/stmmac/dwmac4_lib.c
new file mode 100644
index 0000000..95e25d8
--- /dev/null
+++ b/drivers/net/stmmac/dwmac4_lib.c
@@ -0,0 +1,230 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include "common.h"
+#include "dwmac4_dma.h"
+#include "dwmac4.h"
+
+int dwmac4_dma_reset(void *ioaddr)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_BUS_MODE);
+	int limit;
+
+	/* DMA SW reset */
+	value |= DMA_BUS_MODE_SFT_RESET;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_BUS_MODE);
+	limit = 10;
+	while (limit--) {
+		if (!(rte_read32((uint8_t *)ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))
+			break;
+		rte_delay_us(10 * 1000);
+	}
+
+	if (limit < 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+void dwmac4_set_rx_tail_ptr(void  *ioaddr, uint32_t tail_ptr, uint32_t chan)
+{
+	rte_write32(tail_ptr, (uint8_t *)ioaddr + DMA_CHAN_RX_END_ADDR(chan));
+}
+
+void dwmac4_set_tx_tail_ptr(void  *ioaddr, uint32_t tail_ptr, uint32_t chan)
+{
+	rte_write32(tail_ptr, (uint8_t *)ioaddr + DMA_CHAN_TX_END_ADDR(chan));
+}
+
+void dwmac4_dma_start_tx(void  *ioaddr, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	value |= DMA_CONTROL_ST;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+	value |= GMAC_CONFIG_TE;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+void dwmac4_dma_stop_tx(void  *ioaddr, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+
+	value &= ~DMA_CONTROL_ST;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_TX_CONTROL(chan));
+}
+
+void dwmac4_dma_start_rx(void  *ioaddr, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+
+	value |= DMA_CONTROL_SR;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+
+	value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+	value |= GMAC_CONFIG_RE;
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+void dwmac4_dma_stop_rx(void  *ioaddr, uint32_t chan)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+
+	value &= ~DMA_CONTROL_SR;
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_RX_CONTROL(chan));
+}
+
+void dwmac4_set_tx_ring_len(void  *ioaddr, uint32_t len, uint32_t chan)
+{
+	rte_write32(len, (uint8_t *)ioaddr + DMA_CHAN_TX_RING_LEN(chan));
+}
+
+void dwmac4_set_rx_ring_len(void  *ioaddr, uint32_t len, uint32_t chan)
+{
+	rte_write32(len, (uint8_t *)ioaddr + DMA_CHAN_RX_RING_LEN(chan));
+}
+
+void dwmac4_enable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+
+	if (rx)
+		value |= DMA_CHAN_INTR_DEFAULT_RX;
+	if (tx)
+		value |= DMA_CHAN_INTR_DEFAULT_TX;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+void dwmac410_enable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+
+	if (rx)
+		value |= DMA_CHAN_INTR_DEFAULT_RX_4_10;
+	if (tx)
+		value |= DMA_CHAN_INTR_DEFAULT_TX_4_10;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+void dwmac4_disable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+
+	if (rx)
+		value &= ~DMA_CHAN_INTR_DEFAULT_RX;
+	if (tx)
+		value &= ~DMA_CHAN_INTR_DEFAULT_TX;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+void dwmac410_disable_dma_irq(void  *ioaddr, uint32_t chan, bool rx, bool tx)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+
+	if (rx)
+		value &= ~DMA_CHAN_INTR_DEFAULT_RX_4_10;
+	if (tx)
+		value &= ~DMA_CHAN_INTR_DEFAULT_TX_4_10;
+
+	rte_write32(value, (uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+}
+
+int dwmac4_dma_interrupt(void  *ioaddr,
+			 struct stmmac_extra_stats *x, uint32_t chan)
+{
+	uint32_t intr_status = rte_read32((uint8_t *)ioaddr + DMA_CHAN_STATUS(chan));
+	uint32_t intr_en = rte_read32((uint8_t *)ioaddr + DMA_CHAN_INTR_ENA(chan));
+	int ret = 0;
+
+	/* ABNORMAL interrupts */
+	if (unlikely(intr_status & DMA_CHAN_STATUS_AIS)) {
+		if (unlikely(intr_status & DMA_CHAN_STATUS_RBU))
+			x->rx_buf_unav_irq++;
+		if (unlikely(intr_status & DMA_CHAN_STATUS_RPS))
+			x->rx_process_stopped_irq++;
+		if (unlikely(intr_status & DMA_CHAN_STATUS_RWT))
+			x->rx_watchdog_irq++;
+		if (unlikely(intr_status & DMA_CHAN_STATUS_ETI))
+			x->tx_early_irq++;
+		if (unlikely(intr_status & DMA_CHAN_STATUS_TPS)) {
+			x->tx_process_stopped_irq++;
+			ret = tx_hard_error;
+		}
+		if (unlikely(intr_status & DMA_CHAN_STATUS_FBE)) {
+			x->fatal_bus_error_irq++;
+			ret = tx_hard_error;
+		}
+	}
+	/* TX/RX NORMAL interrupts */
+	if (likely(intr_status & DMA_CHAN_STATUS_NIS)) {
+		x->normal_irq_n++;
+		if (likely(intr_status & DMA_CHAN_STATUS_RI)) {
+			x->rx_normal_irq_n++;
+			ret |= handle_rx;
+		}
+		if (likely(intr_status & (DMA_CHAN_STATUS_TI |
+					  DMA_CHAN_STATUS_TBU))) {
+			x->tx_normal_irq_n++;
+			ret |= handle_tx;
+		}
+		if (unlikely(intr_status & DMA_CHAN_STATUS_ERI))
+			x->rx_early_irq++;
+	}
+
+	rte_write32(intr_status & intr_en, (uint8_t *)ioaddr + DMA_CHAN_STATUS(chan));
+	return ret;
+}
+
+void stmmac_dwmac4_set_mac_addr(void  *ioaddr, uint8_t addr[6],
+				unsigned int high, unsigned int low)
+{
+	unsigned long data;
+
+	data = (addr[5] << 8) | addr[4];
+	/* For MAC Addr registers se have to set the Address Enable (AE)
+	 * bit that has no effect on the High Reg 0 where the bit 31 (MO)
+	 * is RO.
+	 */
+	data |= (STMMAC_CHAN0 << GMAC_HI_DCS_SHIFT);
+	rte_write32(data | GMAC_HI_REG_AE, (uint8_t *)ioaddr + high);
+	data = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
+	rte_write32(data, (uint8_t *)ioaddr + low);
+}
+
+/* Enable disable MAC RX/TX */
+void stmmac_dwmac4_set_mac(void  *ioaddr, bool enable)
+{
+	uint32_t value = rte_read32((uint8_t *)ioaddr + GMAC_CONFIG);
+
+	if (enable)
+		value |= GMAC_CONFIG_RE | GMAC_CONFIG_TE;
+	else
+		value &= ~(GMAC_CONFIG_TE | GMAC_CONFIG_RE);
+
+	rte_write32(value, (uint8_t *)ioaddr + GMAC_CONFIG);
+}
+
+void stmmac_dwmac4_get_mac_addr(void  *ioaddr, unsigned char *addr,
+				unsigned int high, unsigned int low)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = rte_read32((uint8_t *)ioaddr + high);
+	lo_addr = rte_read32((uint8_t *)ioaddr + low);
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xff;
+	addr[1] = (lo_addr >> 8) & 0xff;
+	addr[2] = (lo_addr >> 16) & 0xff;
+	addr[3] = (lo_addr >> 24) & 0xff;
+	addr[4] = hi_addr & 0xff;
+	addr[5] = (hi_addr >> 8) & 0xff;
+}
diff --git a/drivers/net/stmmac/dwmac5.h b/drivers/net/stmmac/dwmac5.h
new file mode 100644
index 0000000..ed54b23
--- /dev/null
+++ b/drivers/net/stmmac/dwmac5.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __DWMAC5_H__
+#define __DWMAC5_H__
+
+#include "common.h"
+
+#define MAC_DPP_FSM_INT_STATUS		0x00000140
+#define MAC_AXI_SLV_DPE_ADDR_STATUS	0x00000144
+#define MAC_FSM_CONTROL			0x00000148
+#define PRTYEN				BIT(1)
+#define TMOUTEN				BIT(0)
+
+#define MAC_FPE_CTRL_STS		0x00000234
+#define EFPE				BIT(0)
+
+#define MAC_PPS_CONTROL			0x00000b70
+#define PPS_MAXIDX(x)			((((x) + 1) * 8) - 1)
+#define PPS_MINIDX(x)			((x) * 8)
+#define PPSx_MASK(x)			GENMASK(PPS_MAXIDX(x), PPS_MINIDX(x))
+#define MCGRENx(x)			BIT(PPS_MAXIDX(x))
+#define TRGTMODSELx(x, val)		\
+	GENMASK(PPS_MAXIDX(x) - 1, PPS_MAXIDX(x) - 2) & \
+	((val) << (PPS_MAXIDX(x) - 2))
+#define PPSCMDx(x, val)			\
+	GENMASK(PPS_MINIDX(x) + 3, PPS_MINIDX(x)) & \
+	((val) << PPS_MINIDX(x))
+#define PPSEN0				BIT(4)
+#define MAC_PPSx_TARGET_TIME_SEC(x)	(0x00000b80 + ((x) * 0x10))
+#define MAC_PPSx_TARGET_TIME_NSEC(x)	(0x00000b84 + ((x) * 0x10))
+#define TRGTBUSY0			BIT(31)
+#define TTSL0				GENMASK(30, 0)
+#define MAC_PPSx_INTERVAL(x)		(0x00000b88 + ((x) * 0x10))
+#define MAC_PPSx_WIDTH(x)		(0x00000b8c + ((x) * 0x10))
+
+#define MTL_EST_CONTROL			0x00000c50
+#define PTOV				GENMASK(31, 24)
+#define PTOV_SHIFT			24
+#define SSWL				BIT(1)
+#define EEST				BIT(0)
+#define MTL_EST_GCL_CONTROL		0x00000c80
+#define BTR_LOW				0x0
+#define BTR_HIGH			0x1
+#define CTR_LOW				0x2
+#define CTR_HIGH			0x3
+#define TER				0x4
+#define LLR				0x5
+#define ADDR_SHIFT			8
+#define GCRR				BIT(2)
+#define SRWO				BIT(0)
+#define MTL_EST_GCL_DATA		0x00000c84
+
+#define MTL_RXP_CONTROL_STATUS		0x00000ca0
+#define RXPI				BIT(31)
+#define NPE				GENMASK(23, 16)
+#define NVE				GENMASK(7, 0)
+#define MTL_RXP_IACC_CTRL_STATUS	0x00000cb0
+#define STARTBUSY			BIT(31)
+#define RXPEIEC				GENMASK(22, 21)
+#define RXPEIEE				BIT(20)
+#define WRRDN				BIT(16)
+#define ADDR				GENMASK(15, 0)
+#define MTL_RXP_IACC_DATA		0x00000cb4
+#define MTL_ECC_CONTROL			0x00000cc0
+#define TSOEE				BIT(4)
+#define MRXPEE				BIT(3)
+#define MESTEE				BIT(2)
+#define MRXEE				BIT(1)
+#define MTXEE				BIT(0)
+
+#define MTL_SAFETY_INT_STATUS		0x00000cc4
+#define MCSIS				BIT(31)
+#define MEUIS				BIT(1)
+#define MECIS				BIT(0)
+#define MTL_ECC_INT_ENABLE		0x00000cc8
+#define RPCEIE				BIT(12)
+#define ECEIE				BIT(8)
+#define RXCEIE				BIT(4)
+#define TXCEIE				BIT(0)
+#define MTL_ECC_INT_STATUS		0x00000ccc
+#define MTL_DPP_CONTROL			0x00000ce0
+#define EPSI				BIT(2)
+#define OPE				BIT(1)
+#define EDPP				BIT(0)
+
+#define DMA_SAFETY_INT_STATUS		0x00001080
+#define MSUIS				BIT(29)
+#define MSCIS				BIT(28)
+#define DEUIS				BIT(1)
+#define DECIS				BIT(0)
+#define DMA_ECC_INT_ENABLE		0x00001084
+#define TCEIE				BIT(0)
+#define DMA_ECC_INT_STATUS		0x00001088
+
+/* EQoS version 5.xx VLAN Tag Filter Fail Packets Queuing */
+#define GMAC_RXQ_CTRL4			0x00000094
+#define GMAC_RXQCTRL_VFFQ_MASK		GENMASK(19, 17)
+#define GMAC_RXQCTRL_VFFQ_SHIFT		17
+#define GMAC_RXQCTRL_VFFQE		BIT(16)
+
+int dwmac5_rxp_config(void  *ioaddr, struct stmmac_tc_entry *entries,
+		      unsigned int count);
+int dwmac5_flex_pps_config(void  *ioaddr, int index,
+			   struct stmmac_pps_cfg *cfg, bool enable,
+			   uint32_t sub_second_inc, uint32_t systime_flags);
+int dwmac5_est_configure(void  *ioaddr, struct stmmac_est *cfg,
+			 unsigned int ptp_rate);
+void dwmac5_fpe_configure(void  *ioaddr, uint32_t num_txq, uint32_t num_rxq,
+			  bool enable);
+
+#endif /* __DWMAC5_H__ */
diff --git a/drivers/net/stmmac/hwif.h b/drivers/net/stmmac/hwif.h
new file mode 100644
index 0000000..6d623aa
--- /dev/null
+++ b/drivers/net/stmmac/hwif.h
@@ -0,0 +1,633 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+// stmmac HW Interface Callbacks
+
+#ifndef __STMMAC_HWIF_H__
+#define __STMMAC_HWIF_H__
+
+#include <rte_ethdev.h>
+#include "stmmac.h"
+
+typedef unsigned long long  dma_addr_t;
+
+#define stmmac_do_void_callback(__priv, __module, __cname,  __arg0, __args...) \
+({ \
+	int __result = -EINVAL; \
+	if ((__priv)->hw->__module && (__priv)->hw->__module->__cname) { \
+		(__priv)->hw->__module->__cname((__arg0), ##__args); \
+		__result = 0; \
+	} \
+	__result; \
+})
+#define stmmac_do_callback(__priv, __module, __cname,  __arg0, __args...) \
+({ \
+	int __result = -EINVAL; \
+	if ((__priv)->hw->__module && (__priv)->hw->__module->__cname) \
+		__result = (__priv)->hw->__module->__cname((__arg0), ##__args); \
+	__result; \
+})
+
+struct stmmac_extra_stats;
+struct stmmac_safety_stats;
+struct dma_desc;
+struct dma_extended_desc;
+struct dma_edesc;
+
+/* Descriptors helpers */
+struct stmmac_desc_ops {
+	/* DMA RX descriptor ring initialization */
+	void (*init_rx_desc)(struct dma_desc *p, int disable_rx_ic, int mode,
+			int end, int bfsize);
+	/* DMA TX descriptor ring initialization */
+	void (*init_tx_desc)(struct dma_desc *p, int mode, int end);
+	/* Invoked by the xmit function to prepare the tx descriptor */
+	void (*prepare_tx_desc)(struct dma_desc *p, int is_fs, int len,
+			bool csum_flag, int mode, bool tx_own, bool ls,
+			unsigned int tot_pkt_len);
+	void (*prepare_tso_tx_desc)(struct dma_desc *p, int is_fs, int len1,
+			int len2, bool tx_own, bool ls, unsigned int tcphdrlen,
+			unsigned int tcppayloadlen);
+	/* Set/get the owner of the descriptor */
+	void (*set_tx_owner)(struct dma_desc *p);
+	int (*get_tx_owner)(struct dma_desc *p);
+	/* Clean the tx descriptor as soon as the tx irq is received */
+	void (*release_tx_desc)(struct dma_desc *p, int mode);
+	/* Clear interrupt on tx frame completion. When this bit is
+	 * set an interrupt happens as soon as the frame is transmitted */
+	void (*set_tx_ic)(struct dma_desc *p);
+	/* Last tx segment reports the transmit status */
+	int (*get_tx_ls)(struct dma_desc *p);
+	/* Return the transmit status looking at the TDES1 */
+	int (*tx_status)(struct rte_eth_stats *x,
+				       struct dma_desc *pr);
+	/* Get the buffer size from the descriptor */
+	int (*get_tx_len)(struct dma_desc *p);
+	/* Handle extra events on specific interrupts hw dependent */
+	void (*set_rx_owner)(struct dma_desc *p, int disable_rx_ic);
+	/* Get the receive frame size */
+	int (*get_rx_frame_len)(struct dma_desc *p, int rx_coe_type);
+	/* Return the reception status looking at the RDES1 */
+	int (*rx_status)(struct rte_eth_stats *x,  struct dma_desc *p);
+	void (*rx_extended_status)(void *data, struct stmmac_extra_stats *x,
+			struct dma_extended_desc *p);
+	/* Set tx timestamp enable bit */
+	void (*enable_tx_timestamp) (struct dma_desc *p);
+	/* get tx timestamp status */
+	int (*get_tx_timestamp_status) (struct dma_desc *p);
+	/* get timestamp value */
+	void (*get_timestamp)(void *desc, uint32_t ats, uint64_t *ts);
+	/* get rx timestamp status */
+	int (*get_rx_timestamp_status)(void *desc, void *next_desc, uint32_t ats);
+	/* Display ring */
+	void (*display_ring)(void *head, unsigned int size, bool rx,
+			     dma_addr_t dma_rx_phy, unsigned int desc_size);
+	/* set MSS via context descriptor */
+	void (*set_mss)(struct dma_desc *p, unsigned int mss);
+	/* get descriptor skbuff address */
+	void (*get_addr)(struct dma_desc *p, unsigned int *addr);
+	/* set descriptor skbuff address */
+	void (*set_addr)(struct dma_desc *p, dma_addr_t addr);
+	/* clear descriptor */
+	void (*clear)(struct dma_desc *p);
+	/* RSS */
+	//int (*get_rx_hash)(struct dma_desc *p, uint32_t *hash,
+	//		   enum pkt_hash_types *type);
+	void (*get_rx_header_len)(struct dma_desc *p, unsigned int *len);
+	void (*set_sec_addr)(struct dma_desc *p, dma_addr_t addr, bool buf2_valid);
+	void (*set_sarc)(struct dma_desc *p, uint32_t sarc_type);
+	void (*set_vlan_tag)(struct dma_desc *p, uint16_t tag, uint16_t inner_tag,
+			     uint32_t inner_type);
+	void (*set_vlan)(struct dma_desc *p, uint32_t type);
+	void (*set_tbs)(struct dma_edesc *p, uint32_t sec, uint32_t nsec);
+};
+
+#define stmmac_init_rx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, init_rx_desc, __args)
+#define stmmac_init_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, init_tx_desc, __args)
+#define stmmac_prepare_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, prepare_tx_desc, __args)
+#define stmmac_prepare_tso_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, prepare_tso_tx_desc, __args)
+#define stmmac_set_tx_owner(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tx_owner, __args)
+#define stmmac_get_tx_owner(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_owner, __args)
+#define stmmac_release_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, release_tx_desc, __args)
+#define stmmac_set_tx_ic(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tx_ic, __args)
+#define stmmac_get_tx_ls(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_ls, __args)
+#define stmmac_tx_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, tx_status, __args)
+#define stmmac_get_tx_len(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_len, __args)
+#define stmmac_set_rx_owner(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_rx_owner, __args)
+#define stmmac_get_rx_frame_len(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_frame_len, __args)
+#define stmmac_rx_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, rx_status, __args)
+#define stmmac_rx_extended_status(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, rx_extended_status, __args)
+#define stmmac_enable_tx_timestamp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, enable_tx_timestamp, __args)
+#define stmmac_get_tx_timestamp_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_timestamp_status, __args)
+#define stmmac_get_timestamp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_timestamp, __args)
+#define stmmac_get_rx_timestamp_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_timestamp_status, __args)
+#define stmmac_display_ring(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, display_ring, __args)
+#define stmmac_set_mss(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_mss, __args)
+#define stmmac_get_desc_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_addr, __args)
+#define stmmac_set_desc_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_addr, __args)
+#define stmmac_clear_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, clear, __args)
+#define stmmac_get_rx_hash(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_hash, __args)
+#define stmmac_get_rx_header_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_rx_header_len, __args)
+#define stmmac_set_desc_sec_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_sec_addr, __args)
+#define stmmac_set_desc_sarc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_sarc, __args)
+#define stmmac_set_desc_vlan_tag(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_vlan_tag, __args)
+#define stmmac_set_desc_vlan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_vlan, __args)
+#define stmmac_set_desc_tbs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tbs, __args)
+
+struct stmmac_dma_cfg;
+struct dma_features;
+
+/* Specific DMA helpers */
+struct stmmac_dma_ops {
+	/* DMA core initialization */
+	int (*reset)(void  *ioaddr);
+	void (*init)(void  *ioaddr, struct stmmac_dma_cfg *dma_cfg);
+	void (*init_chan)(void  *ioaddr,
+			  struct stmmac_dma_cfg *dma_cfg, uint32_t chan);
+	void (*init_rx_chan)(void  *ioaddr,
+			     struct stmmac_dma_cfg *dma_cfg,
+			     dma_addr_t phy, uint32_t chan);
+	void (*init_tx_chan)(void  *ioaddr,
+			     struct stmmac_dma_cfg *dma_cfg,
+			     dma_addr_t phy, uint32_t chan);
+	/* Configure the AXI Bus Mode Register */
+	void (*axi)(void  *ioaddr, struct stmmac_axi *axi);
+	/* Dump DMA registers */
+	void (*dump_regs)(void  *ioaddr, uint32_t *reg_space);
+	void (*dma_rx_mode)(void  *ioaddr, int mode, uint32_t channel,
+			    int fifosz, uint8_t qmode);
+	void (*dma_tx_mode)(void  *ioaddr, int mode, uint32_t channel,
+			    int fifosz, uint8_t qmode);
+	/* To track extra statistic (if supported) */
+	void (*dma_diagnostic_fr) (void *data, struct stmmac_extra_stats *x,
+				   void  *ioaddr);
+	void (*enable_dma_transmission) (void  *ioaddr);
+	void (*enable_dma_irq)(void  *ioaddr, uint32_t chan,
+			       bool rx, bool tx);
+	void (*disable_dma_irq)(void  *ioaddr, uint32_t chan,
+				bool rx, bool tx);
+	void (*start_tx)(void  *ioaddr, uint32_t chan);
+	void (*stop_tx)(void  *ioaddr, uint32_t chan);
+	void (*start_rx)(void  *ioaddr, uint32_t chan);
+	void (*stop_rx)(void  *ioaddr, uint32_t chan);
+	int (*dma_interrupt) (void  *ioaddr,
+			      struct stmmac_extra_stats *x, uint32_t chan);
+	/* If supported then get the optional core features */
+	void (*get_hw_feature)(void  *ioaddr,
+			       struct dma_features *dma_cap);
+	/* Program the HW RX Watchdog */
+	void (*rx_watchdog)(void  *ioaddr, uint32_t riwt, uint32_t number_chan);
+	void (*set_tx_ring_len)(void  *ioaddr, uint32_t len, uint32_t chan);
+	void (*set_rx_ring_len)(void  *ioaddr, uint32_t len, uint32_t chan);
+	void (*set_rx_tail_ptr)(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+	void (*set_tx_tail_ptr)(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+	void (*enable_tso)(void  *ioaddr, bool en, uint32_t chan);
+	void (*qmode)(void  *ioaddr, uint32_t channel, uint8_t qmode);
+	void (*set_bfsize)(void  *ioaddr, int bfsize, uint32_t chan);
+	void (*enable_sph)(void  *ioaddr, bool en, uint32_t chan);
+	int (*enable_tbs)(void  *ioaddr, bool en, uint32_t chan);
+};
+
+#define stmmac_reset(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, reset, __args)
+#define stmmac_dma_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init, __args)
+#define stmmac_init_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_chan, __args)
+#define stmmac_init_rx_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_rx_chan, __args)
+#define stmmac_init_tx_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_tx_chan, __args)
+#define stmmac_axi(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, axi, __args)
+#define stmmac_dump_dma_regs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dump_regs, __args)
+#define stmmac_dma_rx_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_rx_mode, __args)
+#define stmmac_dma_tx_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_tx_mode, __args)
+#define stmmac_dma_diagnostic_fr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_diagnostic_fr, __args)
+#define stmmac_enable_dma_transmission(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_dma_transmission, __args)
+#define stmmac_enable_dma_irq(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_dma_irq, __args)
+#define stmmac_disable_dma_irq(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, disable_dma_irq, __args)
+#define stmmac_start_tx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, start_tx, __args)
+#define stmmac_stop_tx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, stop_tx, __args)
+#define stmmac_start_rx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, start_rx, __args)
+#define stmmac_stop_rx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, stop_rx, __args)
+#define stmmac_dma_interrupt_status(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, dma_interrupt, __args)
+#define stmmac_get_hw_feature(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, get_hw_feature, __args)
+#define stmmac_rx_watchdog(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, rx_watchdog, __args)
+#define stmmac_set_tx_ring_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_tx_ring_len, __args)
+#define stmmac_set_rx_ring_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_rx_ring_len, __args)
+#define stmmac_set_rx_tail_ptr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_rx_tail_ptr, __args)
+#define stmmac_set_tx_tail_ptr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_tx_tail_ptr, __args)
+#define stmmac_enable_tso(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_tso, __args)
+#define stmmac_dma_qmode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, qmode, __args)
+#define stmmac_set_dma_bfsize(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_bfsize, __args)
+#define stmmac_enable_sph(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_sph, __args)
+#define stmmac_enable_tbs(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, enable_tbs, __args)
+
+struct mac_device_info;
+struct stmmac_private;
+struct rgmii_adv;
+struct stmmac_safety_stats;
+struct stmmac_tc_entry;
+struct stmmac_pps_cfg;
+struct stmmac_rss;
+struct stmmac_est;
+
+/* Helpers to program the MAC core */
+struct stmmac_ops {
+	/* MAC core initialization */
+	void (*core_init)(struct mac_device_info *hw, struct stmmac_private *dev);
+	/* Enable the MAC RX/TX */
+	void (*set_mac)(void  *ioaddr, bool enable);
+	/* Enable and verify that the IPC module is supported */
+	int (*rx_ipc)(struct mac_device_info *hw);
+	/* Enable RX Queues */
+	void (*rx_queue_enable)(struct mac_device_info *hw, uint8_t mode, uint32_t queue);
+	/* RX Queues Priority */
+	void (*rx_queue_prio)(struct mac_device_info *hw, uint32_t prio, uint32_t queue);
+	/* TX Queues Priority */
+	void (*tx_queue_prio)(struct mac_device_info *hw, uint32_t prio, uint32_t queue);
+	/* RX Queues Routing */
+	void (*rx_queue_routing)(struct mac_device_info *hw, uint8_t packet,
+				 uint32_t queue);
+	/* Program RX Algorithms */
+	void (*prog_mtl_rx_algorithms)(struct mac_device_info *hw, uint32_t rx_alg);
+	/* Program TX Algorithms */
+	void (*prog_mtl_tx_algorithms)(struct mac_device_info *hw, uint32_t tx_alg);
+	/* Set MTL TX queues weight */
+	void (*set_mtl_tx_queue_weight)(struct mac_device_info *hw,
+					uint32_t weight, uint32_t queue);
+	/* RX MTL queue to RX dma mapping */
+	void (*map_mtl_to_dma)(struct mac_device_info *hw, uint32_t queue, uint32_t chan);
+	/* Configure AV Algorithm */
+	void (*config_cbs)(struct mac_device_info *hw, uint32_t send_slope,
+			   uint32_t idle_slope, uint32_t high_credit, uint32_t low_credit,
+			   uint32_t queue);
+	/* Dump MAC registers */
+	void (*dump_regs)(struct mac_device_info *hw, uint32_t *reg_space);
+	/* Handle extra events on specific interrupts hw dependent */
+	int (*host_irq_status)(struct mac_device_info *hw,
+			       struct stmmac_extra_stats *x);
+	/* Handle MTL interrupts */
+	int (*host_mtl_irq_status)(struct mac_device_info *hw, uint32_t chan);
+	/* Multicast filter setting */
+	void (*set_filter)(struct mac_device_info *hw, struct stmmac_private *dev);
+	/* Flow control setting */
+	void (*flow_ctrl)(struct mac_device_info *hw, unsigned int duplex,
+			  unsigned int fc, unsigned int pause_time, uint32_t tx_cnt);
+	/* Set power management mode (e.g. magic frame) */
+	void (*pmt)(struct mac_device_info *hw, unsigned long mode);
+	/* Set/Get Unicast MAC addresses */
+	void (*set_umac_addr)(struct mac_device_info *hw, unsigned char *addr,
+			      unsigned int reg_n);
+	void (*get_umac_addr)(struct mac_device_info *hw, unsigned char *addr,
+			      unsigned int reg_n);
+	void (*set_eee_mode)(struct mac_device_info *hw,
+			     bool en_tx_lpi_clockgating);
+	void (*reset_eee_mode)(struct mac_device_info *hw);
+	void (*set_eee_timer)(struct mac_device_info *hw, int ls, int tw);
+	void (*set_eee_pls)(struct mac_device_info *hw, int link);
+	void (*debug)(void  *ioaddr, struct stmmac_extra_stats *x,
+		      uint32_t rx_queues, uint32_t tx_queues);
+	/* PCS calls */
+	void (*pcs_ctrl_ane)(void  *ioaddr, bool ane, bool srgmi_ral,
+			     bool loopback);
+	void (*pcs_rane)(void  *ioaddr, bool restart);
+	void (*pcs_get_adv_lp)(void  *ioaddr, struct rgmii_adv *adv);
+	/* Safety Features */
+	int (*safety_feat_config)(void  *ioaddr, unsigned int asp);
+	int (*safety_feat_irq_status)(struct stmmac_private *ndev,
+			void  *ioaddr, unsigned int asp,
+			struct stmmac_safety_stats *stats);
+	int (*safety_feat_dump)(struct stmmac_safety_stats *stats,
+			int index, unsigned long *count, const char **desc);
+	/* Flexible RX Parser */
+	int (*rxp_config)(void  *ioaddr, struct stmmac_tc_entry *entries,
+			  unsigned int count);
+	/* Flexible PPS */
+	int (*flex_pps_config)(void  *ioaddr, int index,
+			       struct stmmac_pps_cfg *cfg, bool enable,
+			       uint32_t sub_second_inc, uint32_t systime_flags);
+	/* Loopback for selftests */
+	void (*set_mac_loopback)(void  *ioaddr, bool enable);
+	/* RSS */
+	int (*rss_configure)(struct mac_device_info *hw,
+			     struct stmmac_rss *cfg, uint32_t num_rxq);
+	/* VLAN */
+	void (*update_vlan_hash)(struct mac_device_info *hw, uint32_t hash,
+				 uint16_t perfect_match, bool is_double);
+	void (*enable_vlan)(struct mac_device_info *hw, uint32_t type);
+	int (*add_hw_vlan_rx_fltr)(struct stmmac_private *dev,
+				   struct mac_device_info *hw,
+				   uint16_t proto, uint16_t vid);
+	int (*del_hw_vlan_rx_fltr)(struct stmmac_private *dev,
+				   struct mac_device_info *hw,
+				   uint16_t proto, uint16_t vid);
+	void (*restore_hw_vlan_rx_fltr)(struct stmmac_private *dev,
+					struct mac_device_info *hw);
+	/* TX Timestamp */
+	int (*get_mac_tx_timestamp)(struct mac_device_info *hw, uint64_t *ts);
+	/* Source Address Insertion / Replacement */
+	void (*sarc_configure)(void  *ioaddr, int val);
+	/* Filtering */
+	int (*config_l3_filter)(struct mac_device_info *hw, uint32_t filter_no,
+				bool en, bool ipv6, bool sa, bool inv,
+				uint32_t match);
+	int (*config_l4_filter)(struct mac_device_info *hw, uint32_t filter_no,
+				bool en, bool udp, bool sa, bool inv,
+				uint32_t match);
+	void (*set_arp_offload)(struct mac_device_info *hw, bool en, uint32_t addr);
+	int (*est_configure)(void  *ioaddr, struct stmmac_est *cfg,
+			     unsigned int ptp_rate);
+	void (*fpe_configure)(void  *ioaddr, uint32_t num_txq, uint32_t num_rxq,
+			      bool enable);
+};
+
+#define stmmac_core_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, core_init, __args)
+#define stmmac_mac_set(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mac, __args)
+#define stmmac_rx_ipc(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rx_ipc, __args)
+#define stmmac_rx_queue_enable(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_enable, __args)
+#define stmmac_rx_queue_prio(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_prio, __args)
+#define stmmac_tx_queue_prio(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, tx_queue_prio, __args)
+#define stmmac_rx_queue_routing(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_routing, __args)
+#define stmmac_prog_mtl_rx_algorithms(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, prog_mtl_rx_algorithms, __args)
+#define stmmac_prog_mtl_tx_algorithms(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, prog_mtl_tx_algorithms, __args)
+#define stmmac_set_mtl_tx_queue_weight(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mtl_tx_queue_weight, __args)
+#define stmmac_map_mtl_to_dma(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, map_mtl_to_dma, __args)
+#define stmmac_config_cbs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, config_cbs, __args)
+#define stmmac_dump_mac_regs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, dump_regs, __args)
+#define stmmac_host_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, host_irq_status, __args)
+#define stmmac_host_mtl_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, host_mtl_irq_status, __args)
+#define stmmac_set_filter(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_filter, __args)
+#define stmmac_flow_ctrl(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, flow_ctrl, __args)
+#define stmmac_pmt(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pmt, __args)
+#define stmmac_set_umac_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_umac_addr, __args)
+#define stmmac_get_umac_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, get_umac_addr, __args)
+#define stmmac_set_eee_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_mode, __args)
+#define stmmac_reset_eee_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, reset_eee_mode, __args)
+#define stmmac_set_eee_timer(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_timer, __args)
+#define stmmac_set_eee_pls(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_pls, __args)
+#define stmmac_mac_debug(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, debug, __args)
+#define stmmac_pcs_ctrl_ane(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_ctrl_ane, __args)
+#define stmmac_pcs_rane(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_rane, __args)
+#define stmmac_pcs_get_adv_lp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_get_adv_lp, __args)
+#define stmmac_safety_feat_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_config, __args)
+#define stmmac_safety_feat_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_irq_status, __args)
+#define stmmac_safety_feat_dump(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_dump, __args)
+#define stmmac_rxp_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rxp_config, __args)
+#define stmmac_flex_pps_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, flex_pps_config, __args)
+#define stmmac_set_mac_loopback(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mac_loopback, __args)
+#define stmmac_rss_configure(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rss_configure, __args)
+#define stmmac_update_vlan_hash(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, update_vlan_hash, __args)
+#define stmmac_enable_vlan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, enable_vlan, __args)
+#define stmmac_add_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, add_hw_vlan_rx_fltr, __args)
+#define stmmac_del_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, del_hw_vlan_rx_fltr, __args)
+#define stmmac_restore_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, restore_hw_vlan_rx_fltr, __args)
+#define stmmac_get_mac_tx_timestamp(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, get_mac_tx_timestamp, __args)
+#define stmmac_sarc_configure(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, sarc_configure, __args)
+#define stmmac_config_l3_filter(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, config_l3_filter, __args)
+#define stmmac_config_l4_filter(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, config_l4_filter, __args)
+#define stmmac_set_arp_offload(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_arp_offload, __args)
+#define stmmac_est_configure(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, est_configure, __args)
+#define stmmac_fpe_configure(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, fpe_configure, __args)
+
+/* PTP and HW Timer helpers */
+struct stmmac_hwtimestamp {
+	void (*config_hw_tstamping) (void  *ioaddr, uint32_t data);
+	void (*config_sub_second_increment)(void  *ioaddr, uint32_t ptp_clock,
+					   int gmac4, uint32_t *ssinc);
+	int (*init_systime) (void  *ioaddr, uint32_t sec, uint32_t nsec);
+	int (*config_addend) (void  *ioaddr, uint32_t addend);
+	int (*adjust_systime) (void  *ioaddr, uint32_t sec, uint32_t nsec,
+			       int add_sub, int gmac4);
+	void (*get_systime) (void  *ioaddr, uint64_t *systime);
+};
+
+#define stmmac_config_hw_tstamping(__priv, __args...) \
+	stmmac_do_void_callback(__priv, ptp, config_hw_tstamping, __args)
+#define stmmac_config_sub_second_increment(__priv, __args...) \
+	stmmac_do_void_callback(__priv, ptp, config_sub_second_increment, __args)
+#define stmmac_init_systime(__priv, __args...) \
+	stmmac_do_callback(__priv, ptp, init_systime, __args)
+#define stmmac_config_addend(__priv, __args...) \
+	stmmac_do_callback(__priv, ptp, config_addend, __args)
+#define stmmac_adjust_systime(__priv, __args...) \
+	stmmac_do_callback(__priv, ptp, adjust_systime, __args)
+#define stmmac_get_systime(__priv, __args...) \
+	stmmac_do_void_callback(__priv, ptp, get_systime, __args)
+
+/* Helpers to manage the descriptors for chain and ring modes */
+struct stmmac_mode_ops {
+	void (*init) (void *des, dma_addr_t phy_addr, unsigned int size,
+		      unsigned int extend_desc);
+	unsigned int (*is_jumbo_frm) (int len, int ehn_desc);
+	//int (*jumbo_frm)(void *priv, struct sk_buff *skb, int csum);
+	int (*set_16kib_bfsize)(int mtu);
+	void (*init_desc3)(struct dma_desc *p);
+	void (*refill_desc3) (void *priv, struct dma_desc *p);
+	void (*clean_desc3) (void *priv, struct dma_desc *p);
+};
+
+#define stmmac_mode_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, init, __args)
+#define stmmac_is_jumbo_frm(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, is_jumbo_frm, __args)
+#define stmmac_jumbo_frm(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, jumbo_frm, __args)
+#define stmmac_set_16kib_bfsize(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, set_16kib_bfsize, __args)
+#define stmmac_init_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, init_desc3, __args)
+#define stmmac_refill_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, refill_desc3, __args)
+#define stmmac_clean_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, clean_desc3, __args)
+
+struct stmmac_priv;
+struct tc_cls_uint32_t_offload;
+struct tc_cbs_qopt_offload;
+struct flow_cls_offload;
+struct tc_taprio_qopt_offload;
+struct tc_etf_qopt_offload;
+
+struct stmmac_tc_ops {
+	int (*init)(struct stmmac_priv *priv);
+	int (*setup_cls_uint32_t)(struct stmmac_priv *priv,
+			     struct tc_cls_uint32_t_offload *cls);
+	int (*setup_cbs)(struct stmmac_priv *priv,
+			 struct tc_cbs_qopt_offload *qopt);
+	int (*setup_cls)(struct stmmac_priv *priv,
+			 struct flow_cls_offload *cls);
+	int (*setup_taprio)(struct stmmac_priv *priv,
+			    struct tc_taprio_qopt_offload *qopt);
+	int (*setup_etf)(struct stmmac_priv *priv,
+			 struct tc_etf_qopt_offload *qopt);
+};
+
+#define stmmac_tc_init(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, init, __args)
+#define stmmac_tc_setup_cls_uint32_t(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_cls_uint32_t, __args)
+#define stmmac_tc_setup_cbs(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_cbs, __args)
+#define stmmac_tc_setup_cls(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_cls, __args)
+#define stmmac_tc_setup_taprio(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_taprio, __args)
+#define stmmac_tc_setup_etf(__priv, __args...) \
+	stmmac_do_callback(__priv, tc, setup_etf, __args)
+
+struct stmmac_counters;
+
+struct stmmac_mmc_ops {
+	void (*ctrl)(void  *ioaddr, unsigned int mode);
+	void (*intr_all_mask)(void  *ioaddr);
+	void (*read)(void  *ioaddr, struct stmmac_counters *mmc);
+};
+
+#define stmmac_mmc_ctrl(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mmc, ctrl, __args)
+#define stmmac_mmc_intr_all_mask(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mmc, intr_all_mask, __args)
+#define stmmac_mmc_read(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mmc, read, __args)
+
+/* XPCS callbacks */
+#define stmmac_xpcs_validate(__priv, __args...) \
+	stmmac_do_callback(__priv, xpcs, validate, __args)
+#define stmmac_xpcs_config(__priv, __args...) \
+	stmmac_do_callback(__priv, xpcs, config, __args)
+#define stmmac_xpcs_get_state(__priv, __args...) \
+	stmmac_do_callback(__priv, xpcs, get_state, __args)
+#define stmmac_xpcs_link_up(__priv, __args...) \
+	stmmac_do_callback(__priv, xpcs, link_up, __args)
+#define stmmac_xpcs_probe(__priv, __args...) \
+	stmmac_do_callback(__priv, xpcs, probe, __args)
+
+struct stmmac_regs_off {
+	uint32_t ptp_off;
+	uint32_t mmc_off;
+};
+
+extern const struct stmmac_ops dwmac100_ops;
+extern const struct stmmac_dma_ops dwmac100_dma_ops;
+extern const struct stmmac_ops dwmac1000_ops;
+extern const struct stmmac_dma_ops dwmac1000_dma_ops;
+extern const struct stmmac_ops dwmac4_ops;
+extern const struct stmmac_dma_ops dwmac4_dma_ops;
+extern const struct stmmac_ops dwmac410_ops;
+extern const struct stmmac_dma_ops dwmac410_dma_ops;
+extern const struct stmmac_ops dwmac510_ops;
+extern const struct stmmac_tc_ops dwmac510_tc_ops;
+extern const struct stmmac_ops dwxgmac210_ops;
+extern const struct stmmac_ops dwxlgmac2_ops;
+extern const struct stmmac_dma_ops dwxgmac210_dma_ops;
+extern const struct stmmac_desc_ops dwxgmac210_desc_ops;
+extern const struct stmmac_mmc_ops dwmac_mmc_ops;
+extern const struct stmmac_mmc_ops dwxgmac_mmc_ops;
+
+#define GMAC_VERSION		0x00000020	/* GMAC CORE Version */
+#define GMAC4_VERSION		0x00000110	/* GMAC4+ CORE Version */
+
+#endif /* __STMMAC_HWIF_H__ */
diff --git a/drivers/net/stmmac/meson.build b/drivers/net/stmmac/meson.build
new file mode 100644
index 0000000..345fd10
--- /dev/null
+++ b/drivers/net/stmmac/meson.build
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright 2021 NXP
+
+if not is_linux
+    build = false
+    reason = 'only supported on linux'
+endif
+
+sources = files(
+        'stmmac_ethdev.c',
+        'stmmac_uio.c',
+        'stmmac_rxtx.c',
+        'dwmac4_lib.c',
+        'dwmac4_core.c',
+        'dwmac4_dma.c',
+        'dwmac4_descs.c'
+)
diff --git a/drivers/net/stmmac/mmc.h b/drivers/net/stmmac/mmc.h
new file mode 100644
index 0000000..28b62c3
--- /dev/null
+++ b/drivers/net/stmmac/mmc.h
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __MMC_H__
+#define __MMC_H__
+
+/* MMC control register */
+/* When set, all counter are reset */
+#define MMC_CNTRL_COUNTER_RESET		0x1
+/* When set, do not roll over zero after reaching the max value*/
+#define MMC_CNTRL_COUNTER_STOP_ROLLOVER	0x2
+#define MMC_CNTRL_RESET_ON_READ		0x4	/* Reset after reading */
+#define MMC_CNTRL_COUNTER_FREEZER	0x8	/* Freeze counter values to the
+						 * current value.*/
+#define MMC_CNTRL_PRESET		0x10
+#define MMC_CNTRL_FULL_HALF_PRESET	0x20
+
+#define MMC_GMAC4_OFFSET		0x700
+#define MMC_GMAC3_X_OFFSET		0x100
+#define MMC_XGMAC_OFFSET		0x800
+
+struct stmmac_counters {
+	unsigned int mmc_tx_octetcount_gb;
+	unsigned int mmc_tx_framecount_gb;
+	unsigned int mmc_tx_broadcastframe_g;
+	unsigned int mmc_tx_multicastframe_g;
+	unsigned int mmc_tx_64_octets_gb;
+	unsigned int mmc_tx_65_to_127_octets_gb;
+	unsigned int mmc_tx_128_to_255_octets_gb;
+	unsigned int mmc_tx_256_to_511_octets_gb;
+	unsigned int mmc_tx_512_to_1023_octets_gb;
+	unsigned int mmc_tx_1024_to_max_octets_gb;
+	unsigned int mmc_tx_unicast_gb;
+	unsigned int mmc_tx_multicast_gb;
+	unsigned int mmc_tx_broadcast_gb;
+	unsigned int mmc_tx_underflow_error;
+	unsigned int mmc_tx_singlecol_g;
+	unsigned int mmc_tx_multicol_g;
+	unsigned int mmc_tx_deferred;
+	unsigned int mmc_tx_latecol;
+	unsigned int mmc_tx_exesscol;
+	unsigned int mmc_tx_carrier_error;
+	unsigned int mmc_tx_octetcount_g;
+	unsigned int mmc_tx_framecount_g;
+	unsigned int mmc_tx_excessdef;
+	unsigned int mmc_tx_pause_frame;
+	unsigned int mmc_tx_vlan_frame_g;
+
+	/* MMC RX counter registers */
+	unsigned int mmc_rx_framecount_gb;
+	unsigned int mmc_rx_octetcount_gb;
+	unsigned int mmc_rx_octetcount_g;
+	unsigned int mmc_rx_broadcastframe_g;
+	unsigned int mmc_rx_multicastframe_g;
+	unsigned int mmc_rx_crc_error;
+	unsigned int mmc_rx_align_error;
+	unsigned int mmc_rx_run_error;
+	unsigned int mmc_rx_jabber_error;
+	unsigned int mmc_rx_undersize_g;
+	unsigned int mmc_rx_oversize_g;
+	unsigned int mmc_rx_64_octets_gb;
+	unsigned int mmc_rx_65_to_127_octets_gb;
+	unsigned int mmc_rx_128_to_255_octets_gb;
+	unsigned int mmc_rx_256_to_511_octets_gb;
+	unsigned int mmc_rx_512_to_1023_octets_gb;
+	unsigned int mmc_rx_1024_to_max_octets_gb;
+	unsigned int mmc_rx_unicast_g;
+	unsigned int mmc_rx_length_error;
+	unsigned int mmc_rx_autofrangetype;
+	unsigned int mmc_rx_pause_frames;
+	unsigned int mmc_rx_fifo_overflow;
+	unsigned int mmc_rx_vlan_frames_gb;
+	unsigned int mmc_rx_watchdog_error;
+	/* IPC */
+	unsigned int mmc_rx_ipc_intr_mask;
+	unsigned int mmc_rx_ipc_intr;
+	/* IPv4 */
+	unsigned int mmc_rx_ipv4_gd;
+	unsigned int mmc_rx_ipv4_hderr;
+	unsigned int mmc_rx_ipv4_nopay;
+	unsigned int mmc_rx_ipv4_frag;
+	unsigned int mmc_rx_ipv4_udsbl;
+
+	unsigned int mmc_rx_ipv4_gd_octets;
+	unsigned int mmc_rx_ipv4_hderr_octets;
+	unsigned int mmc_rx_ipv4_nopay_octets;
+	unsigned int mmc_rx_ipv4_frag_octets;
+	unsigned int mmc_rx_ipv4_udsbl_octets;
+
+	/* IPV6 */
+	unsigned int mmc_rx_ipv6_gd_octets;
+	unsigned int mmc_rx_ipv6_hderr_octets;
+	unsigned int mmc_rx_ipv6_nopay_octets;
+
+	unsigned int mmc_rx_ipv6_gd;
+	unsigned int mmc_rx_ipv6_hderr;
+	unsigned int mmc_rx_ipv6_nopay;
+
+	/* Protocols */
+	unsigned int mmc_rx_udp_gd;
+	unsigned int mmc_rx_udp_err;
+	unsigned int mmc_rx_tcp_gd;
+	unsigned int mmc_rx_tcp_err;
+	unsigned int mmc_rx_icmp_gd;
+	unsigned int mmc_rx_icmp_err;
+
+	unsigned int mmc_rx_udp_gd_octets;
+	unsigned int mmc_rx_udp_err_octets;
+	unsigned int mmc_rx_tcp_gd_octets;
+	unsigned int mmc_rx_tcp_err_octets;
+	unsigned int mmc_rx_icmp_gd_octets;
+	unsigned int mmc_rx_icmp_err_octets;
+
+	/* FPE */
+	unsigned int mmc_tx_fpe_fragment_cntr;
+	unsigned int mmc_tx_hold_req_cntr;
+	unsigned int mmc_rx_packet_assembly_err_cntr;
+	unsigned int mmc_rx_packet_smd_err_cntr;
+	unsigned int mmc_rx_packet_assembly_ok_cntr;
+	unsigned int mmc_rx_fpe_fragment_cntr;
+};
+
+#endif /* __MMC_H__ */
diff --git a/drivers/net/stmmac/stmmac.h b/drivers/net/stmmac/stmmac.h
new file mode 100644
index 0000000..7a9f1e6
--- /dev/null
+++ b/drivers/net/stmmac/stmmac.h
@@ -0,0 +1,179 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __STMMAC_PLATFORM_DATA
+#define __STMMAC_PLATFORM_DATA
+
+#define MTL_MAX_RX_QUEUES	8
+#define MTL_MAX_TX_QUEUES	8
+#define STMMAC_CH_MAX		8
+
+#define STMMAC_RX_COE_NONE	0
+#define STMMAC_RX_COE_TYPE1	1
+#define STMMAC_RX_COE_TYPE2	2
+
+/* Define the macros for CSR clock range parameters to be passed by
+ * platform code.
+ * This could also be configured at run time using CPU freq framework. */
+
+/* MDC Clock Selection define*/
+#define	STMMAC_CSR_60_100M	0x0	/* MDC = clk_scr_i/42 */
+#define	STMMAC_CSR_100_150M	0x1	/* MDC = clk_scr_i/62 */
+#define	STMMAC_CSR_20_35M	0x2	/* MDC = clk_scr_i/16 */
+#define	STMMAC_CSR_35_60M	0x3	/* MDC = clk_scr_i/26 */
+#define	STMMAC_CSR_150_250M	0x4	/* MDC = clk_scr_i/102 */
+#define	STMMAC_CSR_250_300M	0x5	/* MDC = clk_scr_i/122 */
+
+/* MTL algorithms identifiers */
+#define MTL_TX_ALGORITHM_WRR	0x0
+#define MTL_TX_ALGORITHM_WFQ	0x1
+#define MTL_TX_ALGORITHM_DWRR	0x2
+#define MTL_TX_ALGORITHM_SP	0x3
+#define MTL_RX_ALGORITHM_SP	0x4
+#define MTL_RX_ALGORITHM_WSP	0x5
+
+/* RX/TX Queue Mode */
+#define MTL_QUEUE_AVB		0x0
+#define MTL_QUEUE_DCB		0x1
+
+/* The MDC clock could be set higher than the IEEE 802.3
+ * specified frequency limit 0f 2.5 MHz, by programming a clock divider
+ * of value different than the above defined values. The resultant MDIO
+ * clock frequency of 12.5 MHz is applicable for the interfacing chips
+ * supporting higher MDC clocks.
+ * The MDC clock selection macros need to be defined for MDC clock rate
+ * of 12.5 MHz, corresponding to the following selection.
+ */
+#define STMMAC_CSR_I_4		0x8	/* clk_csr_i/4 */
+#define STMMAC_CSR_I_6		0x9	/* clk_csr_i/6 */
+#define STMMAC_CSR_I_8		0xA	/* clk_csr_i/8 */
+#define STMMAC_CSR_I_10		0xB	/* clk_csr_i/10 */
+#define STMMAC_CSR_I_12		0xC	/* clk_csr_i/12 */
+#define STMMAC_CSR_I_14		0xD	/* clk_csr_i/14 */
+#define STMMAC_CSR_I_16		0xE	/* clk_csr_i/16 */
+#define STMMAC_CSR_I_18		0xF	/* clk_csr_i/18 */
+
+/* AXI DMA Burst length supported */
+#define DMA_AXI_BLEN_4		(1 << 1)
+#define DMA_AXI_BLEN_8		(1 << 2)
+#define DMA_AXI_BLEN_16		(1 << 3)
+#define DMA_AXI_BLEN_32		(1 << 4)
+#define DMA_AXI_BLEN_64		(1 << 5)
+#define DMA_AXI_BLEN_128	(1 << 6)
+#define DMA_AXI_BLEN_256	(1 << 7)
+#define DMA_AXI_BLEN_ALL (DMA_AXI_BLEN_4 | DMA_AXI_BLEN_8 | DMA_AXI_BLEN_16 \
+			| DMA_AXI_BLEN_32 | DMA_AXI_BLEN_64 \
+			| DMA_AXI_BLEN_128 | DMA_AXI_BLEN_256)
+
+/* Platfrom data for platform device structure's platform_data field */
+
+struct stmmac_mdio_bus_data {
+	unsigned int phy_mask;
+	unsigned int has_xpcs;
+	int *irqs;
+	int probed_phy_irq;
+	bool needs_reset;
+};
+
+struct stmmac_dma_cfg {
+	int pbl;
+	int txpbl;
+	int rxpbl;
+	bool pblx8;
+	int fixed_burst;
+	int mixed_burst;
+	bool aal;
+	bool eame;
+};
+
+#define AXI_BLEN	7
+struct stmmac_axi {
+	bool axi_lpi_en;
+	bool axi_xit_frm;
+	uint32_t axi_wr_osr_lmt;
+	uint32_t axi_rd_osr_lmt;
+	bool axi_kbbe;
+	uint32_t axi_blen[AXI_BLEN];
+	bool axi_fb;
+	bool axi_mb;
+	bool axi_rb;
+};
+
+#define EST_GCL		1024
+struct stmmac_est {
+	int enable;
+	uint32_t btr_offset[2];
+	uint32_t btr[2];
+	uint32_t ctr[2];
+	uint32_t ter;
+	uint32_t gcl_unaligned[EST_GCL];
+	uint32_t gcl[EST_GCL];
+	uint32_t gcl_size;
+};
+
+struct stmmac_rxq_cfg {
+	uint8_t mode_to_use;
+	uint32_t chan;
+	uint8_t pkt_route;
+	bool use_prio;
+	uint32_t prio;
+};
+
+struct stmmac_txq_cfg {
+	uint32_t weight;
+	uint8_t mode_to_use;
+	/* Credit Base Shaper parameters */
+	uint32_t send_slope;
+	uint32_t idle_slope;
+	uint32_t high_credit;
+	uint32_t low_credit;
+	bool use_prio;
+	uint32_t prio;
+	int tbs_en;
+};
+
+struct plat_stmmacenet_data {
+	int bus_id;
+	struct stmmac_dma_cfg *dma_cfg;
+	struct stmmac_est *est;
+	int clk_csr;
+	int has_gmac;
+	int has_gmac4;
+	int enh_desc;
+	int tx_coe;
+	int rx_coe;
+	int bugged_jumbo;
+	int pmt;
+	int force_sf_dma_mode;
+	int force_thresh_dma_mode;
+	int riwt_off;
+	int max_speed;
+	int maxmtu;
+	int multicast_filter_bins;
+	int unicast_filter_entries;
+	int tx_fifo_size;
+	int rx_fifo_size;
+	uint32_t addr64;
+	uint32_t rx_queues_to_use;
+	uint32_t tx_queues_to_use;
+	uint8_t rx_sched_algorithm;
+	uint8_t tx_sched_algorithm;
+	struct stmmac_rxq_cfg rx_queues_cfg[MTL_MAX_RX_QUEUES];
+	struct stmmac_txq_cfg tx_queues_cfg[MTL_MAX_TX_QUEUES];
+	void (*get_eth_addr)(void *priv, unsigned char *addr);
+	struct mac_device_info *(*setup)(void *priv);
+	uint32_t ptp_max_adj;
+	struct stmmac_axi *axi;
+	bool has_sun8i;
+	bool tso_en;
+	int rss_en;
+	int mac_port_sel_speed;
+	bool en_tx_lpi_clockgating;
+	int has_xgmac;
+	bool vlan_fail_q_en;
+	uint8_t vlan_fail_q;
+	unsigned int eee_usecs_rate;
+	bool uio;
+};
+#endif
diff --git a/drivers/net/stmmac/stmmac_ethdev.c b/drivers/net/stmmac/stmmac_ethdev.c
new file mode 100644
index 0000000..be6cbbe
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_ethdev.c
@@ -0,0 +1,920 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <ethdev_vdev.h>
+#include <ethdev_driver.h>
+#include <rte_io.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include "stmmac_pmd_logs.h"
+#include "stmmac_ethdev.h"
+#include "stmmac_regs.h"
+#include "common.h"
+#include "stmmac_ptp.h"
+#include "stmmac.h"
+#include "hwif.h"
+
+#define STMMAC_NAME_PMD                net_stmmac
+
+/* FEC receive acceleration */
+#define STMMAC_RACC_IPDIS		RTE_BIT32(1)
+#define STMMAC_RACC_PRODIS		RTE_BIT32(2)
+#define STMMAC_RACC_SHIFT16		RTE_BIT32(7)
+#define STMMAC_RACC_OPTIONS		(STMMAC_RACC_IPDIS | \
+					STMMAC_RACC_PRODIS)
+
+#define STMMAC_PAUSE_FLAG_AUTONEG	0x1
+#define STMMAC_PAUSE_FLAG_ENABLE	0x2
+
+/* Pause frame field and FIFO threshold */
+#define STMMAC_FCE			RTE_BIT32(5)
+#define STMMAC_RSEM_V			0x84
+#define STMMAC_RSFL_V			16
+#define STMMAC_RAEM_V			0x8
+#define STMMAC_RAFL_V			0x8
+#define STMMAC_OPD_V			0xFFF0
+
+/* Supported Rx offloads */
+static uint64_t dev_rx_offloads_sup =
+		RTE_ETH_RX_OFFLOAD_CHECKSUM |
+		RTE_ETH_RX_OFFLOAD_VLAN;
+
+static uint32_t
+stmmac_get_id(struct stmmac_private *priv, uint32_t id_reg)
+{
+	uint32_t reg = rte_read32((uint8_t *)priv->ioaddr_v + id_reg);
+
+	if (!reg) {
+		STMMAC_PMD_ERR("Version ID not available\n");
+		return 0x0;
+	}
+
+	STMMAC_PMD_INFO("User ID: 0x%x, Synopsys ID: 0x%x\n",
+			(unsigned int)(reg & GENMASK(15, 8)) >> 8,
+			(unsigned int)(reg & GENMASK(7, 0)));
+	return reg & GENMASK(7, 0);
+}
+
+static const struct stmmac_hwif_entry {
+	bool gmac;
+	bool gmac4;
+	uint32_t min_id;
+	uint32_t dev_id;
+	const struct stmmac_regs_off regs;
+	const void *desc;
+	const void *dma;
+	const void *mac;
+	const void *hwtimestamp;
+	const void *mode;
+	const void *tc;
+	const void *mmc;
+	int (*setup)(struct stmmac_private *priv);
+	int (*quirks)(struct stmmac_private *priv);
+} stmmac_hw[] = {
+	{
+		.gmac = false,
+		.gmac4 = true,
+		.min_id = DWMAC_CORE_4_10,
+		.regs = {
+			.ptp_off = PTP_GMAC4_OFFSET,
+			.mmc_off = MMC_GMAC4_OFFSET,
+		},
+		.desc = &dwmac4_desc_ops,
+		.dma = &dwmac410_dma_ops,
+		.mac = &dwmac410_ops,
+		.mode = &dwmac4_ring_mode_ops,
+		.setup = dwmac4_setup,
+	},
+};
+
+static int
+stmmac_hwif_init(struct stmmac_private *priv)
+{
+	bool needs_gmac4;
+	bool needs_gmac;
+	const struct stmmac_hwif_entry *entry;
+	struct mac_device_info *mac;
+	bool needs_setup = true;
+	uint32_t id;
+	int i, ret;
+
+	needs_gmac4 = priv->plat->has_gmac4;
+	needs_gmac = priv->plat->has_gmac;
+
+	if (needs_gmac) {
+		id = stmmac_get_id(priv, GMAC_VERSION);
+	} else if (needs_gmac4) {
+		id = stmmac_get_id(priv, GMAC4_VERSION);
+	} else {
+		id = 0;
+	}
+
+	/* Save ID for later use */
+	priv->synopsys_id = id;
+
+	/* Lets assume some safe values first */
+	priv->ptpaddr = (uint8_t *)priv->ioaddr_v +
+		(needs_gmac4 ? PTP_GMAC4_OFFSET : PTP_GMAC3_X_OFFSET);
+	priv->mmcaddr = (uint8_t *)priv->ioaddr_v +
+		(needs_gmac4 ? MMC_GMAC4_OFFSET : MMC_GMAC3_X_OFFSET);
+
+	mac = rte_zmalloc("mac_device_info", sizeof(*mac), 0);
+	if (!mac)
+		return -ENOMEM;
+
+	/* Fallback to generic HW */
+	for (i = ARRAY_SIZE(stmmac_hw) - 1; i >= 0; i--) {
+		entry = &stmmac_hw[i];
+
+		if (needs_gmac ^ entry->gmac)
+			continue;
+		if (needs_gmac4 ^ entry->gmac4)
+			continue;
+		/* Use synopsys_id var because some setups can override this */
+		if (priv->synopsys_id < entry->min_id)
+			continue;
+
+		/* Only use generic HW helpers if needed */
+		mac->desc = mac->desc ? : entry->desc;
+		mac->dma = mac->dma ? : entry->dma;
+		mac->mac = mac->mac ? : entry->mac;
+		mac->ptp = mac->ptp ? : entry->hwtimestamp;
+		mac->mode = mac->mode ? : entry->mode;
+		mac->tc = mac->tc ? : entry->tc;
+		mac->mmc = mac->mmc ? : entry->mmc;
+
+		priv->hw = mac;
+		priv->ptpaddr = (uint8_t *)priv->ioaddr_v + entry->regs.ptp_off;
+		priv->mmcaddr = (uint8_t *)priv->ioaddr_v + entry->regs.mmc_off;
+
+		/* Entry found */
+		if (needs_setup) {
+			ret = entry->setup(priv);
+			if (ret)
+				return ret;
+		}
+
+		return 0;
+	}
+
+	STMMAC_PMD_ERR("Failed to find HW IF (id=0x%x, gmac=%d/%d)\n",
+			id, needs_gmac, needs_gmac4);
+	return -EINVAL;
+}
+
+/**
+ * stmmac_start_rx_dma - start RX DMA channel
+ * @priv: driver private structure
+ * @chan: RX channel index
+ * Description:
+ * This starts a RX DMA channel
+ */
+static void
+stmmac_start_rx_dma(struct stmmac_private *priv, uint32_t chan)
+{
+	STMMAC_PMD_INFO("DMA RX processes started in channel %d\n", chan);
+	stmmac_start_rx(priv, priv->ioaddr_v, chan);
+}
+
+/**
+ * stmmac_start_tx_dma - start TX DMA channel
+ * @priv: driver private structure
+ * @chan: TX channel index
+ * Description:
+ * This starts a TX DMA channel
+ */
+static void
+stmmac_start_tx_dma(struct stmmac_private *priv, uint32_t chan)
+{
+	STMMAC_PMD_INFO("DMA TX processes started in channel %d\n", chan);
+	stmmac_start_tx(priv, priv->ioaddr_v, chan);
+}
+
+/**
+ * stmmac_stop_rx_dma - stop RX DMA channel
+ * @priv: driver private structure
+ * @chan: RX channel index
+ * Description:
+ * This stops a RX DMA channel
+ */
+static void
+stmmac_stop_rx_dma(struct stmmac_private *priv, uint32_t chan)
+{
+	STMMAC_PMD_INFO("DMA RX processes stopped in channel %d\n", chan);
+	stmmac_stop_rx(priv, priv->ioaddr_v, chan);
+}
+
+/**
+ * stmmac_stop_tx_dma - stop TX DMA channel
+ * @priv: driver private structure
+ * @chan: TX channel index
+ * Description:
+ * This stops a TX DMA channel
+ */
+static void
+stmmac_stop_tx_dma(struct stmmac_private *priv, uint32_t chan)
+{
+	STMMAC_PMD_INFO("DMA TX processes stopped in channel %d\n", chan);
+	stmmac_stop_tx(priv, priv->ioaddr_v, chan);
+}
+
+/**
+ * stmmac_start_all_dma - start all RX and TX DMA channels
+ * @priv: driver private structure
+ * Description:
+ * This starts all the RX and TX DMA channels
+ */
+static void
+stmmac_start_all_dma(struct stmmac_private *priv)
+{
+	uint32_t rx_channels_count = priv->rx_queues_to_use;
+	uint32_t tx_channels_count = priv->tx_queues_to_use;
+	uint32_t chan = 0;
+
+	for (chan = 0; chan < rx_channels_count; chan++)
+		stmmac_start_rx_dma(priv, chan);
+
+	for (chan = 0; chan < tx_channels_count; chan++)
+		stmmac_start_tx_dma(priv, chan);
+}
+
+/**
+ * stmmac_stop_all_dma - stop all RX and TX DMA channels
+ * @priv: driver private structure
+ * Description:
+ * This stops the RX and TX DMA channels
+ */
+static void
+stmmac_stop_all_dma(struct stmmac_private *priv)
+{
+	uint32_t rx_channels_count = priv->rx_queues_to_use;
+	uint32_t tx_channels_count = priv->tx_queues_to_use;
+	uint32_t chan = 0;
+
+	for (chan = 0; chan < rx_channels_count; chan++)
+		stmmac_stop_rx_dma(priv, chan);
+
+	for (chan = 0; chan < tx_channels_count; chan++)
+		stmmac_stop_tx_dma(priv, chan);
+}
+
+/*
+ * This function is called to start or restart the STMMAC during a link
+ * change, transmit timeout, or to reconfigure the STMMAC. The network
+ * packet processing for this device must be stopped before this call.
+ */
+static int
+stmmac_start(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	/* Start the ball rolling... */
+	stmmac_start_all_dma(private);
+
+	rte_delay_us(200);
+
+	return 0;
+}
+
+static void
+stmmac_free_buffers(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	unsigned int i, q;
+	struct rte_mbuf *mbuf;
+	struct stmmac_rx_queue *rxq;
+	struct stmmac_tx_queue *txq;
+
+	STMMAC_PMD_ERR("stmmac_free_buffers");
+	for (q = 0; q < dev->data->nb_rx_queues; q++) {
+		rxq = private->rx_queues[q];
+		for (i = 0; i < rxq->dma_rx_size; i++) {
+			mbuf = rxq->rx_mbuf[i];
+			rxq->rx_mbuf[i] = NULL;
+			rte_pktmbuf_free(mbuf);
+		}
+	}
+
+	for (q = 0; q < dev->data->nb_tx_queues; q++) {
+		txq = private->tx_queues[q];
+		for (i = 0; i < txq->dma_tx_size; i++) {
+			mbuf = txq->tx_mbuf[i];
+			txq->tx_mbuf[i] = NULL;
+			rte_pktmbuf_free(mbuf);
+		}
+	}
+}
+
+static int
+stmmac_eth_configure(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	if (dev->data->dev_conf.rxmode.offloads & RTE_ETH_RX_OFFLOAD_CHECKSUM)
+		private->flag_csum |= RX_FLAG_CSUM_EN;
+
+	if (dev->data->dev_conf.rxmode.offloads & RTE_ETH_RX_OFFLOAD_KEEP_CRC)
+		STMMAC_PMD_ERR("PMD does not support KEEP_CRC offload");
+
+	return 0;
+}
+
+static int
+stmmac_eth_start(struct rte_eth_dev *dev)
+{
+	stmmac_start(dev);
+	dev->rx_pkt_burst = &stmmac_recv_pkts;
+	dev->tx_pkt_burst = &stmmac_xmit_pkts;
+
+	return 0;
+}
+
+/* STMMAC disable function.
+ * @param[in] base      STMMAC base address
+ */
+static void
+stmmac_disable(struct stmmac_private *private)
+{
+	stmmac_stop_all_dma(private);
+}
+
+static int
+stmmac_eth_stop(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	struct stmmac_rx_queue *rxq;
+	struct stmmac_tx_queue *txq;
+	unsigned int q;
+
+	dev->data->dev_started = 0;
+	stmmac_disable(private);
+
+	for (q = 0; q < dev->data->nb_rx_queues; q++) {
+		STMMAC_PMD_ERR("stmmac_eth_stop rx queue");
+		rxq = private->rx_queues[q];
+		rxq->cur_rx = 0;
+	}
+
+	for (q = 0; q < dev->data->nb_tx_queues; q++) {
+		STMMAC_PMD_ERR("stmmac_eth_stop tx queue");
+		txq = private->tx_queues[q];
+		txq->cur_tx = 0;
+	}
+
+	return 0;
+}
+
+static int
+stmmac_eth_close(struct rte_eth_dev *dev)
+{
+	stmmac_free_buffers(dev);
+	return 0;
+}
+
+static int
+stmmac_eth_link_update(struct rte_eth_dev *dev,
+			int wait_to_complete __rte_unused)
+{
+	struct rte_eth_link link;
+	unsigned int lstatus = 1;
+
+	memset(&link, 0, sizeof(struct rte_eth_link));
+
+	link.link_status = lstatus;
+	link.link_speed = RTE_ETH_SPEED_NUM_1G;
+
+	STMMAC_PMD_ERR("Port (%d) link is %s\n", dev->data->port_id, "Up");
+
+	return rte_eth_linkstatus_set(dev, &link);
+}
+
+/* Set a MAC change in hardware. */
+static int
+stmmac_set_mac_address(struct rte_eth_dev *dev,
+		    struct rte_ether_addr *addr)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	/* Copy the MAC addr into the HW  */
+	stmmac_set_umac_addr(private, private->hw, addr->addr_bytes, 0);
+
+	rte_ether_addr_copy(addr, &dev->data->mac_addrs[0]);
+
+	return 0;
+}
+
+static int
+stmmac_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *stats)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	struct rte_eth_stats *eth_stats = &private->stats;
+
+	stats->ipackets = eth_stats->ipackets;
+	stats->ibytes = eth_stats->ibytes;
+	stats->ierrors = eth_stats->ierrors;
+	stats->opackets = eth_stats->opackets;
+	stats->obytes = eth_stats->obytes;
+	stats->oerrors = eth_stats->oerrors;
+	stats->rx_nombuf = eth_stats->rx_nombuf;
+
+	return 0;
+}
+
+static int
+stmmac_eth_info(__rte_unused struct rte_eth_dev *dev,
+		struct rte_eth_dev_info *dev_info)
+{
+	dev_info->max_rx_pktlen = STMMAC_MAX_RX_PKT_LEN;
+	dev_info->max_rx_queues = STMMAC_MAX_Q;
+	dev_info->max_tx_queues = STMMAC_MAX_Q;
+	dev_info->rx_offload_capa = dev_rx_offloads_sup;
+	return 0;
+}
+
+static void
+stmmac_free_queue(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	unsigned int i;
+
+	for (i = 0; i < dev->data->nb_rx_queues; i++)
+		rte_free(private->rx_queues[i]);
+	for (i = 0; i < dev->data->nb_tx_queues; i++)
+		rte_free(private->rx_queues[i]);
+}
+
+static void
+stmmac_clear_rx_descriptors(struct stmmac_private *priv, uint32_t queue)
+{
+	struct stmmac_rx_queue *rx_q = priv->rx_queues[queue];
+	unsigned int i;
+
+	/* Clear the RX descriptors */
+	for (i = 0; i < rx_q->dma_rx_size; i++)
+		if (priv->extend_desc)
+			stmmac_init_rx_desc(priv, &rx_q->dma_erx[i].basic,
+					priv->use_riwt, priv->mode,
+					(i == priv->dma_rx_size - 1),
+					priv->dma_buf_sz);
+		else
+			stmmac_init_rx_desc(priv, &rx_q->dma_rx[i],
+					priv->use_riwt, priv->mode,
+					(i == priv->dma_rx_size - 1),
+					priv->dma_buf_sz);
+}
+
+/**
+ * stmmac_clear_tx_descriptors - clear tx descriptors
+ * @priv: driver private structure
+ * @queue: TX queue index.
+ * Description: this function is called to clear the TX descriptors
+ * in case of both basic and extended descriptors are used.
+ */
+static void
+stmmac_clear_tx_descriptors(struct stmmac_private *priv, uint32_t queue)
+{
+	struct stmmac_tx_queue *tx_q = priv->tx_queues[queue];
+	unsigned int i;
+
+	/* Clear the TX descriptors */
+	for (i = 0; i < tx_q->dma_tx_size; i++) {
+		int last = (i == (priv->dma_tx_size - 1));
+		struct dma_desc *p;
+
+		if (priv->extend_desc)
+			p = &tx_q->dma_etx[i].basic;
+		else if (tx_q->tbs & STMMAC_TBS_AVAIL)
+			p = &tx_q->dma_entx[i].basic;
+		else
+			p = &tx_q->dma_tx[i];
+
+		stmmac_init_tx_desc(priv, p, priv->mode, last);
+	}
+}
+
+/**
+ * stmmac_init_rx_buffers - init the RX descriptor buffer.
+ * @priv: driver private structure
+ * @p: descriptor pointer
+ * @i: descriptor index
+ * @flags: gfp flag
+ * @queue: RX queue index
+ * Description: this function is called to allocate a receive buffer, perform
+ * the DMA mapping and init the descriptor.
+ */
+static int
+stmmac_init_rx_buffers(struct stmmac_private *priv, struct dma_desc *p,
+		       struct rte_mbuf *buf)
+{
+	stmmac_set_desc_addr(priv, p, rte_cpu_to_le_32(rte_pktmbuf_iova(buf)));
+	if (priv->dma_buf_sz == BUF_SIZE_16KiB)
+		stmmac_init_desc3(priv, p);
+
+	return 0;
+}
+
+static int
+stmmac_tx_queue_setup(struct rte_eth_dev *dev,
+		      uint16_t queue_idx,
+		      uint16_t nb_desc,
+		      unsigned int socket_id __rte_unused,
+		      const struct rte_eth_txconf *tx_conf)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	struct stmmac_tx_queue *txq =  private->tx_queues[queue_idx];
+	unsigned int i;
+	int ret;
+
+	/* Tx deferred start is not supported */
+	if (tx_conf->tx_deferred_start) {
+		STMMAC_PMD_ERR("Tx deferred start not supported\n");
+		return -EINVAL;
+	}
+
+	/* allocate transmit queue */
+	txq = rte_zmalloc(NULL, sizeof(*txq), RTE_CACHE_LINE_SIZE);
+	if (txq == NULL) {
+		STMMAC_PMD_ERR("transmit queue allocation failed\n");
+		return -ENOMEM;
+	}
+
+	if (nb_desc > DMA_MAX_TX_SIZE) {
+		nb_desc = DMA_MAX_TX_SIZE;
+		STMMAC_PMD_WARN("modified the nb_desc to MAX_TX_BD_RING_SIZE\n");
+	}
+
+	txq->dma_tx_size = nb_desc;
+	private->total_tx_ring_size += txq->dma_tx_size;
+	private->tx_queues[queue_idx] = txq;
+	txq->dma_tx = private->bd_addr_t_v;
+	txq->dma_tx_phy = private->bd_addr_t_p;
+	txq->private = private;
+
+	txq->tx_mbuf_dma = rte_zmalloc(NULL, nb_desc * sizeof(struct stmmac_tx_info), 0);
+	if (txq->tx_mbuf_dma == NULL) {
+		STMMAC_PMD_ERR("transmit queue tx_mbuf_dma allocation failed\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	stmmac_clear_tx_descriptors(private, queue_idx);
+	STMMAC_PMD_INFO("%s nb_desc: %d, total_tx_ring_size: %d\n", __func__,
+			nb_desc, private->total_tx_ring_size);
+
+	for (i = 0; i <txq->dma_tx_size; i++) {
+		struct dma_desc *p;
+		if (private->extend_desc)
+			p = &((txq->dma_etx + i)->basic);
+		else if (txq->tbs & STMMAC_TBS_AVAIL)
+			p = &((txq->dma_entx + i)->basic);
+		else
+			p = txq->dma_tx + i;
+
+		stmmac_clear_desc(private, p);
+
+		txq->tx_mbuf_dma[i].buf = 0;
+		txq->tx_mbuf_dma[i].len = 0;
+		txq->tx_mbuf_dma[i].last_segment = false;
+		txq->tx_mbuf[i] = NULL;
+	}
+
+	txq->dirty_tx = 0;
+	txq->cur_tx = 0;
+	txq->mss = 0;
+
+	dev->data->tx_queues[queue_idx] = private->tx_queues[queue_idx];
+
+	return 0;
+fail:
+	if (txq)
+		rte_free(txq);
+
+	return ret;
+}
+
+static int
+stmmac_rx_queue_setup(struct rte_eth_dev *dev,
+		      uint16_t queue_idx,
+		      uint16_t nb_rx_desc,
+		      unsigned int socket_id __rte_unused,
+		      const struct rte_eth_rxconf *rx_conf,
+		      struct rte_mempool *mb_pool)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	struct stmmac_rx_queue *rxq;
+	unsigned int i;
+	int ret;
+
+	/* Rx deferred start is not supported */
+	if (rx_conf->rx_deferred_start) {
+		STMMAC_PMD_ERR("Rx deferred start not supported\n");
+		return -EINVAL;
+	}
+
+	/* allocate receive queue */
+	rxq = rte_zmalloc(NULL, sizeof(*rxq), RTE_CACHE_LINE_SIZE);
+	if (rxq == NULL) {
+		STMMAC_PMD_ERR("receive queue allocation failed\n");
+		return -ENOMEM;
+	}
+
+	if (nb_rx_desc > DMA_MAX_RX_SIZE) {
+		nb_rx_desc = DMA_MAX_RX_SIZE;
+		STMMAC_PMD_WARN("modified the nb_desc to MAX_RX_BD_RING_SIZE\n");
+	}
+
+	rxq->dma_rx_size = nb_rx_desc;
+	private->total_rx_ring_size += rxq->dma_rx_size;
+	private->rx_queues[queue_idx] = rxq;
+	rxq->pool = mb_pool;
+	rxq->private = private;
+	rxq->queue_index = queue_idx;
+	rxq->dma_rx = private->bd_addr_r_v;
+	rxq->dma_rx_phy = private->bd_addr_r_p;
+
+	STMMAC_PMD_INFO("%s nb_rx_desc: %d, total_rx_ring_size: %d\n",
+			__func__, nb_rx_desc, private->total_rx_ring_size);
+
+	stmmac_clear_rx_descriptors(private, queue_idx);
+
+	for (i = 0; i < rxq->dma_rx_size; i++) {
+		struct dma_desc *p;
+		void *data;
+		int size;
+		/* Initialize Rx buffers from pktmbuf pool */
+		struct rte_mbuf *mbuf = rte_pktmbuf_alloc(mb_pool);
+		if (mbuf == NULL) {
+			STMMAC_PMD_ERR("mbuf failed");
+			ret = -ENOMEM;
+			goto err_alloc;
+		}
+		data = rte_pktmbuf_mtod(mbuf, uint8_t *);
+		mbuf->data_off += STMMAC_BUFFER_ALIGN;
+		data += STMMAC_BUFFER_ALIGN;
+		for (size = 0; size <= STMMAC_ALIGN_LENGTH; size += 64) {
+			dcivac((uint8_t *)data + i);
+		}
+
+		if (private->extend_desc)
+			p = &((rxq->dma_erx + i)->basic);
+		else
+			p = rxq->dma_rx + i;
+
+		stmmac_init_rx_buffers(private, p, mbuf);
+		rxq->rx_mbuf[i] = mbuf;
+	}
+
+	rxq->cur_rx = 0;
+	rxq->dirty_rx = (unsigned int)(i - private->dma_rx_size);
+
+	/* Setup the chained descriptor addresses */
+	if (private->mode == STMMAC_CHAIN_MODE) {
+		if (private->extend_desc)
+			stmmac_mode_init(private, rxq->dma_erx,
+					 rxq->dma_rx_phy,
+					 rxq->dma_rx_size, 1);
+		else
+			stmmac_mode_init(private, rxq->dma_rx,
+					 rxq->dma_rx_phy,
+					 rxq->dma_rx_size, 0);
+	}
+
+	dev->data->rx_queues[queue_idx] = private->rx_queues[queue_idx];
+	rxq->rx_tail_addr = rxq->dma_rx_phy +
+			    (rxq->dma_rx_size * sizeof(struct dma_desc));
+	wmb();
+	stmmac_set_rx_tail_ptr(rxq->private, rxq->private->ioaddr_v, rxq->rx_tail_addr, 0);
+
+
+	return 0;
+
+err_alloc:
+	rte_free(rxq);
+
+	return ret;
+}
+
+#define GMAC_PACKET_FILTER		0x00000008
+#define GMAC_PACKET_FILTER_PR		BIT(0)
+
+static int
+stmmac_promiscuous_enable(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	uint32_t tmp;
+
+	private->flags |= IFF_PROMISC;
+	tmp = rte_read32((uint8_t *)private->ioaddr_v + GMAC_PACKET_FILTER);
+	tmp |= GMAC_PACKET_FILTER_PR;
+	rte_write32(rte_cpu_to_le_32(tmp),
+		(uint8_t *)private->ioaddr_v + GMAC_PACKET_FILTER);
+
+	return 0;
+}
+
+static int
+stmmac_promiscuous_disable(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+	uint32_t tmp;
+
+	private->flags &= ~IFF_PROMISC;
+	tmp = rte_read32((uint8_t *)private->ioaddr_v + GMAC_PACKET_FILTER);
+	tmp &= ~GMAC_PACKET_FILTER_PR;
+	rte_write32(rte_cpu_to_le_32(tmp),
+		(uint8_t *)private->ioaddr_v + GMAC_PACKET_FILTER);
+
+	return 0;
+}
+
+static int
+stmmac_allmulticast_enable(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	private->flags |= IFF_ALLMULTI;
+	/* To-do */
+
+	return 0;
+}
+
+static int
+stmmac_allmulticast_disable(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	private->flags &= ~IFF_ALLMULTI;
+	/* To-do */
+
+	return 0;
+}
+static const struct eth_dev_ops stmmac_dev_ops = {
+	.dev_configure          = stmmac_eth_configure,
+	.dev_start              = stmmac_eth_start,
+	.dev_stop               = stmmac_eth_stop,
+	.dev_close              = stmmac_eth_close,
+	.link_update            = stmmac_eth_link_update,
+	.promiscuous_enable     = stmmac_promiscuous_enable,
+	.promiscuous_disable	= stmmac_promiscuous_disable,
+	.allmulticast_enable	= stmmac_allmulticast_enable,
+	.allmulticast_disable	= stmmac_allmulticast_disable,
+	.mac_addr_set           = stmmac_set_mac_address,
+	.stats_get              = stmmac_stats_get,
+	.dev_infos_get          = stmmac_eth_info,
+	.rx_queue_setup         = stmmac_rx_queue_setup,
+	.tx_queue_setup         = stmmac_tx_queue_setup
+};
+
+static int
+stmmac_eth_init(struct rte_eth_dev *dev)
+{
+	struct stmmac_private *private = dev->data->dev_private;
+
+	private->full_duplex = FULL_DUPLEX;
+	dev->dev_ops = &stmmac_dev_ops;
+	rte_eth_dev_probing_finish(dev);
+
+	return 0;
+}
+
+static int
+pmd_stmmac_probe(struct rte_vdev_device *vdev)
+{
+	struct rte_eth_dev *dev = NULL;
+	struct stmmac_private *private;
+	const char *name;
+	struct rte_ether_addr macaddr = {
+		.addr_bytes = { 0x1, 0x1, 0x1, 0x1, 0x1, 0x1 }
+	};
+	int rc, i, id = 0, fd = socket(AF_INET, SOCK_DGRAM, 0);
+	struct ifreq req;
+	char if_name[16];
+
+	name = rte_vdev_device_name(vdev);
+	STMMAC_PMD_LOG(INFO, "Initializing pmd_stmmac for %s\n", name);
+
+	if (strncmp(name, RTE_STR(STMMAC_NAME_PMD), sizeof(RTE_STR(STMMAC_NAME_PMD))) > 0) {
+		sscanf(&name[strlen(RTE_STR(STMMAC_NAME_PMD))], "%d", &id);
+		STMMAC_PMD_LOG(INFO, "Initializing pmd_stmmac for id %d\n", id);
+	}
+
+	dev = rte_eth_vdev_allocate(vdev, sizeof(*private));
+	if (dev == NULL)
+		return -ENOMEM;
+
+	/* setup board info structure */
+	private = dev->data->dev_private;
+	private->dev = dev;
+	private->rx_queues_to_use = STMMAC_MAX_Q;
+	private->tx_queues_to_use = STMMAC_MAX_Q;
+
+	rc = stmmac_configure(private, id);
+	if (rc != 0)
+		return -ENOMEM;
+	rc = config_stmmac_uio(private);
+	if (rc != 0)
+		return -ENOMEM;
+
+	for (i = 0; i < private->rx_queues_to_use; i++) {
+		private->desc_addr_p_r[i] = private->bd_addr_r_p;
+		private->dma_baseaddr_v_r[i] = private->bd_addr_r_v;
+		private->bd_addr_r_v = (uint8_t *)private->bd_addr_r_v + private->bd_r_size[i] * i;
+		private->bd_addr_r_p = private->bd_addr_r_p +  private->bd_r_size[i];
+	}
+
+	for (i = 0; i < private->tx_queues_to_use; i++) {
+		private->desc_addr_p_t[i] = private->bd_addr_t_p;
+		private->dma_baseaddr_v_t[i] = private->bd_addr_t_v;
+		private->bd_addr_t_v = (uint8_t *)private->bd_addr_t_v +  private->bd_t_size[i] * i;
+		private->bd_addr_t_p = private->bd_addr_t_p +  private->bd_t_size[i];
+	}
+
+	/* Copy the station address into the dev structure, */
+	dev->data->mac_addrs = rte_zmalloc("mac_addr", RTE_ETHER_ADDR_LEN, 0);
+	if (dev->data->mac_addrs == NULL) {
+		STMMAC_PMD_ERR("Failed to allocate mem %d to store MAC addresses\n",
+			       RTE_ETHER_ADDR_LEN);
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	private->plat = rte_zmalloc("plat_stmmacenet_data", sizeof(*private->plat), 0);
+	if (private->plat == NULL) {
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	private->plat->has_gmac4 = true;
+	private->plat->has_gmac= false;
+
+	/* Initialize HW Interface */
+	rc  = stmmac_hwif_init(private);
+	if (rc )
+		goto err;
+
+	rc = stmmac_eth_init(dev);
+	if (rc)
+		goto failed_init;
+
+	memset(&req, 0, sizeof(req));
+	snprintf(if_name, sizeof(if_name), "%s%d", "eth", id);
+	strcpy(req.ifr_name, if_name);
+	rc = ioctl(fd, SIOCGIFHWADDR, &req);
+	if (rc)
+		goto failed_init;
+	memcpy(macaddr.addr_bytes,                           
+	       req.ifr_addr.sa_data, RTE_ETHER_ADDR_LEN);
+	/*
+	 * Set default mac address
+	 */
+	stmmac_set_mac_address(dev, &macaddr);
+
+	return 0;
+
+failed_init:
+	if (private->plat)
+	rte_free(private->plat);
+		STMMAC_PMD_ERR("Failed to init");
+err:
+	rte_eth_dev_release_port(dev);
+	
+	return rc;
+}
+
+static int
+pmd_stmmac_remove(struct rte_vdev_device *vdev)
+{
+	struct rte_eth_dev *eth_dev = NULL;
+	struct stmmac_private *private;
+	int ret;
+
+	/* find the ethdev entry */
+	eth_dev = rte_eth_dev_allocated(rte_vdev_device_name(vdev));
+	if (eth_dev == NULL)
+		return -ENODEV;
+
+	private = eth_dev->data->dev_private;
+	/* Free descriptor base of first RX queue as it was configured
+	 * first in stmmac_eth_init().
+	 */
+	stmmac_free_queue(eth_dev);
+	stmmac_eth_stop(eth_dev);
+
+	ret = rte_eth_dev_release_port(eth_dev);
+	if (ret != 0)
+		return -EINVAL;
+
+	STMMAC_PMD_INFO("Release stmmac sw device");
+	stmmac_cleanup(private);
+
+	return 0;
+}
+
+static struct rte_vdev_driver pmd_stmmac_drv = {
+	.probe = pmd_stmmac_probe,
+	.remove = pmd_stmmac_remove,
+};
+
+RTE_PMD_REGISTER_VDEV(STMMAC_NAME_PMD, pmd_stmmac_drv);
+RTE_LOG_REGISTER_DEFAULT(stmmac_logtype_pmd, NOTICE);
diff --git a/drivers/net/stmmac/stmmac_ethdev.h b/drivers/net/stmmac/stmmac_ethdev.h
new file mode 100644
index 0000000..5f97df4
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_ethdev.h
@@ -0,0 +1,489 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __STMMAC_ETHDEV_H__
+#define __STMMAC_ETHDEV_H__
+
+#include "descs.h"
+#include <rte_ethdev.h>
+
+#define STMMAC_RX_COE_NONE	0
+#define STMMAC_RX_COE_TYPE1	1
+#define STMMAC_RX_COE_TYPE2	2
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+#if 0
+#define stmmac_do_void_callback(__priv, __module, __cname,  __arg0, __args...) \
+({ \
+	int __result = -EINVAL; \
+	if ((__priv)->hw->__module && (__priv)->hw->__module->__cname) { \
+		(__priv)->hw->__module->__cname((__arg0), ##__args); \
+		__result = 0; \
+	} \
+	__result; \
+})
+#define stmmac_do_callback(__priv, __module, __cname,  __arg0, __args...) \
+({ \
+	int __result = -EINVAL; \
+	if ((__priv)->hw->__module && (__priv)->hw->__module->__cname) \
+		__result = (__priv)->hw->__module->__cname((__arg0), ##__args); \
+	__result; \
+})
+
+struct stmmac_extra_stats;
+struct stmmac_safety_stats;
+struct dma_desc;
+struct dma_extended_desc;
+struct dma_edesc;
+
+/* Descriptors helpers */
+struct stmmac_desc_ops {
+	/* DMA RX descriptor ring initialization */
+	void (*init_rx_desc)(struct dma_desc *p, int disable_rx_ic, int mode,
+			int end, int bfsize);
+	/* DMA TX descriptor ring initialization */
+	void (*init_tx_desc)(struct dma_desc *p, int mode, int end);
+	/* Invoked by the xmit function to prepare the tx descriptor */
+	void (*prepare_tx_desc)(struct dma_desc *p, int is_fs, int len,
+			bool csum_flag, int mode, bool tx_own, bool ls,
+			unsigned int tot_pkt_len);
+	void (*prepare_tso_tx_desc)(struct dma_desc *p, int is_fs, int len1,
+			int len2, bool tx_own, bool ls, unsigned int tcphdrlen,
+			unsigned int tcppayloadlen);
+	/* Set/get the owner of the descriptor */
+	void (*set_tx_owner)(struct dma_desc *p);
+	int (*get_tx_owner)(struct dma_desc *p);
+	/* Clean the tx descriptor as soon as the tx irq is received */
+	void (*release_tx_desc)(struct dma_desc *p, int mode);
+	/* Clear interrupt on tx frame completion. When this bit is
+	 * set an interrupt happens as soon as the frame is transmitted */
+	void (*set_tx_ic)(struct dma_desc *p);
+	/* Last tx segment reports the transmit status */
+	int (*get_tx_ls)(struct dma_desc *p);
+	/* Return the transmit status looking at the TDES1 */
+	int (*tx_status)(void *data, struct stmmac_extra_stats *x,
+			struct dma_desc *p, void *ioaddr);
+	/* Get the buffer size from the descriptor */
+	int (*get_tx_len)(struct dma_desc *p);
+	/* Handle extra events on specific interrupts hw dependent */
+	void (*set_rx_owner)(struct dma_desc *p, int disable_rx_ic);
+	/* Get the receive frame size */
+	int (*get_rx_frame_len)(struct dma_desc *p, int rx_coe_type);
+	/* Return the reception status looking at the RDES1 */
+	int (*rx_status)(struct rte_eth_stats *x,
+				       struct dma_desc *p);
+	void (*rx_extended_status)(void *data, struct stmmac_extra_stats *x,
+			struct dma_extended_desc *p);
+	/* Set tx timestamp enable bit */
+	void (*enable_tx_timestamp) (struct dma_desc *p);
+	/* get tx timestamp status */
+	int (*get_tx_timestamp_status) (struct dma_desc *p);
+	/* get timestamp value */
+	void (*get_timestamp)(void *desc, uint32_t ats, uint64_t *ts);
+	/* get rx timestamp status */
+	int (*get_rx_timestamp_status)(void *desc, void *next_desc, uint32_t ats);
+	/* Display ring */
+	void (*display_ring)(void *head, unsigned int size, bool rx,
+			     dma_addr_t dma_rx_phy, unsigned int desc_size);
+	/* set MSS via context descriptor */
+	void (*set_mss)(struct dma_desc *p, unsigned int mss);
+	/* get descriptor skbuff address */
+	void (*get_addr)(struct dma_desc *p, unsigned int *addr);
+	/* set descriptor skbuff address */
+	void (*set_addr)(struct dma_desc *p, dma_addr_t addr);
+	/* clear descriptor */
+	void (*clear)(struct dma_desc *p);
+	void (*get_rx_header_len)(struct dma_desc *p, unsigned int *len);
+	void (*set_sec_addr)(struct dma_desc *p, dma_addr_t addr, bool buf2_valid);
+	void (*set_sarc)(struct dma_desc *p, uint32_t sarc_type);
+	void (*set_vlan_tag)(struct dma_desc *p, uint16_t tag, uint16_t inner_tag,
+			     uint32_t inner_type);
+	void (*set_vlan)(struct dma_desc *p, uint32_t type);
+	void (*set_tbs)(struct dma_edesc *p, uint32_t sec, uint32_t nsec);
+};
+
+#define stmmac_init_rx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, init_rx_desc, __args)
+#define stmmac_init_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, init_tx_desc, __args)
+#define stmmac_prepare_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, prepare_tx_desc, __args)
+#define stmmac_prepare_tso_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, prepare_tso_tx_desc, __args)
+#define stmmac_set_tx_owner(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tx_owner, __args)
+#define stmmac_get_tx_owner(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_owner, __args)
+#define stmmac_release_tx_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, release_tx_desc, __args)
+#define stmmac_set_tx_ic(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tx_ic, __args)
+#define stmmac_get_tx_ls(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_ls, __args)
+#define stmmac_tx_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, tx_status, __args)
+#define stmmac_get_tx_len(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_len, __args)
+#define stmmac_set_rx_owner(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_rx_owner, __args)
+#define stmmac_get_rx_frame_len(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_frame_len, __args)
+#define stmmac_rx_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, rx_status, __args)
+#define stmmac_rx_extended_status(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, rx_extended_status, __args)
+#define stmmac_enable_tx_timestamp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, enable_tx_timestamp, __args)
+#define stmmac_get_tx_timestamp_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_tx_timestamp_status, __args)
+#define stmmac_get_timestamp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_timestamp, __args)
+#define stmmac_get_rx_timestamp_status(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_timestamp_status, __args)
+#define stmmac_display_ring(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, display_ring, __args)
+#define stmmac_set_mss(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_mss, __args)
+#define stmmac_get_desc_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_addr, __args)
+#define stmmac_set_desc_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_addr, __args)
+#define stmmac_clear_desc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, clear, __args)
+#define stmmac_get_rx_hash(__priv, __args...) \
+	stmmac_do_callback(__priv, desc, get_rx_hash, __args)
+#define stmmac_get_rx_header_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, get_rx_header_len, __args)
+#define stmmac_set_desc_sec_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_sec_addr, __args)
+#define stmmac_set_desc_sarc(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_sarc, __args)
+#define stmmac_set_desc_vlan_tag(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_vlan_tag, __args)
+#define stmmac_set_desc_vlan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_vlan, __args)
+#define stmmac_set_desc_tbs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, desc, set_tbs, __args)
+
+struct stmmac_dma_cfg;
+struct dma_features;
+
+#define stmmac_reset(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, reset, __args)
+#define stmmac_dma_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init, __args)
+#define stmmac_init_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_chan, __args)
+#define stmmac_init_rx_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_rx_chan, __args)
+#define stmmac_init_tx_chan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, init_tx_chan, __args)
+#define stmmac_axi(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, axi, __args)
+#define stmmac_dump_dma_regs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dump_regs, __args)
+#define stmmac_dma_rx_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_rx_mode, __args)
+#define stmmac_dma_tx_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_tx_mode, __args)
+#define stmmac_dma_diagnostic_fr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, dma_diagnostic_fr, __args)
+#define stmmac_enable_dma_transmission(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_dma_transmission, __args)
+#define stmmac_enable_dma_irq(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_dma_irq, __args)
+#define stmmac_disable_dma_irq(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, disable_dma_irq, __args)
+#define stmmac_start_tx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, start_tx, __args)
+#define stmmac_stop_tx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, stop_tx, __args)
+#define stmmac_start_rx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, start_rx, __args)
+#define stmmac_stop_rx(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, stop_rx, __args)
+#define stmmac_dma_interrupt_status(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, dma_interrupt, __args)
+#define stmmac_get_hw_feature(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, get_hw_feature, __args)
+#define stmmac_rx_watchdog(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, rx_watchdog, __args)
+#define stmmac_set_tx_ring_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_tx_ring_len, __args)
+#define stmmac_set_rx_ring_len(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_rx_ring_len, __args)
+#define stmmac_set_rx_tail_ptr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_rx_tail_ptr, __args)
+#define stmmac_set_tx_tail_ptr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_tx_tail_ptr, __args)
+#define stmmac_enable_tso(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_tso, __args)
+#define stmmac_dma_qmode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, qmode, __args)
+#define stmmac_set_dma_bfsize(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, set_bfsize, __args)
+#define stmmac_enable_sph(__priv, __args...) \
+	stmmac_do_void_callback(__priv, dma, enable_sph, __args)
+#define stmmac_enable_tbs(__priv, __args...) \
+	stmmac_do_callback(__priv, dma, enable_tbs, __args)
+
+struct mac_device_info;
+struct net_device;
+struct rgmii_adv;
+struct stmmac_safety_stats;
+struct stmmac_tc_entry;
+struct stmmac_pps_cfg;
+struct stmmac_rss;
+struct stmmac_est;
+
+#define stmmac_core_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, core_init, __args)
+#define stmmac_mac_set(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mac, __args)
+#define stmmac_rx_ipc(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rx_ipc, __args)
+#define stmmac_rx_queue_enable(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_enable, __args)
+#define stmmac_rx_queue_prio(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_prio, __args)
+#define stmmac_tx_queue_prio(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, tx_queue_prio, __args)
+#define stmmac_rx_queue_routing(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, rx_queue_routing, __args)
+#define stmmac_prog_mtl_rx_algorithms(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, prog_mtl_rx_algorithms, __args)
+#define stmmac_prog_mtl_tx_algorithms(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, prog_mtl_tx_algorithms, __args)
+#define stmmac_set_mtl_tx_queue_weight(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mtl_tx_queue_weight, __args)
+#define stmmac_map_mtl_to_dma(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, map_mtl_to_dma, __args)
+#define stmmac_config_cbs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, config_cbs, __args)
+#define stmmac_dump_mac_regs(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, dump_regs, __args)
+#define stmmac_host_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, host_irq_status, __args)
+#define stmmac_host_mtl_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, host_mtl_irq_status, __args)
+#define stmmac_set_filter(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_filter, __args)
+#define stmmac_flow_ctrl(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, flow_ctrl, __args)
+#define stmmac_pmt(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pmt, __args)
+#define stmmac_set_umac_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_umac_addr, __args)
+#define stmmac_get_umac_addr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, get_umac_addr, __args)
+#define stmmac_set_eee_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_mode, __args)
+#define stmmac_reset_eee_mode(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, reset_eee_mode, __args)
+#define stmmac_set_eee_timer(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_timer, __args)
+#define stmmac_set_eee_pls(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_eee_pls, __args)
+#define stmmac_mac_debug(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, debug, __args)
+#define stmmac_pcs_ctrl_ane(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_ctrl_ane, __args)
+#define stmmac_pcs_rane(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_rane, __args)
+#define stmmac_pcs_get_adv_lp(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, pcs_get_adv_lp, __args)
+#define stmmac_safety_feat_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_config, __args)
+#define stmmac_safety_feat_irq_status(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_irq_status, __args)
+#define stmmac_safety_feat_dump(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, safety_feat_dump, __args)
+#define stmmac_rxp_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rxp_config, __args)
+#define stmmac_flex_pps_config(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, flex_pps_config, __args)
+#define stmmac_set_mac_loopback(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_mac_loopback, __args)
+#define stmmac_rss_configure(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, rss_configure, __args)
+#define stmmac_update_vlan_hash(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, update_vlan_hash, __args)
+#define stmmac_enable_vlan(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, enable_vlan, __args)
+#define stmmac_add_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, add_hw_vlan_rx_fltr, __args)
+#define stmmac_del_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, del_hw_vlan_rx_fltr, __args)
+#define stmmac_restore_hw_vlan_rx_fltr(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, restore_hw_vlan_rx_fltr, __args)
+#define stmmac_get_mac_tx_timestamp(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, get_mac_tx_timestamp, __args)
+#define stmmac_sarc_configure(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, sarc_configure, __args)
+#define stmmac_config_l3_filter(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, config_l3_filter, __args)
+#define stmmac_config_l4_filter(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, config_l4_filter, __args)
+#define stmmac_set_arp_offload(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, set_arp_offload, __args)
+#define stmmac_est_configure(__priv, __args...) \
+	stmmac_do_callback(__priv, mac, est_configure, __args)
+#define stmmac_fpe_configure(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mac, fpe_configure, __args)
+
+/* Specific DMA helpers */
+struct stmmac_dma_ops {
+	/* DMA core initialization */
+	int (*reset)(void  *ioaddr);
+	void (*init)(void  *ioaddr, struct stmmac_dma_cfg *dma_cfg,
+		     int atds);
+	void (*init_chan)(void  *ioaddr,
+			  struct stmmac_dma_cfg *dma_cfg, uint32_t chan);
+	void (*init_rx_chan)(void  *ioaddr,
+			     struct stmmac_dma_cfg *dma_cfg,
+			     dma_addr_t phy, uint32_t chan);
+	void (*init_tx_chan)(void  *ioaddr,
+			     struct stmmac_dma_cfg *dma_cfg,
+			     dma_addr_t phy, uint32_t chan);
+	/* Dump DMA registers */
+	void (*dump_regs)(void  *ioaddr, uint32_t *reg_space);
+	void (*dma_rx_mode)(void  *ioaddr, int mode, uint32_t channel,
+			    int fifosz, uint8_t qmode);
+	void (*dma_tx_mode)(void  *ioaddr, int mode, uint32_t channel,
+			    int fifosz, uint8_t qmode);
+	/* To track extra statistic (if supported) */
+	void (*dma_diagnostic_fr) (void *data, struct stmmac_extra_stats *x,
+				   void  *ioaddr);
+	void (*enable_dma_transmission) (void  *ioaddr);
+	void (*enable_dma_irq)(void  *ioaddr, uint32_t chan,
+			       bool rx, bool tx);
+	void (*disable_dma_irq)(void  *ioaddr, uint32_t chan,
+				bool rx, bool tx);
+	void (*start_tx)(void  *ioaddr, uint32_t chan);
+	void (*stop_tx)(void  *ioaddr, uint32_t chan);
+	void (*start_rx)(void  *ioaddr, uint32_t chan);
+	void (*stop_rx)(void  *ioaddr, uint32_t chan);
+	int (*dma_interrupt) (void  *ioaddr,
+			      struct stmmac_extra_stats *x, uint32_t chan);
+	/* If supported then get the optional core features */
+	void (*get_hw_feature)(void  *ioaddr,
+			       struct dma_features *dma_cap);
+	/* Program the HW RX Watchdog */
+	void (*rx_watchdog)(void  *ioaddr, uint32_t riwt, uint32_t number_chan);
+	void (*set_tx_ring_len)(void  *ioaddr, uint32_t len, uint32_t chan);
+	void (*set_rx_ring_len)(void  *ioaddr, uint32_t len, uint32_t chan);
+	void (*set_rx_tail_ptr)(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+	void (*set_tx_tail_ptr)(void  *ioaddr, uint32_t tail_ptr, uint32_t chan);
+	void (*enable_tso)(void  *ioaddr, bool en, uint32_t chan);
+	void (*qmode)(void  *ioaddr, uint32_t channel, uint8_t qmode);
+	void (*set_bfsize)(void  *ioaddr, int bfsize, uint32_t chan);
+	void (*enable_sph)(void  *ioaddr, bool en, uint32_t chan);
+	int (*enable_tbs)(void  *ioaddr, bool en, uint32_t chan);
+};
+
+struct stmmac_regs_off {
+	uint32_t ptp_off;
+	uint32_t mmc_off;
+};
+
+extern const struct stmmac_ops dwmac100_ops;
+extern const struct stmmac_dma_ops dwmac100_dma_ops;
+extern const struct stmmac_ops dwmac1000_ops;
+extern const struct stmmac_dma_ops dwmac1000_dma_ops;
+extern const struct stmmac_ops dwmac4_ops;
+extern const struct stmmac_dma_ops dwmac4_dma_ops;
+extern const struct stmmac_ops dwmac410_ops;
+extern const struct stmmac_dma_ops dwmac410_dma_ops;
+extern const struct stmmac_ops dwmac510_ops;
+
+#define GMAC_VERSION		0x00000020	/* GMAC CORE Version */
+#define GMAC4_VERSION		0x00000110	/* GMAC4+ CORE Version */
+
+#define stmmac_mode_init(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, init, __args)
+#define stmmac_is_jumbo_frm(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, is_jumbo_frm, __args)
+#define stmmac_jumbo_frm(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, jumbo_frm, __args)
+#define stmmac_set_16kib_bfsize(__priv, __args...) \
+	stmmac_do_callback(__priv, mode, set_16kib_bfsize, __args)
+#define stmmac_init_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, init_desc3, __args)
+#define stmmac_refill_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, refill_desc3, __args)
+#define stmmac_clean_desc3(__priv, __args...) \
+	stmmac_do_void_callback(__priv, mode, clean_desc3, __args)
+#endif
+
+#define BD_LEN			49152
+#define STMMAC_TX_FR_SIZE	2048
+#define ETH_HLEN		RTE_ETHER_HDR_LEN
+
+/* full duplex */
+#define FULL_DUPLEX		0x00
+
+#define PKT_MAX_BUF_SIZE	1984
+#define OPT_FRAME_SIZE		(PKT_MAX_BUF_SIZE << 16)
+#define STMMAC_MAX_RX_PKT_LEN	3000
+
+#if defined(RTE_ARCH_ARM)
+#if defined(RTE_ARCH_64)
+#define dcbf(p) { asm volatile("dc cvac, %0" : : "r"(p) : "memory"); }
+#define dcbf_64(p) dcbf(p)
+#define dcivac(p) { asm volatile("dc civac, %0" : : "r"(p) : "memory"); }
+#define dcivac_64(p) dcivac(p)
+
+#else /* RTE_ARCH_32 */
+#define dcbf(p) RTE_SET_USED(p)
+#define dcbf_64(p) dcbf(p)
+#define dcivac(p)	RTE_SET_USED(p)
+#endif
+
+#else
+#define dcbf(p) RTE_SET_USED(p)
+#define dcbf_64(p) dcbf(p)
+#define dcivac(p)	RTE_SET_USED(p)
+#endif
+
+#define dsb(opt)	asm volatile("dsb " #opt : : : "memory")
+#define wmb()		dsb(st)
+#define wsb()		dsb(sy)
+#define isb()		asm volatile("isb" : : : "memory")
+#define barrier()	asm volatile ("" : : : "memory");
+
+#if 0
+static inline struct
+bufdesc *stmmac_get_nextdesc(struct bufdesc *bdp, struct bufdesc_prop *bd)
+{
+	return (bdp >= bd->last) ? bd->base
+		: (struct bufdesc *)(((uintptr_t)bdp) + bd->d_size);
+}
+
+static inline int
+fls64(unsigned long word)
+{
+	return (64 - __builtin_clzl(word)) - 1;
+}
+
+static inline struct
+bufdesc *stmmac_get_prevdesc(struct bufdesc *bdp, struct bufdesc_prop *bd)
+{
+	return (bdp <= bd->base) ? bd->last
+		: (struct bufdesc *)(((uintptr_t)bdp) - bd->d_size);
+}
+
+static inline int
+stmmac_get_bd_index(struct bufdesc *bdp, struct bufdesc_prop *bd)
+{
+	return ((const char *)bdp - (const char *)bd->base) >> bd->d_size_log2;
+}
+#endif
+
+uint16_t stmmac_recv_pkts(void *rxq1, struct rte_mbuf **rx_pkts,
+		uint16_t nb_pkts);
+uint16_t stmmac_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts,
+		uint16_t nb_pkts);
+
+#endif /*__STMMAC_ETHDEV_H__*/
diff --git a/drivers/net/stmmac/stmmac_pmd_logs.h b/drivers/net/stmmac/stmmac_pmd_logs.h
new file mode 100644
index 0000000..c4233dc
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_pmd_logs.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _STMMAC_LOGS_H_
+#define _STMMAC_LOGS_H_
+
+#include <rte_log.h>
+
+extern int stmmac_logtype_pmd;
+
+/* PMD related logs */
+#define STMMAC_PMD_LOG(level, fmt, args...) \
+	rte_log(RTE_LOG_ ## level, stmmac_logtype_pmd, "stmmac_net: %s()" \
+		fmt "\n", __func__, ##args)
+
+#define PMD_INIT_FUNC_TRACE() ENET_PMD_LOG(DEBUG, " >>")
+
+#define STMMAC_PMD_DEBUG(fmt, args...) \
+	STMMAC_PMD_LOG(DEBUG, fmt, ## args)
+#define STMMAC_PMD_ERR(fmt, args...) \
+	STMMAC_PMD_LOG(ERR, fmt, ## args)
+#define STMMAC_PMD_INFO(fmt, args...) \
+	STMMAC_PMD_LOG(INFO, fmt, ## args)
+
+#define STMMAC_PMD_WARN(fmt, args...) \
+	STMMAC_PMD_LOG(WARNING, fmt, ## args)
+
+/* DP Logs, toggled out at compile time if level lower than current level */
+#define STMMAC_DP_LOG(level, fmt, args...) \
+	RTE_LOG_DP(level, PMD, fmt, ## args)
+
+#endif /* _STMMAC_LOGS_H_ */
diff --git a/drivers/net/stmmac/stmmac_ptp.h b/drivers/net/stmmac/stmmac_ptp.h
new file mode 100644
index 0000000..48a8413
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_ptp.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef	__STMMAC_PTP_H__
+#define	__STMMAC_PTP_H__
+
+#define PTP_XGMAC_OFFSET	0xd00
+#define	PTP_GMAC4_OFFSET	0xb00
+#define	PTP_GMAC3_X_OFFSET	0x700
+
+/* IEEE 1588 PTP register offsets */
+#define	PTP_TCR		0x00	/* Timestamp Control Reg */
+#define	PTP_SSIR	0x04	/* Sub-Second Increment Reg */
+#define	PTP_STSR	0x08	/* System Time – Seconds Regr */
+#define	PTP_STNSR	0x0c	/* System Time – Nanoseconds Reg */
+#define	PTP_STSUR	0x10	/* System Time – Seconds Update Reg */
+#define	PTP_STNSUR	0x14	/* System Time – Nanoseconds Update Reg */
+#define	PTP_TAR		0x18	/* Timestamp Addend Reg */
+
+#define	PTP_STNSUR_ADDSUB_SHIFT	31
+#define	PTP_DIGITAL_ROLLOVER_MODE	0x3B9ACA00	/* 10e9-1 ns */
+#define	PTP_BINARY_ROLLOVER_MODE	0x80000000	/* ~0.466 ns */
+
+/* PTP Timestamp control register defines */
+#define	PTP_TCR_TSENA		BIT(0)	/* Timestamp Enable */
+#define	PTP_TCR_TSCFUPDT	BIT(1)	/* Timestamp Fine/Coarse Update */
+#define	PTP_TCR_TSINIT		BIT(2)	/* Timestamp Initialize */
+#define	PTP_TCR_TSUPDT		BIT(3)	/* Timestamp Update */
+#define	PTP_TCR_TSTRIG		BIT(4)	/* Timestamp Interrupt Trigger Enable */
+#define	PTP_TCR_TSADDREG	BIT(5)	/* Addend Reg Update */
+#define	PTP_TCR_TSENALL		BIT(8)	/* Enable Timestamp for All Frames */
+#define	PTP_TCR_TSCTRLSSR	BIT(9)	/* Digital or Binary Rollover Control */
+/* Enable PTP packet Processing for Version 2 Format */
+#define	PTP_TCR_TSVER2ENA	BIT(10)
+/* Enable Processing of PTP over Ethernet Frames */
+#define	PTP_TCR_TSIPENA		BIT(11)
+/* Enable Processing of PTP Frames Sent over IPv6-UDP */
+#define	PTP_TCR_TSIPV6ENA	BIT(12)
+/* Enable Processing of PTP Frames Sent over IPv4-UDP */
+#define	PTP_TCR_TSIPV4ENA	BIT(13)
+/* Enable Timestamp Snapshot for Event Messages */
+#define	PTP_TCR_TSEVNTENA	BIT(14)
+/* Enable Snapshot for Messages Relevant to Master */
+#define	PTP_TCR_TSMSTRENA	BIT(15)
+/* Select PTP packets for Taking Snapshots
+ * On gmac4 specifically:
+ * Enable SYNC, Pdelay_Req, Pdelay_Resp when TSEVNTENA is enabled.
+ * or
+ * Enable  SYNC, Follow_Up, Delay_Req, Delay_Resp, Pdelay_Req, Pdelay_Resp,
+ * Pdelay_Resp_Follow_Up if TSEVNTENA is disabled
+ */
+#define	PTP_TCR_SNAPTYPSEL_1	BIT(16)
+/* Enable MAC address for PTP Frame Filtering */
+#define	PTP_TCR_TSENMACADDR	BIT(18)
+
+/* SSIR defines */
+#define	PTP_SSIR_SSINC_MASK		0xff
+#define	GMAC4_PTP_SSIR_SSINC_SHIFT	16
+
+#endif	/* __STMMAC_PTP_H__ */
diff --git a/drivers/net/stmmac/stmmac_regs.h b/drivers/net/stmmac/stmmac_regs.h
new file mode 100644
index 0000000..a0ab908
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_regs.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __STMMAC_REGS_H
+#define __STMMAC_REGS_H
+
+/* Ethernet receive use control and status of buffer descriptor
+ */
+#define RX_BD_TR	((ushort)0x0001) /* Truncated */
+#define RX_BD_OV	((ushort)0x0002) /* Over-run */
+#define RX_BD_CR	((ushort)0x0004) /* CRC or Frame error */
+#define RX_BD_SH	((ushort)0x0008) /* Reserved */
+#define RX_BD_NO	((ushort)0x0010) /* Rcvd non-octet aligned frame */
+#define RX_BD_LG	((ushort)0x0020) /* Rcvd frame length voilation */
+#define RX_BD_FIRST	((ushort)0x0400) /* Reserved */
+#define RX_BD_LAST	((ushort)0x0800) /* last buffer in the frame */
+#define RX_BD_INT	0x00800000
+#define RX_BD_ICE	0x00000020
+#define RX_BD_PCR	0x00000010
+
+/*
+ * 0 The next BD in consecutive location
+ * 1 The next BD in STMMACn_RDSR.
+ */
+#define RX_BD_WRAP	((ushort)0x2000)
+#define RX_BD_EMPTY	((ushort)0x8000) /* BD is empty */
+#define RX_BD_STATS	((ushort)0x013f) /* All buffer descriptor status bits */
+
+/* Ethernet receive use control and status of enhanced buffer descriptor */
+#define BD_STMMAC_RX_VLAN	0x00000004
+
+#define RX_FLAG_CSUM_EN		(RX_BD_ICE | RX_BD_PCR)
+#define RX_FLAG_CSUM_ERR	(RX_BD_ICE | RX_BD_PCR)
+
+/* Ethernet transmit use control and status of buffer descriptor */
+#define TX_BD_TC	((ushort)0x0400) /* Transmit CRC */
+#define TX_BD_LAST	((ushort)0x0800) /* Last in frame */
+#define TX_BD_READY	((ushort)0x8000) /* Data is ready */
+#define TX_BD_STATS	((ushort)0x0fff) /* All buffer descriptor status bits */
+#define TX_BD_WRAP	((ushort)0x2000)
+
+/* Ethernet transmit use control and status of enhanced buffer descriptor */
+#define TX_BD_IINS		0x08000000
+#define TX_BD_PINS		0x10000000
+
+#define STMMAC_RD_START(X)	(((X) == 1) ? STMMAC_RD_START_1 : \
+				(((X) == 2) ? \
+				   STMMAC_RD_START_2 : STMMAC_RD_START_0))
+#define STMMAC_TD_START(X)	(((X) == 1) ? STMMAC_TD_START_1 : \
+				(((X) == 2) ? \
+				   STMMAC_TD_START_2 : STMMAC_TD_START_0))
+#define STMMAC_MRB_SIZE(X)	(((X) == 1) ? STMMAC_MRB_SIZE_1 : \
+				(((X) == 2) ? \
+				   STMMAC_MRB_SIZE_2 : STMMAC_MRB_SIZE_0))
+
+#define STMMAC_ETHEREN		((uint)0x00000002)
+#define STMMAC_TXC_DLY		((uint)0x00010000)
+#define STMMAC_RXC_DLY		((uint)0x00020000)
+
+/* STMMAC MAC is in controller */
+#define QUIRK_HAS_STMMAC_MAC	(1 << 0)
+/* GBIT supported in controller */
+#define QUIRK_GBIT		(1 << 3)
+/* Controller support hardware checksum */
+#define QUIRK_CSUM		(1 << 5)
+/* Controller support hardware vlan */
+#define QUIRK_VLAN		(1 << 6)
+/* RACC register supported by controller */
+#define QUIRK_RACC		(1 << 12)
+/* i.MX8 STMMAC IP version added the feature to generate the delayed TXC or
+ * RXC. For its implementation, STMMAC uses synchronized clocks (250MHz) for
+ * generating delay of 2ns.
+ */
+#define QUIRK_SUPPORT_DELAYED_CLKS	(1 << 18)
+
+#define STMMAC_EIR	0x004 /* Interrupt event register */
+#define STMMAC_EIMR	0x008 /* Interrupt mask register */
+#define STMMAC_RDAR_0	0x010 /* Receive descriptor active register ring0 */
+#define STMMAC_TDAR_0	0x014 /* Transmit descriptor active register ring0 */
+#define STMMAC_ECR	0x024 /* Ethernet control register */
+#define STMMAC_MSCR	0x044 /* MII speed control register */
+#define STMMAC_MIBC	0x064 /* MIB control and status register */
+#define STMMAC_RCR	0x084 /* Receive control register */
+#define STMMAC_TCR	0x0c4 /* Transmit Control register */
+#define STMMAC_PALR	0x0e4 /* MAC address low 32 bits */
+#define STMMAC_PAUR	0x0e8 /* MAC address high 16 bits */
+#define STMMAC_OPD	0x0ec /* Opcode/Pause duration register */
+#define STMMAC_IAUR	0x118 /* hash table 32 bits high */
+#define STMMAC_IALR	0x11c /* hash table 32 bits low */
+#define STMMAC_GAUR	0x120 /* grp hash table 32 bits high */
+#define STMMAC_GALR	0x124 /* grp hash table 32 bits low */
+#define STMMAC_TFWR	0x144 /* transmit FIFO water_mark */
+#define STMMAC_RACC	0x1c4 /* Receive Accelerator function configuration*/
+#define STMMAC_DMA1CFG	0x1d8 /* DMA class based configuration ring1 */
+#define STMMAC_DMA2CFG	0x1dc /* DMA class based Configuration ring2 */
+#define STMMAC_RDAR_1	0x1e0 /* Rx descriptor active register ring1 */
+#define STMMAC_TDAR_1	0x1e4 /* Tx descriptor active register ring1 */
+#define STMMAC_RDAR_2	0x1e8 /* Rx descriptor active register ring2 */
+#define STMMAC_TDAR_2	0x1ec /* Tx descriptor active register ring2 */
+#define STMMAC_RD_START_1	0x160 /* Receive descriptor ring1 start reg */
+#define STMMAC_TD_START_1	0x164 /* Transmit descriptor ring1 start reg */
+#define STMMAC_MRB_SIZE_1	0x168 /* Max receive buffer size reg ring1 */
+#define STMMAC_RD_START_2	0x16c /* Receive descriptor ring2 start reg */
+#define STMMAC_TD_START_2	0x170 /* Transmit descriptor ring2 start reg */
+#define STMMAC_MRB_SIZE_2	0x174 /* Max receive buffer size reg ring2 */
+#define STMMAC_RD_START_0	0x180 /* Receive descriptor ring0 start reg */
+#define STMMAC_TD_START_0	0x184 /* Transmit descriptor ring0 start reg */
+#define STMMAC_MRB_SIZE_0	0x188 /* Max receive buffer size reg ring0*/
+#define STMMAC_R_FIFO_SFL	0x190 /* Rx FIFO full threshold */
+#define STMMAC_R_FIFO_SEM	0x194 /* Rx FIFO empty threshold */
+#define STMMAC_R_FIFO_AEM	0x198 /* Rx FIFO almost empty threshold */
+#define STMMAC_R_FIFO_AFL	0x19c /* Rx FIFO almost full threshold */
+#define STMMAC_FRAME_TRL	0x1b0 /* Frame truncation length */
+
+#endif /*__STMMAC_REGS_H */
diff --git a/drivers/net/stmmac/stmmac_rxtx.c b/drivers/net/stmmac/stmmac_rxtx.c
new file mode 100644
index 0000000..6fd622f
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_rxtx.c
@@ -0,0 +1,222 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <rte_mbuf.h>
+#include <rte_io.h>
+#include <ethdev_driver.h>
+#include "stmmac_regs.h"
+#include "stmmac_ethdev.h"
+#include "common.h"
+#include "stmmac_pmd_logs.h"
+
+#define ETH_FCS_LEN	4
+
+#define roundup(x, y) (					\
+{							\
+	const typeof(y) __y = y;			\
+	(((x) + (__y - 1)) / __y) * __y;		\
+}							\
+)
+#define rounddown(x, y) (				\
+{							\
+	typeof(x) __x = (x);				\
+	__x - (__x % (y));				\
+}							\
+)
+
+/* This function does stmmac_rx_queue processing. Dequeue packet from Rx queue
+ * When update through the ring, just set the empty indicator.
+ */
+uint16_t
+stmmac_recv_pkts(void *rxq, struct rte_mbuf **rx_pkts,
+		uint16_t nb_pkts)
+{
+	struct rte_mempool *pool;
+	struct rte_mbuf *mbuf, *new_mbuf = NULL;
+	unsigned int pkt_len;
+	int pkt_received = 0;
+	void *data;
+	struct stmmac_rx_queue *rx_q = (struct stmmac_rx_queue *)rxq;
+	struct rte_eth_stats *stats;
+	struct dma_desc *p;
+	int status;
+	unsigned int entry = rx_q->cur_rx;
+	int coe, i;
+	void *new_data;
+	dma_addr_t hw_addr;
+
+	stats = &rx_q->private->stats;
+
+	pool = rx_q->pool;
+	coe = rx_q->private->hw->rx_csum;
+
+	/* check if managed by the DMA otherwise go ahead */
+	while (pkt_received < nb_pkts) {
+		entry = rx_q->cur_rx;
+		p = rx_q->dma_rx + entry;
+		/* read the status of the incoming frame */
+		status = rte_le_to_cpu_32(p->des3);
+		if (status & BIT(31))
+			break;
+
+		rte_rmb();
+
+		new_mbuf = rte_pktmbuf_alloc(pool);
+		if (unlikely(new_mbuf == NULL)) {
+			stats->rx_nombuf++;
+			STMMAC_PMD_ERR("%s rx_nombuf\n", __func__);
+			break;
+		}
+
+		new_data = rte_pktmbuf_mtod(new_mbuf, uint8_t *);
+		new_mbuf->data_off += STMMAC_BUFFER_ALIGN;
+		new_data += STMMAC_BUFFER_ALIGN;
+		hw_addr = rte_cpu_to_le_32(rte_pktmbuf_iova(new_mbuf));
+
+		for (i = 0; i <= STMMAC_ALIGN_LENGTH; i += 64) {
+			dcivac((uint8_t *)new_data + i);
+		}
+		dsb(sy);
+
+		pkt_len = stmmac_get_rx_frame_len(rx_q->private, p, coe);
+
+		/*	If frame length is greater than skb buffer size
+		 *	(preallocated during init) then the packet is
+		 *	ignored
+		 */
+		if (pkt_len > 1522) {
+			STMMAC_PMD_ERR("len %d larger than size (%d)\n",
+				       pkt_len, rx_q->private->dma_buf_sz);
+			stats->ierrors++;
+			continue;
+		}
+
+		/* The zero-copy is always used for all the sizes
+		 * in case of GMAC4 because it needs
+		 * to refill the used descriptors, always.
+		 */
+		/* Process the incoming frame. */
+		stats->ipackets++;
+		pkt_len -= ETH_FCS_LEN;
+		stats->ibytes += pkt_len;
+		mbuf = rx_q->rx_mbuf[entry];
+
+		data = rte_pktmbuf_mtod(mbuf, uint8_t *);
+
+		rte_prefetch0(data);
+
+		rte_pktmbuf_append((struct rte_mbuf *)mbuf, pkt_len);
+
+		rx_pkts[pkt_received] = mbuf;
+		pkt_received++;
+
+		mbuf->ol_flags = RTE_MBUF_F_RX_IP_CKSUM_GOOD;
+		p->des3 = 0;
+		p->des2 = 0;
+		p->des1 = 0;
+		p->des0 = 0;
+
+		rx_q->rx_mbuf[entry] = new_mbuf;
+		rx_q->cur_rx = STMMAC_GET_ENTRY(entry, rx_q->dma_rx_size);
+		/* Make sure the updates to rest of the descriptor are
+		 * performed before transferring ownership.
+		 */
+		stmmac_set_desc_addr(rx_q->private, p, hw_addr);
+		stmmac_set_rx_owner(rx_q->private, p, 1);
+	}
+
+	rx_q->rx_tail_addr = rx_q->dma_rx_phy +
+			    (rx_q->cur_rx * sizeof(struct dma_desc));
+	wmb();
+	stmmac_set_rx_tail_ptr(rx_q->private, rx_q->private->ioaddr_v, rx_q->rx_tail_addr, 0);
+
+	return pkt_received;
+}
+
+uint16_t
+stmmac_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
+{
+	struct stmmac_tx_queue *tx_q  =
+			(struct stmmac_tx_queue *)tx_queue;
+	struct rte_eth_stats *stats;
+	struct rte_mbuf *mbuf;
+	int status;
+	unsigned short buflen;
+	unsigned int pkt_transmitted = 0;
+	void *txdata;
+	int tx_st = 1;
+	int i, csum_insertion = 1;
+	unsigned int entry = tx_q->cur_tx, desc_size = sizeof(struct dma_desc);
+	struct dma_desc *desc;
+
+	stats = &tx_q->private->stats;
+	while (tx_st) {
+		if (pkt_transmitted >= nb_pkts) {
+			tx_st = 0;
+			break;
+		}
+
+		entry = tx_q->cur_tx;
+		desc = tx_q->dma_tx + entry;
+
+		status = stmmac_tx_status(tx_q->private, stats, desc);
+		/* Check if the descriptor is owned by the DMA */
+		if (unlikely(status & tx_dma_own)) {
+			stats->oerrors++;
+			continue;
+		}
+
+		rte_rmb();
+		if (tx_q->tx_mbuf[entry]) {
+			rte_pktmbuf_free(tx_q->tx_mbuf[entry]);
+			tx_q->tx_mbuf[entry] = NULL;
+		}
+
+		desc->des3 = 0;
+		desc->des2 = 0;
+		desc->des1 = 0;
+		desc->des0 = 0;
+
+		mbuf = *(tx_pkts);
+		tx_pkts++;
+		tx_q->cur_tx = STMMAC_GET_ENTRY(entry, tx_q->dma_tx_size);
+
+		/* Make sure descriptor fields are read after reading
+		 * the own bit.
+		 */
+		/* Set buffer length and buffer pointer */
+		buflen = rte_pktmbuf_pkt_len(mbuf);
+		stats->opackets++;
+		stats->obytes += buflen;
+
+		if (mbuf->nb_segs > 1) {
+			STMMAC_PMD_ERR("SG not supported");
+			return -1;
+		}
+
+		/* Save mbuf pointer */
+		tx_q->tx_mbuf[entry] = mbuf;
+		pkt_transmitted++;
+
+		txdata = rte_pktmbuf_mtod(mbuf, uint8_t *);
+
+		for (i = 0; i <= buflen; i += 64) {
+			dcbf((uint8_t *)txdata + i);
+		}
+		dsb(sy);
+
+		stmmac_set_desc_addr(tx_q->private, desc, rte_cpu_to_le_32(rte_pktmbuf_iova(mbuf)));
+
+		/* Prepare the first descriptor setting the OWN bit too */
+		stmmac_prepare_tx_desc(tx_q->private, desc, 1, buflen,
+				csum_insertion, tx_q->private->mode, 1, 1,
+				buflen);
+	}
+
+	tx_q->tx_tail_addr = tx_q->dma_tx_phy + (entry * desc_size);
+	wmb();
+	stmmac_set_tx_tail_ptr(tx_q->private, tx_q->private->ioaddr_v, tx_q->tx_tail_addr, 0);
+
+	return pkt_transmitted;
+}
diff --git a/drivers/net/stmmac/stmmac_uio.c b/drivers/net/stmmac/stmmac_uio.c
new file mode 100644
index 0000000..c0a0b0b
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_uio.c
@@ -0,0 +1,304 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <rte_common.h>
+#include <rte_malloc.h>
+#include "stmmac_pmd_logs.h"
+#include "common.h"
+
+static int stmmac_count;
+
+/** @brief Checks if a file name contains a certain substring.
+ * This function assumes a filename format of: [text][number].
+ * @param [in]  filename    File name
+ * @param [in]  match       String to match in file name
+ *
+ * @retval true if file name matches the criteria
+ * @retval false if file name does not match the criteria
+ */
+static bool
+file_name_match_extract(const char filename[], const char match[])
+{
+	char *substr = NULL;
+
+	substr = strstr(filename, match);
+	if (substr == NULL)
+		return false;
+
+	return true;
+}
+
+/*
+ * @brief Reads first line from a file.
+ * Composes file name as: root/subdir/filename
+ *
+ * @param [in]  root     Root path
+ * @param [in]  subdir   Subdirectory name
+ * @param [in]  filename File name
+ * @param [out] line     The first line read from file.
+ *
+ * @retval 0 for success
+ * @retval other value for error
+ */
+static int
+file_read_first_line(const char root[], const char subdir[],
+			const char filename[], char *line)
+{
+	char absolute_file_name[STMMAC_UIO_MAX_ATTR_FILE_NAME];
+	int fd = 0, ret = 0;
+
+	/*compose the file name: root/subdir/filename */
+	memset(absolute_file_name, 0, sizeof(absolute_file_name));
+	snprintf(absolute_file_name, STMMAC_UIO_MAX_ATTR_FILE_NAME,
+		"%s/%s/%s", root, subdir, filename);
+
+	fd = open(absolute_file_name, O_RDONLY);
+	if (fd <= 0)
+		STMMAC_PMD_ERR("Error opening file %s\n", absolute_file_name);
+
+	/* read UIO device name from first line in file */
+	ret = read(fd, line, STMMAC_UIO_MAX_DEVICE_FILE_NAME_LENGTH);
+	if (ret <= 0) {
+		STMMAC_PMD_ERR("Error reading file %s\n", absolute_file_name);
+		return ret;
+	}
+	close(fd);
+
+	/* NULL-ify string */
+	line[ret] = '\0';
+
+	return 0;
+}
+
+/*
+ * @brief Maps rx-tx bd range assigned for a bd ring.
+ *
+ * @param [in] uio_device_fd    UIO device file descriptor
+ * @param [in] uio_device_id    UIO device id
+ * @param [in] uio_map_id       UIO allows maximum 5 different mapping for
+				each device. Maps start with id 0.
+ * @param [out] map_size        Map size.
+ * @param [out] map_addr	Map physical address
+ *
+ * @retval  NULL if failed to map registers
+ * @retval  Virtual address for mapped register address range
+ */
+static void *
+uio_map_mem(int uio_device_fd, int uio_device_id,
+		int uio_map_id, int *map_size, uint64_t *map_addr)
+{
+	void *mapped_address = NULL;
+	unsigned int uio_map_size = 0;
+	unsigned int uio_map_p_addr = 0;
+	char uio_sys_root[STMMAC_UIO_MAX_ATTR_FILE_NAME];
+	char uio_sys_map_subdir[STMMAC_UIO_MAX_ATTR_FILE_NAME];
+	char uio_map_size_str[STMMAC_UIO_MAX_DEVICE_FILE_NAME_LENGTH + 1];
+	char uio_map_p_addr_str[32];
+	int ret = 0;
+
+	/* compose the file name: root/subdir/filename */
+	memset(uio_sys_root, 0, sizeof(uio_sys_root));
+	memset(uio_sys_map_subdir, 0, sizeof(uio_sys_map_subdir));
+	memset(uio_map_size_str, 0, sizeof(uio_map_size_str));
+	memset(uio_map_p_addr_str, 0, sizeof(uio_map_p_addr_str));
+
+	/* Compose string: /sys/class/uio/uioX */
+	snprintf(uio_sys_root, sizeof(uio_sys_root), "%s/%s%d",
+			STMMAC_UIO_DEVICE_SYS_ATTR_PATH, "uio", uio_device_id);
+	/* Compose string: maps/mapY */
+	snprintf(uio_sys_map_subdir, sizeof(uio_sys_map_subdir), "%s%d",
+			STMMAC_UIO_DEVICE_SYS_MAP_ATTR, uio_map_id);
+
+	STMMAC_PMD_INFO("US_UIO: uio_map_mem uio_sys_root: %s, uio_sys_map_subdir: %s, uio_map_size_str: %s\n",
+			uio_sys_root, uio_sys_map_subdir, uio_map_size_str);
+
+	/* Read first (and only) line from file
+	 * /sys/class/uio/uioX/maps/mapY/size
+	 */
+	ret = file_read_first_line(uio_sys_root, uio_sys_map_subdir,
+				"size", uio_map_size_str);
+	if (ret < 0) {
+		STMMAC_PMD_ERR("file_read_first_line() failed\n");
+		return NULL;
+	}
+	ret = file_read_first_line(uio_sys_root, uio_sys_map_subdir,
+				"addr", uio_map_p_addr_str);
+	if (ret < 0) {
+		STMMAC_PMD_ERR("file_read_first_line() failed\n");
+		return NULL;
+	}
+	/* Read mapping size and physical address expressed in hexa(base 16) */
+	uio_map_size = strtol(uio_map_size_str, NULL, 16);
+	uio_map_p_addr = strtol(uio_map_p_addr_str, NULL, 16);
+
+	if (uio_map_id == 0) {
+		/* Map the register address in user space when map_id is 0 */
+		mapped_address = mmap(0 /*dynamically choose virtual address */,
+				uio_map_size, PROT_READ | PROT_WRITE,
+				MAP_SHARED, uio_device_fd, 0);
+	} else if (uio_map_id == 2) {
+		/* Map the BD memory in user space */
+		mapped_address = mmap(NULL, uio_map_size,
+				PROT_READ | PROT_WRITE,
+				MAP_SHARED, uio_device_fd, (2 * MAP_PAGE_SIZE));
+	} else if (uio_map_id == 1) {
+		/* Map the BD memory in user space */
+		mapped_address = mmap(NULL, uio_map_size,
+				PROT_READ | PROT_WRITE,
+				MAP_SHARED, uio_device_fd, (1 * MAP_PAGE_SIZE));
+	}
+
+	if (mapped_address == MAP_FAILED) {
+		STMMAC_PMD_ERR("Failed to map! errno = %d uio job fd = %d,"
+			"uio device id = %d, uio map id = %d\n", errno,
+			uio_device_fd, uio_device_id, uio_map_id);
+		return NULL;
+	}
+
+	/* Save the map size to use it later on for munmap-ing */
+	*map_size = uio_map_size;
+	*map_addr = uio_map_p_addr;
+
+	STMMAC_PMD_INFO("UIO dev[%d] mapped region [id =%d] size 0x%x map_addr_p: 0x%lx, at %p\n",
+		uio_device_id, uio_map_id, uio_map_size, *map_addr, mapped_address);
+
+	return mapped_address;
+}
+
+int
+config_stmmac_uio(struct stmmac_private *private)
+{
+	char uio_device_file_name[32];
+	struct uio_job *uio_job = NULL;
+
+	uio_job = &private->stmmac_uio_job;
+
+	/* Find UIO device created by STMMAC-UIO kernel driver */
+	memset(uio_device_file_name, 0, sizeof(uio_device_file_name));
+	snprintf(uio_device_file_name, sizeof(uio_device_file_name), "%s%d",
+		 STMMAC_UIO_DEVICE_FILE_NAME, uio_job->uio_minor_number);
+
+	STMMAC_PMD_INFO("stmmac_configure uio_name id: %d",
+		       uio_job->uio_minor_number);
+
+	/* Open device file */
+	uio_job->uio_fd = open(uio_device_file_name, O_RDWR);
+	if (uio_job->uio_fd < 0) {
+		STMMAC_PMD_WARN("Unable to open STMMAC_UIO file\n");
+		return -1;
+	}
+
+	STMMAC_PMD_INFO("US_UIO: Open device(%s) file with uio_fd = %d\n",
+			uio_device_file_name, uio_job->uio_fd);
+
+	private->ioaddr_v = uio_map_mem(uio_job->uio_fd,
+		uio_job->uio_minor_number, STMMAC_UIO_REG_MAP_ID,
+		&uio_job->map_size, &uio_job->map_addr);
+	if (private->ioaddr_v == NULL)
+		return -ENOMEM;
+	private->ioaddr_p = uio_job->map_addr;
+	private->reg_size = uio_job->map_size;
+
+	private->bd_addr_r_v = uio_map_mem(uio_job->uio_fd,
+		uio_job->uio_minor_number, STMMAC_UIO_RX_BD_MAP_ID,
+		&uio_job->map_size, &uio_job->map_addr);
+	if (private->bd_addr_r_v == NULL)
+		return -ENOMEM;
+	private->bd_addr_r_p = (uint32_t)uio_job->map_addr;
+	private->bd_r_size[0] = uio_job->map_size;
+
+	private->bd_addr_t_v = uio_map_mem(uio_job->uio_fd,
+		uio_job->uio_minor_number, STMMAC_UIO_TX_BD_MAP_ID,
+		&uio_job->map_size, &uio_job->map_addr);
+	if (private->bd_addr_t_v == NULL)
+		return -ENOMEM;
+	private->bd_addr_t_p = (uint32_t)uio_job->map_addr;
+	private->bd_t_size[0] = uio_job->map_size;
+
+	stmmac_count++;
+
+	return 0;
+}
+
+int
+stmmac_configure(struct stmmac_private *private, int id)
+{
+	char uio_name[32];
+	int uio_minor_number = -1;
+	int ret;
+	DIR *d = NULL;
+	struct dirent *dir;
+
+	d = opendir(STMMAC_UIO_DEVICE_SYS_ATTR_PATH);
+	if (d == NULL) {
+		STMMAC_PMD_ERR("\nError opening directory '%s': %s\n",
+			STMMAC_UIO_DEVICE_SYS_ATTR_PATH, strerror(errno));
+		return -1;
+	}
+
+	/* Iterate through all subdirs */
+	while ((dir = readdir(d)) != NULL) {
+		STMMAC_PMD_INFO("stmmac_configure dir name: %s\n",
+						  dir->d_name);
+		if (!strncmp(dir->d_name, ".", 1) ||
+				!strncmp(dir->d_name, "..", 2))
+			continue;
+
+		if (file_name_match_extract(dir->d_name, "uio")) {
+			/*
+			 * As substring <uio> was found in <d_name>
+			 * read number following <uio> substring in <d_name>
+			 */
+			ret = sscanf(dir->d_name + strlen("uio"), "%d",
+							&uio_minor_number);
+			if (ret < 0)
+				STMMAC_PMD_ERR("Error: not find minor number\n");
+
+			STMMAC_PMD_INFO("stmmac device uio_minor_number: %d\n",
+					uio_minor_number);
+
+			/*
+			 * Open file uioX/name and read first line which
+			 * contains the name for the device. Based on the
+			 * name check if this UIO device is for stmmac.
+			 */
+			memset(uio_name, 0, sizeof(uio_name));
+			ret = file_read_first_line(STMMAC_UIO_DEVICE_SYS_ATTR_PATH,
+					dir->d_name, "name", uio_name);
+			if (ret != 0) {
+				STMMAC_PMD_INFO("file_read_first_line failed\n");
+				closedir(d);
+				return -1;
+			}
+
+			STMMAC_PMD_INFO("stmmac_configure uio_name: %s", uio_name);
+
+			if (file_name_match_extract(uio_name,
+				STMMAC_UIO_DEVICE_NAME) && (id == uio_minor_number)) {
+				private->stmmac_uio_job.uio_minor_number =
+							uio_minor_number;
+				STMMAC_PMD_INFO("stmmac device uio name: %s\n", uio_name);
+			}
+		}
+	}
+	closedir(d);
+	return 0;
+}
+
+void
+stmmac_cleanup(struct stmmac_private *private)
+{
+	munmap(private->ioaddr_v, private->reg_size);
+}
diff --git a/drivers/net/stmmac/stmmac_uio.h b/drivers/net/stmmac/stmmac_uio.h
new file mode 100644
index 0000000..8c96753
--- /dev/null
+++ b/drivers/net/stmmac/stmmac_uio.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright (c) 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+/* Prefix path to sysfs directory where UIO device attributes are exported.
+ * Path for UIO device X is /sys/class/uio/uioX
+ */
+#define STMMAC_UIO_DEVICE_SYS_ATTR_PATH	"/sys/class/uio"
+
+/* Subfolder in sysfs where mapping attributes are exported
+ * for each UIO device. Path for mapping Y for device X is:
+ * /sys/class/uio/uioX/maps/mapY
+ */
+#define STMMAC_UIO_DEVICE_SYS_MAP_ATTR	"maps/map"
+
+/* Name of UIO device file prefix. Each UIO device will have a device file
+ * /dev/uioX, where X is the minor device number.
+ */
+#define STMMAC_UIO_DEVICE_FILE_NAME	"/dev/uio"
+/*
+ * Name of UIO device. User space STMMAC will have a corresponding
+ * UIO device.
+ * Maximum length is #STMMAC_UIO_MAX_DEVICE_NAME_LENGTH.
+ *
+ * @note  Must be kept in sync with STMMAC kernel driver
+ * define #STMMAC_UIO_DEVICE_NAME !
+ */
+#define STMMAC_UIO_DEVICE_NAME     "uio_eth"
+
+/* Maximum length for the name of an UIO device file.
+ * Device file name format is: /dev/uioX.
+ */
+#define STMMAC_UIO_MAX_DEVICE_FILE_NAME_LENGTH	30
+
+/* Maximum length for the name of an attribute file for an UIO device.
+ * Attribute files are exported in sysfs and have the name formatted as:
+ * /sys/class/uio/uioX/<attribute_file_name>
+ */
+#define STMMAC_UIO_MAX_ATTR_FILE_NAME	100
+
+/* The id for the mapping used to export STMMAC registers and BD memory to
+ * user space through UIO device.
+ */
+#define STMMAC_UIO_REG_MAP_ID		0
+#define STMMAC_UIO_RX_BD_MAP_ID	1
+#define STMMAC_UIO_TX_BD_MAP_ID	2
+#define STMMAC_UIO_RX_BD1_MAP_ID	3
+#define STMMAC_UIO_TX_BD1_MAP_ID	4
+
+#define MAP_PAGE_SIZE			4096
+
+struct uio_job {
+	uint32_t fec_id;
+	int uio_fd;
+	void *bd_start_addr;
+	void *register_base_addr;
+	int map_size;
+	uint64_t map_addr;
+	int uio_minor_number;
+};
+
+int stmmac_configure(struct stmmac_private *private, int id);
+int config_stmmac_uio(struct stmmac_private *private);
+void stmmac_uio_init(void);
+void stmmac_cleanup(struct stmmac_private *private);
diff --git a/drivers/net/stmmac/version.map b/drivers/net/stmmac/version.map
new file mode 100644
index 0000000..c2e0723
--- /dev/null
+++ b/drivers/net/stmmac/version.map
@@ -0,0 +1,3 @@
+DPDK_22 {
+	local: *;
+};
diff --git a/lib/ethdev/rte_ethdev.h b/lib/ethdev/rte_ethdev.h
index 0be04c5..15f8835 100644
--- a/lib/ethdev/rte_ethdev.h
+++ b/lib/ethdev/rte_ethdev.h
@@ -1708,8 +1708,8 @@
  * These are used if an application requests default parameters
  * but the PMD does not provide preferred values.
  */
-#define RTE_ETH_DEV_FALLBACK_RX_RINGSIZE 512
-#define RTE_ETH_DEV_FALLBACK_TX_RINGSIZE 512
+#define RTE_ETH_DEV_FALLBACK_RX_RINGSIZE 1024
+#define RTE_ETH_DEV_FALLBACK_TX_RINGSIZE 1024
 #define RTE_ETH_DEV_FALLBACK_RX_NBQUEUES 1
 #define RTE_ETH_DEV_FALLBACK_TX_NBQUEUES 1
 
